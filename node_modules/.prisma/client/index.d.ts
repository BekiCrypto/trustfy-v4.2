
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model TradeReview
 * 
 */
export type TradeReview = $Result.DefaultSelection<Prisma.$TradeReviewPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Escrow
 * 
 */
export type Escrow = $Result.DefaultSelection<Prisma.$EscrowPayload>
/**
 * Model EscrowTimeline
 * 
 */
export type EscrowTimeline = $Result.DefaultSelection<Prisma.$EscrowTimelinePayload>
/**
 * Model EscrowMessage
 * 
 */
export type EscrowMessage = $Result.DefaultSelection<Prisma.$EscrowMessagePayload>
/**
 * Model EscrowPaymentInstruction
 * 
 */
export type EscrowPaymentInstruction = $Result.DefaultSelection<Prisma.$EscrowPaymentInstructionPayload>
/**
 * Model EscrowFiatStatus
 * 
 */
export type EscrowFiatStatus = $Result.DefaultSelection<Prisma.$EscrowFiatStatusPayload>
/**
 * Model EvidenceItem
 * 
 */
export type EvidenceItem = $Result.DefaultSelection<Prisma.$EvidenceItemPayload>
/**
 * Model Dispute
 * 
 */
export type Dispute = $Result.DefaultSelection<Prisma.$DisputePayload>
/**
 * Model IndexerCheckpoint
 * 
 */
export type IndexerCheckpoint = $Result.DefaultSelection<Prisma.$IndexerCheckpointPayload>
/**
 * Model TokenRegistry
 * 
 */
export type TokenRegistry = $Result.DefaultSelection<Prisma.$TokenRegistryPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Nonce
 * 
 */
export type Nonce = $Result.DefaultSelection<Prisma.$NoncePayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ReferralCode
 * 
 */
export type ReferralCode = $Result.DefaultSelection<Prisma.$ReferralCodePayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model CommissionLedger
 * 
 */
export type CommissionLedger = $Result.DefaultSelection<Prisma.$CommissionLedgerPayload>
/**
 * Model ReferralWallet
 * 
 */
export type ReferralWallet = $Result.DefaultSelection<Prisma.$ReferralWalletPayload>
/**
 * Model ReferralWalletTransaction
 * 
 */
export type ReferralWalletTransaction = $Result.DefaultSelection<Prisma.$ReferralWalletTransactionPayload>
/**
 * Model PrimeStatus
 * 
 */
export type PrimeStatus = $Result.DefaultSelection<Prisma.$PrimeStatusPayload>
/**
 * Model ReferralConfig
 * 
 */
export type ReferralConfig = $Result.DefaultSelection<Prisma.$ReferralConfigPayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.tradeReview`: Exposes CRUD operations for the **TradeReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeReviews
    * const tradeReviews = await prisma.tradeReview.findMany()
    * ```
    */
  get tradeReview(): Prisma.TradeReviewDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.escrow`: Exposes CRUD operations for the **Escrow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escrows
    * const escrows = await prisma.escrow.findMany()
    * ```
    */
  get escrow(): Prisma.EscrowDelegate<ExtArgs>;

  /**
   * `prisma.escrowTimeline`: Exposes CRUD operations for the **EscrowTimeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowTimelines
    * const escrowTimelines = await prisma.escrowTimeline.findMany()
    * ```
    */
  get escrowTimeline(): Prisma.EscrowTimelineDelegate<ExtArgs>;

  /**
   * `prisma.escrowMessage`: Exposes CRUD operations for the **EscrowMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowMessages
    * const escrowMessages = await prisma.escrowMessage.findMany()
    * ```
    */
  get escrowMessage(): Prisma.EscrowMessageDelegate<ExtArgs>;

  /**
   * `prisma.escrowPaymentInstruction`: Exposes CRUD operations for the **EscrowPaymentInstruction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowPaymentInstructions
    * const escrowPaymentInstructions = await prisma.escrowPaymentInstruction.findMany()
    * ```
    */
  get escrowPaymentInstruction(): Prisma.EscrowPaymentInstructionDelegate<ExtArgs>;

  /**
   * `prisma.escrowFiatStatus`: Exposes CRUD operations for the **EscrowFiatStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowFiatStatuses
    * const escrowFiatStatuses = await prisma.escrowFiatStatus.findMany()
    * ```
    */
  get escrowFiatStatus(): Prisma.EscrowFiatStatusDelegate<ExtArgs>;

  /**
   * `prisma.evidenceItem`: Exposes CRUD operations for the **EvidenceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvidenceItems
    * const evidenceItems = await prisma.evidenceItem.findMany()
    * ```
    */
  get evidenceItem(): Prisma.EvidenceItemDelegate<ExtArgs>;

  /**
   * `prisma.dispute`: Exposes CRUD operations for the **Dispute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disputes
    * const disputes = await prisma.dispute.findMany()
    * ```
    */
  get dispute(): Prisma.DisputeDelegate<ExtArgs>;

  /**
   * `prisma.indexerCheckpoint`: Exposes CRUD operations for the **IndexerCheckpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndexerCheckpoints
    * const indexerCheckpoints = await prisma.indexerCheckpoint.findMany()
    * ```
    */
  get indexerCheckpoint(): Prisma.IndexerCheckpointDelegate<ExtArgs>;

  /**
   * `prisma.tokenRegistry`: Exposes CRUD operations for the **TokenRegistry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenRegistries
    * const tokenRegistries = await prisma.tokenRegistry.findMany()
    * ```
    */
  get tokenRegistry(): Prisma.TokenRegistryDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.nonce`: Exposes CRUD operations for the **Nonce** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nonces
    * const nonces = await prisma.nonce.findMany()
    * ```
    */
  get nonce(): Prisma.NonceDelegate<ExtArgs>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.referralCode`: Exposes CRUD operations for the **ReferralCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralCodes
    * const referralCodes = await prisma.referralCode.findMany()
    * ```
    */
  get referralCode(): Prisma.ReferralCodeDelegate<ExtArgs>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs>;

  /**
   * `prisma.commissionLedger`: Exposes CRUD operations for the **CommissionLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommissionLedgers
    * const commissionLedgers = await prisma.commissionLedger.findMany()
    * ```
    */
  get commissionLedger(): Prisma.CommissionLedgerDelegate<ExtArgs>;

  /**
   * `prisma.referralWallet`: Exposes CRUD operations for the **ReferralWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralWallets
    * const referralWallets = await prisma.referralWallet.findMany()
    * ```
    */
  get referralWallet(): Prisma.ReferralWalletDelegate<ExtArgs>;

  /**
   * `prisma.referralWalletTransaction`: Exposes CRUD operations for the **ReferralWalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralWalletTransactions
    * const referralWalletTransactions = await prisma.referralWalletTransaction.findMany()
    * ```
    */
  get referralWalletTransaction(): Prisma.ReferralWalletTransactionDelegate<ExtArgs>;

  /**
   * `prisma.primeStatus`: Exposes CRUD operations for the **PrimeStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrimeStatuses
    * const primeStatuses = await prisma.primeStatus.findMany()
    * ```
    */
  get primeStatus(): Prisma.PrimeStatusDelegate<ExtArgs>;

  /**
   * `prisma.referralConfig`: Exposes CRUD operations for the **ReferralConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralConfigs
    * const referralConfigs = await prisma.referralConfig.findMany()
    * ```
    */
  get referralConfig(): Prisma.ReferralConfigDelegate<ExtArgs>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    TradeReview: 'TradeReview',
    Role: 'Role',
    Escrow: 'Escrow',
    EscrowTimeline: 'EscrowTimeline',
    EscrowMessage: 'EscrowMessage',
    EscrowPaymentInstruction: 'EscrowPaymentInstruction',
    EscrowFiatStatus: 'EscrowFiatStatus',
    EvidenceItem: 'EvidenceItem',
    Dispute: 'Dispute',
    IndexerCheckpoint: 'IndexerCheckpoint',
    TokenRegistry: 'TokenRegistry',
    AuditLog: 'AuditLog',
    Nonce: 'Nonce',
    NotificationPreference: 'NotificationPreference',
    Notification: 'Notification',
    ReferralCode: 'ReferralCode',
    Referral: 'Referral',
    CommissionLedger: 'CommissionLedger',
    ReferralWallet: 'ReferralWallet',
    ReferralWalletTransaction: 'ReferralWalletTransaction',
    PrimeStatus: 'PrimeStatus',
    ReferralConfig: 'ReferralConfig',
    Offer: 'Offer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "tradeReview" | "role" | "escrow" | "escrowTimeline" | "escrowMessage" | "escrowPaymentInstruction" | "escrowFiatStatus" | "evidenceItem" | "dispute" | "indexerCheckpoint" | "tokenRegistry" | "auditLog" | "nonce" | "notificationPreference" | "notification" | "referralCode" | "referral" | "commissionLedger" | "referralWallet" | "referralWalletTransaction" | "primeStatus" | "referralConfig" | "offer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      TradeReview: {
        payload: Prisma.$TradeReviewPayload<ExtArgs>
        fields: Prisma.TradeReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload>
          }
          findFirst: {
            args: Prisma.TradeReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload>
          }
          findMany: {
            args: Prisma.TradeReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload>[]
          }
          create: {
            args: Prisma.TradeReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload>
          }
          createMany: {
            args: Prisma.TradeReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload>[]
          }
          delete: {
            args: Prisma.TradeReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload>
          }
          update: {
            args: Prisma.TradeReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload>
          }
          deleteMany: {
            args: Prisma.TradeReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TradeReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeReviewPayload>
          }
          aggregate: {
            args: Prisma.TradeReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeReview>
          }
          groupBy: {
            args: Prisma.TradeReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeReviewCountArgs<ExtArgs>
            result: $Utils.Optional<TradeReviewCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Escrow: {
        payload: Prisma.$EscrowPayload<ExtArgs>
        fields: Prisma.EscrowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          findFirst: {
            args: Prisma.EscrowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          findMany: {
            args: Prisma.EscrowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>[]
          }
          create: {
            args: Prisma.EscrowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          createMany: {
            args: Prisma.EscrowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>[]
          }
          delete: {
            args: Prisma.EscrowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          update: {
            args: Prisma.EscrowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          deleteMany: {
            args: Prisma.EscrowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          aggregate: {
            args: Prisma.EscrowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrow>
          }
          groupBy: {
            args: Prisma.EscrowGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowCountAggregateOutputType> | number
          }
        }
      }
      EscrowTimeline: {
        payload: Prisma.$EscrowTimelinePayload<ExtArgs>
        fields: Prisma.EscrowTimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowTimelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowTimelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          findFirst: {
            args: Prisma.EscrowTimelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowTimelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          findMany: {
            args: Prisma.EscrowTimelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>[]
          }
          create: {
            args: Prisma.EscrowTimelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          createMany: {
            args: Prisma.EscrowTimelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowTimelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>[]
          }
          delete: {
            args: Prisma.EscrowTimelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          update: {
            args: Prisma.EscrowTimelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          deleteMany: {
            args: Prisma.EscrowTimelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowTimelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowTimelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          aggregate: {
            args: Prisma.EscrowTimelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrowTimeline>
          }
          groupBy: {
            args: Prisma.EscrowTimelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowTimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowTimelineCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowTimelineCountAggregateOutputType> | number
          }
        }
      }
      EscrowMessage: {
        payload: Prisma.$EscrowMessagePayload<ExtArgs>
        fields: Prisma.EscrowMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          findFirst: {
            args: Prisma.EscrowMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          findMany: {
            args: Prisma.EscrowMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>[]
          }
          create: {
            args: Prisma.EscrowMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          createMany: {
            args: Prisma.EscrowMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>[]
          }
          delete: {
            args: Prisma.EscrowMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          update: {
            args: Prisma.EscrowMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          deleteMany: {
            args: Prisma.EscrowMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          aggregate: {
            args: Prisma.EscrowMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrowMessage>
          }
          groupBy: {
            args: Prisma.EscrowMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowMessageCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowMessageCountAggregateOutputType> | number
          }
        }
      }
      EscrowPaymentInstruction: {
        payload: Prisma.$EscrowPaymentInstructionPayload<ExtArgs>
        fields: Prisma.EscrowPaymentInstructionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowPaymentInstructionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowPaymentInstructionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          findFirst: {
            args: Prisma.EscrowPaymentInstructionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowPaymentInstructionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          findMany: {
            args: Prisma.EscrowPaymentInstructionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>[]
          }
          create: {
            args: Prisma.EscrowPaymentInstructionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          createMany: {
            args: Prisma.EscrowPaymentInstructionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowPaymentInstructionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>[]
          }
          delete: {
            args: Prisma.EscrowPaymentInstructionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          update: {
            args: Prisma.EscrowPaymentInstructionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          deleteMany: {
            args: Prisma.EscrowPaymentInstructionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowPaymentInstructionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowPaymentInstructionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          aggregate: {
            args: Prisma.EscrowPaymentInstructionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrowPaymentInstruction>
          }
          groupBy: {
            args: Prisma.EscrowPaymentInstructionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowPaymentInstructionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowPaymentInstructionCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowPaymentInstructionCountAggregateOutputType> | number
          }
        }
      }
      EscrowFiatStatus: {
        payload: Prisma.$EscrowFiatStatusPayload<ExtArgs>
        fields: Prisma.EscrowFiatStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowFiatStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowFiatStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          findFirst: {
            args: Prisma.EscrowFiatStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowFiatStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          findMany: {
            args: Prisma.EscrowFiatStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>[]
          }
          create: {
            args: Prisma.EscrowFiatStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          createMany: {
            args: Prisma.EscrowFiatStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowFiatStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>[]
          }
          delete: {
            args: Prisma.EscrowFiatStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          update: {
            args: Prisma.EscrowFiatStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          deleteMany: {
            args: Prisma.EscrowFiatStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowFiatStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowFiatStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          aggregate: {
            args: Prisma.EscrowFiatStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrowFiatStatus>
          }
          groupBy: {
            args: Prisma.EscrowFiatStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowFiatStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowFiatStatusCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowFiatStatusCountAggregateOutputType> | number
          }
        }
      }
      EvidenceItem: {
        payload: Prisma.$EvidenceItemPayload<ExtArgs>
        fields: Prisma.EvidenceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          findFirst: {
            args: Prisma.EvidenceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          findMany: {
            args: Prisma.EvidenceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>[]
          }
          create: {
            args: Prisma.EvidenceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          createMany: {
            args: Prisma.EvidenceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>[]
          }
          delete: {
            args: Prisma.EvidenceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          update: {
            args: Prisma.EvidenceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          deleteMany: {
            args: Prisma.EvidenceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvidenceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          aggregate: {
            args: Prisma.EvidenceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidenceItem>
          }
          groupBy: {
            args: Prisma.EvidenceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenceItemCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenceItemCountAggregateOutputType> | number
          }
        }
      }
      Dispute: {
        payload: Prisma.$DisputePayload<ExtArgs>
        fields: Prisma.DisputeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisputeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisputeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          findFirst: {
            args: Prisma.DisputeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisputeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          findMany: {
            args: Prisma.DisputeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          create: {
            args: Prisma.DisputeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          createMany: {
            args: Prisma.DisputeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisputeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          delete: {
            args: Prisma.DisputeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          update: {
            args: Prisma.DisputeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          deleteMany: {
            args: Prisma.DisputeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisputeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisputeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          aggregate: {
            args: Prisma.DisputeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispute>
          }
          groupBy: {
            args: Prisma.DisputeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisputeCountArgs<ExtArgs>
            result: $Utils.Optional<DisputeCountAggregateOutputType> | number
          }
        }
      }
      IndexerCheckpoint: {
        payload: Prisma.$IndexerCheckpointPayload<ExtArgs>
        fields: Prisma.IndexerCheckpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndexerCheckpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndexerCheckpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          findFirst: {
            args: Prisma.IndexerCheckpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndexerCheckpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          findMany: {
            args: Prisma.IndexerCheckpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>[]
          }
          create: {
            args: Prisma.IndexerCheckpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          createMany: {
            args: Prisma.IndexerCheckpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndexerCheckpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>[]
          }
          delete: {
            args: Prisma.IndexerCheckpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          update: {
            args: Prisma.IndexerCheckpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          deleteMany: {
            args: Prisma.IndexerCheckpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndexerCheckpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndexerCheckpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          aggregate: {
            args: Prisma.IndexerCheckpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndexerCheckpoint>
          }
          groupBy: {
            args: Prisma.IndexerCheckpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndexerCheckpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndexerCheckpointCountArgs<ExtArgs>
            result: $Utils.Optional<IndexerCheckpointCountAggregateOutputType> | number
          }
        }
      }
      TokenRegistry: {
        payload: Prisma.$TokenRegistryPayload<ExtArgs>
        fields: Prisma.TokenRegistryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenRegistryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenRegistryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          findFirst: {
            args: Prisma.TokenRegistryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenRegistryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          findMany: {
            args: Prisma.TokenRegistryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>[]
          }
          create: {
            args: Prisma.TokenRegistryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          createMany: {
            args: Prisma.TokenRegistryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenRegistryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>[]
          }
          delete: {
            args: Prisma.TokenRegistryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          update: {
            args: Prisma.TokenRegistryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          deleteMany: {
            args: Prisma.TokenRegistryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenRegistryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenRegistryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          aggregate: {
            args: Prisma.TokenRegistryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenRegistry>
          }
          groupBy: {
            args: Prisma.TokenRegistryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenRegistryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenRegistryCountArgs<ExtArgs>
            result: $Utils.Optional<TokenRegistryCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Nonce: {
        payload: Prisma.$NoncePayload<ExtArgs>
        fields: Prisma.NonceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NonceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NonceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          findFirst: {
            args: Prisma.NonceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NonceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          findMany: {
            args: Prisma.NonceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>[]
          }
          create: {
            args: Prisma.NonceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          createMany: {
            args: Prisma.NonceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NonceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>[]
          }
          delete: {
            args: Prisma.NonceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          update: {
            args: Prisma.NonceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          deleteMany: {
            args: Prisma.NonceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NonceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NonceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          aggregate: {
            args: Prisma.NonceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNonce>
          }
          groupBy: {
            args: Prisma.NonceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NonceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NonceCountArgs<ExtArgs>
            result: $Utils.Optional<NonceCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ReferralCode: {
        payload: Prisma.$ReferralCodePayload<ExtArgs>
        fields: Prisma.ReferralCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          findFirst: {
            args: Prisma.ReferralCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          findMany: {
            args: Prisma.ReferralCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>[]
          }
          create: {
            args: Prisma.ReferralCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          createMany: {
            args: Prisma.ReferralCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>[]
          }
          delete: {
            args: Prisma.ReferralCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          update: {
            args: Prisma.ReferralCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          deleteMany: {
            args: Prisma.ReferralCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralCodePayload>
          }
          aggregate: {
            args: Prisma.ReferralCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralCode>
          }
          groupBy: {
            args: Prisma.ReferralCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCodeCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCodeCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      CommissionLedger: {
        payload: Prisma.$CommissionLedgerPayload<ExtArgs>
        fields: Prisma.CommissionLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload>
          }
          findFirst: {
            args: Prisma.CommissionLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload>
          }
          findMany: {
            args: Prisma.CommissionLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload>[]
          }
          create: {
            args: Prisma.CommissionLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload>
          }
          createMany: {
            args: Prisma.CommissionLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload>[]
          }
          delete: {
            args: Prisma.CommissionLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload>
          }
          update: {
            args: Prisma.CommissionLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload>
          }
          deleteMany: {
            args: Prisma.CommissionLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommissionLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionLedgerPayload>
          }
          aggregate: {
            args: Prisma.CommissionLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommissionLedger>
          }
          groupBy: {
            args: Prisma.CommissionLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionLedgerCountAggregateOutputType> | number
          }
        }
      }
      ReferralWallet: {
        payload: Prisma.$ReferralWalletPayload<ExtArgs>
        fields: Prisma.ReferralWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload>
          }
          findFirst: {
            args: Prisma.ReferralWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload>
          }
          findMany: {
            args: Prisma.ReferralWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload>[]
          }
          create: {
            args: Prisma.ReferralWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload>
          }
          createMany: {
            args: Prisma.ReferralWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload>[]
          }
          delete: {
            args: Prisma.ReferralWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload>
          }
          update: {
            args: Prisma.ReferralWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload>
          }
          deleteMany: {
            args: Prisma.ReferralWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletPayload>
          }
          aggregate: {
            args: Prisma.ReferralWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralWallet>
          }
          groupBy: {
            args: Prisma.ReferralWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralWalletCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralWalletCountAggregateOutputType> | number
          }
        }
      }
      ReferralWalletTransaction: {
        payload: Prisma.$ReferralWalletTransactionPayload<ExtArgs>
        fields: Prisma.ReferralWalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralWalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralWalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.ReferralWalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralWalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload>
          }
          findMany: {
            args: Prisma.ReferralWalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload>[]
          }
          create: {
            args: Prisma.ReferralWalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload>
          }
          createMany: {
            args: Prisma.ReferralWalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralWalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.ReferralWalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload>
          }
          update: {
            args: Prisma.ReferralWalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.ReferralWalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralWalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralWalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralWalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.ReferralWalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralWalletTransaction>
          }
          groupBy: {
            args: Prisma.ReferralWalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralWalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralWalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralWalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      PrimeStatus: {
        payload: Prisma.$PrimeStatusPayload<ExtArgs>
        fields: Prisma.PrimeStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrimeStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrimeStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload>
          }
          findFirst: {
            args: Prisma.PrimeStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrimeStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload>
          }
          findMany: {
            args: Prisma.PrimeStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload>[]
          }
          create: {
            args: Prisma.PrimeStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload>
          }
          createMany: {
            args: Prisma.PrimeStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrimeStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload>[]
          }
          delete: {
            args: Prisma.PrimeStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload>
          }
          update: {
            args: Prisma.PrimeStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload>
          }
          deleteMany: {
            args: Prisma.PrimeStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrimeStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrimeStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrimeStatusPayload>
          }
          aggregate: {
            args: Prisma.PrimeStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrimeStatus>
          }
          groupBy: {
            args: Prisma.PrimeStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrimeStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrimeStatusCountArgs<ExtArgs>
            result: $Utils.Optional<PrimeStatusCountAggregateOutputType> | number
          }
        }
      }
      ReferralConfig: {
        payload: Prisma.$ReferralConfigPayload<ExtArgs>
        fields: Prisma.ReferralConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload>
          }
          findFirst: {
            args: Prisma.ReferralConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload>
          }
          findMany: {
            args: Prisma.ReferralConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload>[]
          }
          create: {
            args: Prisma.ReferralConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload>
          }
          createMany: {
            args: Prisma.ReferralConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload>[]
          }
          delete: {
            args: Prisma.ReferralConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload>
          }
          update: {
            args: Prisma.ReferralConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload>
          }
          deleteMany: {
            args: Prisma.ReferralConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralConfigPayload>
          }
          aggregate: {
            args: Prisma.ReferralConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralConfig>
          }
          groupBy: {
            args: Prisma.ReferralConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralConfigCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roles: number
    referralCodes: number
    referralsMade: number
    referralsReceived: number
    notifications: number
    reviewsGiven: number
    reviewsReceived: number
    offers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    referralCodes?: boolean | UserCountOutputTypeCountReferralCodesArgs
    referralsMade?: boolean | UserCountOutputTypeCountReferralsMadeArgs
    referralsReceived?: boolean | UserCountOutputTypeCountReferralsReceivedArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    reviewsGiven?: boolean | UserCountOutputTypeCountReviewsGivenArgs
    reviewsReceived?: boolean | UserCountOutputTypeCountReviewsReceivedArgs
    offers?: boolean | UserCountOutputTypeCountOffersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }


  /**
   * Count Type EscrowCountOutputType
   */

  export type EscrowCountOutputType = {
    timeline: number
    messages: number
    fiatStatuses: number
    evidence: number
    reviews: number
  }

  export type EscrowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeline?: boolean | EscrowCountOutputTypeCountTimelineArgs
    messages?: boolean | EscrowCountOutputTypeCountMessagesArgs
    fiatStatuses?: boolean | EscrowCountOutputTypeCountFiatStatusesArgs
    evidence?: boolean | EscrowCountOutputTypeCountEvidenceArgs
    reviews?: boolean | EscrowCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowCountOutputType
     */
    select?: EscrowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowTimelineWhereInput
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowMessageWhereInput
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountFiatStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowFiatStatusWhereInput
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceItemWhereInput
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeReviewWhereInput
  }


  /**
   * Count Type ReferralCodeCountOutputType
   */

  export type ReferralCodeCountOutputType = {
    referrals: number
  }

  export type ReferralCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrals?: boolean | ReferralCodeCountOutputTypeCountReferralsArgs
  }

  // Custom InputTypes
  /**
   * ReferralCodeCountOutputType without action
   */
  export type ReferralCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCodeCountOutputType
     */
    select?: ReferralCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferralCodeCountOutputType without action
   */
  export type ReferralCodeCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }


  /**
   * Count Type ReferralCountOutputType
   */

  export type ReferralCountOutputType = {
    commissions: number
  }

  export type ReferralCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissions?: boolean | ReferralCountOutputTypeCountCommissionsArgs
  }

  // Custom InputTypes
  /**
   * ReferralCountOutputType without action
   */
  export type ReferralCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCountOutputType
     */
    select?: ReferralCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferralCountOutputType without action
   */
  export type ReferralCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionLedgerWhereInput
  }


  /**
   * Count Type ReferralWalletCountOutputType
   */

  export type ReferralWalletCountOutputType = {
    transactions: number
  }

  export type ReferralWalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ReferralWalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ReferralWalletCountOutputType without action
   */
  export type ReferralWalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletCountOutputType
     */
    select?: ReferralWalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferralWalletCountOutputType without action
   */
  export type ReferralWalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWalletTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    reputationScore: number | null
    successfulTrades: number | null
    totalVolume: Decimal | null
  }

  export type UserSumAggregateOutputType = {
    reputationScore: number | null
    successfulTrades: number | null
    totalVolume: Decimal | null
  }

  export type UserMinAggregateOutputType = {
    address: string | null
    displayName: string | null
    bio: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
    reputationScore: number | null
    successfulTrades: number | null
    totalVolume: Decimal | null
  }

  export type UserMaxAggregateOutputType = {
    address: string | null
    displayName: string | null
    bio: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
    reputationScore: number | null
    successfulTrades: number | null
    totalVolume: Decimal | null
  }

  export type UserCountAggregateOutputType = {
    address: number
    displayName: number
    bio: number
    paymentMethods: number
    createdAt: number
    lastLoginAt: number
    reputationScore: number
    successfulTrades: number
    totalVolume: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    reputationScore?: true
    successfulTrades?: true
    totalVolume?: true
  }

  export type UserSumAggregateInputType = {
    reputationScore?: true
    successfulTrades?: true
    totalVolume?: true
  }

  export type UserMinAggregateInputType = {
    address?: true
    displayName?: true
    bio?: true
    createdAt?: true
    lastLoginAt?: true
    reputationScore?: true
    successfulTrades?: true
    totalVolume?: true
  }

  export type UserMaxAggregateInputType = {
    address?: true
    displayName?: true
    bio?: true
    createdAt?: true
    lastLoginAt?: true
    reputationScore?: true
    successfulTrades?: true
    totalVolume?: true
  }

  export type UserCountAggregateInputType = {
    address?: true
    displayName?: true
    bio?: true
    paymentMethods?: true
    createdAt?: true
    lastLoginAt?: true
    reputationScore?: true
    successfulTrades?: true
    totalVolume?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    address: string
    displayName: string | null
    bio: string | null
    paymentMethods: string[]
    createdAt: Date
    lastLoginAt: Date | null
    reputationScore: number
    successfulTrades: number
    totalVolume: Decimal
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    displayName?: boolean
    bio?: boolean
    paymentMethods?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    reputationScore?: boolean
    successfulTrades?: boolean
    totalVolume?: boolean
    roles?: boolean | User$rolesArgs<ExtArgs>
    notificationPreference?: boolean | User$notificationPreferenceArgs<ExtArgs>
    referralCodes?: boolean | User$referralCodesArgs<ExtArgs>
    referralsMade?: boolean | User$referralsMadeArgs<ExtArgs>
    referralsReceived?: boolean | User$referralsReceivedArgs<ExtArgs>
    referralWallet?: boolean | User$referralWalletArgs<ExtArgs>
    prime?: boolean | User$primeArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    offers?: boolean | User$offersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    displayName?: boolean
    bio?: boolean
    paymentMethods?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    reputationScore?: boolean
    successfulTrades?: boolean
    totalVolume?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    address?: boolean
    displayName?: boolean
    bio?: boolean
    paymentMethods?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    reputationScore?: boolean
    successfulTrades?: boolean
    totalVolume?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | User$rolesArgs<ExtArgs>
    notificationPreference?: boolean | User$notificationPreferenceArgs<ExtArgs>
    referralCodes?: boolean | User$referralCodesArgs<ExtArgs>
    referralsMade?: boolean | User$referralsMadeArgs<ExtArgs>
    referralsReceived?: boolean | User$referralsReceivedArgs<ExtArgs>
    referralWallet?: boolean | User$referralWalletArgs<ExtArgs>
    prime?: boolean | User$primeArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    offers?: boolean | User$offersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      roles: Prisma.$RolePayload<ExtArgs>[]
      notificationPreference: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      referralCodes: Prisma.$ReferralCodePayload<ExtArgs>[]
      referralsMade: Prisma.$ReferralPayload<ExtArgs>[]
      referralsReceived: Prisma.$ReferralPayload<ExtArgs>[]
      referralWallet: Prisma.$ReferralWalletPayload<ExtArgs> | null
      prime: Prisma.$PrimeStatusPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      reviewsGiven: Prisma.$TradeReviewPayload<ExtArgs>[]
      reviewsReceived: Prisma.$TradeReviewPayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      address: string
      displayName: string | null
      bio: string | null
      paymentMethods: string[]
      createdAt: Date
      lastLoginAt: Date | null
      reputationScore: number
      successfulTrades: number
      totalVolume: Prisma.Decimal
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `address`
     * const userWithAddressOnly = await prisma.user.findMany({ select: { address: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `address`
     * const userWithAddressOnly = await prisma.user.createManyAndReturn({ 
     *   select: { address: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany"> | Null>
    notificationPreference<T extends User$notificationPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferenceArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referralCodes<T extends User$referralCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$referralCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findMany"> | Null>
    referralsMade<T extends User$referralsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    referralsReceived<T extends User$referralsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    referralWallet<T extends User$referralWalletArgs<ExtArgs> = {}>(args?: Subset<T, User$referralWalletArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prime<T extends User$primeArgs<ExtArgs> = {}>(args?: Subset<T, User$primeArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    reviewsGiven<T extends User$reviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "findMany"> | Null>
    reviewsReceived<T extends User$reviewsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "findMany"> | Null>
    offers<T extends User$offersArgs<ExtArgs> = {}>(args?: Subset<T, User$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly address: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly paymentMethods: FieldRef<"User", 'String[]'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly reputationScore: FieldRef<"User", 'Int'>
    readonly successfulTrades: FieldRef<"User", 'Int'>
    readonly totalVolume: FieldRef<"User", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * User.notificationPreference
   */
  export type User$notificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.referralCodes
   */
  export type User$referralCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    where?: ReferralCodeWhereInput
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    cursor?: ReferralCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralCodeScalarFieldEnum | ReferralCodeScalarFieldEnum[]
  }

  /**
   * User.referralsMade
   */
  export type User$referralsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referralsReceived
   */
  export type User$referralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referralWallet
   */
  export type User$referralWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    where?: ReferralWalletWhereInput
  }

  /**
   * User.prime
   */
  export type User$primeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    where?: PrimeStatusWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.reviewsGiven
   */
  export type User$reviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    where?: TradeReviewWhereInput
    orderBy?: TradeReviewOrderByWithRelationInput | TradeReviewOrderByWithRelationInput[]
    cursor?: TradeReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeReviewScalarFieldEnum | TradeReviewScalarFieldEnum[]
  }

  /**
   * User.reviewsReceived
   */
  export type User$reviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    where?: TradeReviewWhereInput
    orderBy?: TradeReviewOrderByWithRelationInput | TradeReviewOrderByWithRelationInput[]
    cursor?: TradeReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeReviewScalarFieldEnum | TradeReviewScalarFieldEnum[]
  }

  /**
   * User.offers
   */
  export type User$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model TradeReview
   */

  export type AggregateTradeReview = {
    _count: TradeReviewCountAggregateOutputType | null
    _avg: TradeReviewAvgAggregateOutputType | null
    _sum: TradeReviewSumAggregateOutputType | null
    _min: TradeReviewMinAggregateOutputType | null
    _max: TradeReviewMaxAggregateOutputType | null
  }

  export type TradeReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type TradeReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type TradeReviewMinAggregateOutputType = {
    id: string | null
    tradeId: Buffer | null
    reviewerAddress: string | null
    reviewedAddress: string | null
    rating: number | null
    reviewText: string | null
    tradeRole: string | null
    createdAt: Date | null
  }

  export type TradeReviewMaxAggregateOutputType = {
    id: string | null
    tradeId: Buffer | null
    reviewerAddress: string | null
    reviewedAddress: string | null
    rating: number | null
    reviewText: string | null
    tradeRole: string | null
    createdAt: Date | null
  }

  export type TradeReviewCountAggregateOutputType = {
    id: number
    tradeId: number
    reviewerAddress: number
    reviewedAddress: number
    rating: number
    reviewText: number
    reviewTags: number
    tradeRole: number
    createdAt: number
    _all: number
  }


  export type TradeReviewAvgAggregateInputType = {
    rating?: true
  }

  export type TradeReviewSumAggregateInputType = {
    rating?: true
  }

  export type TradeReviewMinAggregateInputType = {
    id?: true
    tradeId?: true
    reviewerAddress?: true
    reviewedAddress?: true
    rating?: true
    reviewText?: true
    tradeRole?: true
    createdAt?: true
  }

  export type TradeReviewMaxAggregateInputType = {
    id?: true
    tradeId?: true
    reviewerAddress?: true
    reviewedAddress?: true
    rating?: true
    reviewText?: true
    tradeRole?: true
    createdAt?: true
  }

  export type TradeReviewCountAggregateInputType = {
    id?: true
    tradeId?: true
    reviewerAddress?: true
    reviewedAddress?: true
    rating?: true
    reviewText?: true
    reviewTags?: true
    tradeRole?: true
    createdAt?: true
    _all?: true
  }

  export type TradeReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeReview to aggregate.
     */
    where?: TradeReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeReviews to fetch.
     */
    orderBy?: TradeReviewOrderByWithRelationInput | TradeReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeReviews
    **/
    _count?: true | TradeReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeReviewMaxAggregateInputType
  }

  export type GetTradeReviewAggregateType<T extends TradeReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeReview[P]>
      : GetScalarType<T[P], AggregateTradeReview[P]>
  }




  export type TradeReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeReviewWhereInput
    orderBy?: TradeReviewOrderByWithAggregationInput | TradeReviewOrderByWithAggregationInput[]
    by: TradeReviewScalarFieldEnum[] | TradeReviewScalarFieldEnum
    having?: TradeReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeReviewCountAggregateInputType | true
    _avg?: TradeReviewAvgAggregateInputType
    _sum?: TradeReviewSumAggregateInputType
    _min?: TradeReviewMinAggregateInputType
    _max?: TradeReviewMaxAggregateInputType
  }

  export type TradeReviewGroupByOutputType = {
    id: string
    tradeId: Buffer
    reviewerAddress: string
    reviewedAddress: string
    rating: number
    reviewText: string | null
    reviewTags: string[]
    tradeRole: string
    createdAt: Date
    _count: TradeReviewCountAggregateOutputType | null
    _avg: TradeReviewAvgAggregateOutputType | null
    _sum: TradeReviewSumAggregateOutputType | null
    _min: TradeReviewMinAggregateOutputType | null
    _max: TradeReviewMaxAggregateOutputType | null
  }

  type GetTradeReviewGroupByPayload<T extends TradeReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeReviewGroupByOutputType[P]>
            : GetScalarType<T[P], TradeReviewGroupByOutputType[P]>
        }
      >
    >


  export type TradeReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeId?: boolean
    reviewerAddress?: boolean
    reviewedAddress?: boolean
    rating?: boolean
    reviewText?: boolean
    reviewTags?: boolean
    tradeRole?: boolean
    createdAt?: boolean
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewed?: boolean | UserDefaultArgs<ExtArgs>
    escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeReview"]>

  export type TradeReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeId?: boolean
    reviewerAddress?: boolean
    reviewedAddress?: boolean
    rating?: boolean
    reviewText?: boolean
    reviewTags?: boolean
    tradeRole?: boolean
    createdAt?: boolean
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewed?: boolean | UserDefaultArgs<ExtArgs>
    escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeReview"]>

  export type TradeReviewSelectScalar = {
    id?: boolean
    tradeId?: boolean
    reviewerAddress?: boolean
    reviewedAddress?: boolean
    rating?: boolean
    reviewText?: boolean
    reviewTags?: boolean
    tradeRole?: boolean
    createdAt?: boolean
  }

  export type TradeReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewed?: boolean | UserDefaultArgs<ExtArgs>
    escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }
  export type TradeReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewed?: boolean | UserDefaultArgs<ExtArgs>
    escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }

  export type $TradeReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeReview"
    objects: {
      reviewer: Prisma.$UserPayload<ExtArgs>
      reviewed: Prisma.$UserPayload<ExtArgs>
      escrow: Prisma.$EscrowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tradeId: Buffer
      reviewerAddress: string
      reviewedAddress: string
      rating: number
      reviewText: string | null
      reviewTags: string[]
      tradeRole: string
      createdAt: Date
    }, ExtArgs["result"]["tradeReview"]>
    composites: {}
  }

  type TradeReviewGetPayload<S extends boolean | null | undefined | TradeReviewDefaultArgs> = $Result.GetResult<Prisma.$TradeReviewPayload, S>

  type TradeReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TradeReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TradeReviewCountAggregateInputType | true
    }

  export interface TradeReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeReview'], meta: { name: 'TradeReview' } }
    /**
     * Find zero or one TradeReview that matches the filter.
     * @param {TradeReviewFindUniqueArgs} args - Arguments to find a TradeReview
     * @example
     * // Get one TradeReview
     * const tradeReview = await prisma.tradeReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeReviewFindUniqueArgs>(args: SelectSubset<T, TradeReviewFindUniqueArgs<ExtArgs>>): Prisma__TradeReviewClient<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TradeReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TradeReviewFindUniqueOrThrowArgs} args - Arguments to find a TradeReview
     * @example
     * // Get one TradeReview
     * const tradeReview = await prisma.tradeReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeReviewClient<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TradeReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeReviewFindFirstArgs} args - Arguments to find a TradeReview
     * @example
     * // Get one TradeReview
     * const tradeReview = await prisma.tradeReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeReviewFindFirstArgs>(args?: SelectSubset<T, TradeReviewFindFirstArgs<ExtArgs>>): Prisma__TradeReviewClient<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TradeReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeReviewFindFirstOrThrowArgs} args - Arguments to find a TradeReview
     * @example
     * // Get one TradeReview
     * const tradeReview = await prisma.tradeReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeReviewClient<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TradeReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeReviews
     * const tradeReviews = await prisma.tradeReview.findMany()
     * 
     * // Get first 10 TradeReviews
     * const tradeReviews = await prisma.tradeReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeReviewWithIdOnly = await prisma.tradeReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeReviewFindManyArgs>(args?: SelectSubset<T, TradeReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TradeReview.
     * @param {TradeReviewCreateArgs} args - Arguments to create a TradeReview.
     * @example
     * // Create one TradeReview
     * const TradeReview = await prisma.tradeReview.create({
     *   data: {
     *     // ... data to create a TradeReview
     *   }
     * })
     * 
     */
    create<T extends TradeReviewCreateArgs>(args: SelectSubset<T, TradeReviewCreateArgs<ExtArgs>>): Prisma__TradeReviewClient<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TradeReviews.
     * @param {TradeReviewCreateManyArgs} args - Arguments to create many TradeReviews.
     * @example
     * // Create many TradeReviews
     * const tradeReview = await prisma.tradeReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeReviewCreateManyArgs>(args?: SelectSubset<T, TradeReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeReviews and returns the data saved in the database.
     * @param {TradeReviewCreateManyAndReturnArgs} args - Arguments to create many TradeReviews.
     * @example
     * // Create many TradeReviews
     * const tradeReview = await prisma.tradeReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeReviews and only return the `id`
     * const tradeReviewWithIdOnly = await prisma.tradeReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TradeReview.
     * @param {TradeReviewDeleteArgs} args - Arguments to delete one TradeReview.
     * @example
     * // Delete one TradeReview
     * const TradeReview = await prisma.tradeReview.delete({
     *   where: {
     *     // ... filter to delete one TradeReview
     *   }
     * })
     * 
     */
    delete<T extends TradeReviewDeleteArgs>(args: SelectSubset<T, TradeReviewDeleteArgs<ExtArgs>>): Prisma__TradeReviewClient<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TradeReview.
     * @param {TradeReviewUpdateArgs} args - Arguments to update one TradeReview.
     * @example
     * // Update one TradeReview
     * const tradeReview = await prisma.tradeReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeReviewUpdateArgs>(args: SelectSubset<T, TradeReviewUpdateArgs<ExtArgs>>): Prisma__TradeReviewClient<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TradeReviews.
     * @param {TradeReviewDeleteManyArgs} args - Arguments to filter TradeReviews to delete.
     * @example
     * // Delete a few TradeReviews
     * const { count } = await prisma.tradeReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeReviewDeleteManyArgs>(args?: SelectSubset<T, TradeReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeReviews
     * const tradeReview = await prisma.tradeReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeReviewUpdateManyArgs>(args: SelectSubset<T, TradeReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TradeReview.
     * @param {TradeReviewUpsertArgs} args - Arguments to update or create a TradeReview.
     * @example
     * // Update or create a TradeReview
     * const tradeReview = await prisma.tradeReview.upsert({
     *   create: {
     *     // ... data to create a TradeReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeReview we want to update
     *   }
     * })
     */
    upsert<T extends TradeReviewUpsertArgs>(args: SelectSubset<T, TradeReviewUpsertArgs<ExtArgs>>): Prisma__TradeReviewClient<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TradeReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeReviewCountArgs} args - Arguments to filter TradeReviews to count.
     * @example
     * // Count the number of TradeReviews
     * const count = await prisma.tradeReview.count({
     *   where: {
     *     // ... the filter for the TradeReviews we want to count
     *   }
     * })
    **/
    count<T extends TradeReviewCountArgs>(
      args?: Subset<T, TradeReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeReviewAggregateArgs>(args: Subset<T, TradeReviewAggregateArgs>): Prisma.PrismaPromise<GetTradeReviewAggregateType<T>>

    /**
     * Group by TradeReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeReviewGroupByArgs['orderBy'] }
        : { orderBy?: TradeReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeReview model
   */
  readonly fields: TradeReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviewed<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    escrow<T extends EscrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscrowDefaultArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeReview model
   */ 
  interface TradeReviewFieldRefs {
    readonly id: FieldRef<"TradeReview", 'String'>
    readonly tradeId: FieldRef<"TradeReview", 'Bytes'>
    readonly reviewerAddress: FieldRef<"TradeReview", 'String'>
    readonly reviewedAddress: FieldRef<"TradeReview", 'String'>
    readonly rating: FieldRef<"TradeReview", 'Int'>
    readonly reviewText: FieldRef<"TradeReview", 'String'>
    readonly reviewTags: FieldRef<"TradeReview", 'String[]'>
    readonly tradeRole: FieldRef<"TradeReview", 'String'>
    readonly createdAt: FieldRef<"TradeReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TradeReview findUnique
   */
  export type TradeReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * Filter, which TradeReview to fetch.
     */
    where: TradeReviewWhereUniqueInput
  }

  /**
   * TradeReview findUniqueOrThrow
   */
  export type TradeReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * Filter, which TradeReview to fetch.
     */
    where: TradeReviewWhereUniqueInput
  }

  /**
   * TradeReview findFirst
   */
  export type TradeReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * Filter, which TradeReview to fetch.
     */
    where?: TradeReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeReviews to fetch.
     */
    orderBy?: TradeReviewOrderByWithRelationInput | TradeReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeReviews.
     */
    cursor?: TradeReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeReviews.
     */
    distinct?: TradeReviewScalarFieldEnum | TradeReviewScalarFieldEnum[]
  }

  /**
   * TradeReview findFirstOrThrow
   */
  export type TradeReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * Filter, which TradeReview to fetch.
     */
    where?: TradeReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeReviews to fetch.
     */
    orderBy?: TradeReviewOrderByWithRelationInput | TradeReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeReviews.
     */
    cursor?: TradeReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeReviews.
     */
    distinct?: TradeReviewScalarFieldEnum | TradeReviewScalarFieldEnum[]
  }

  /**
   * TradeReview findMany
   */
  export type TradeReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * Filter, which TradeReviews to fetch.
     */
    where?: TradeReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeReviews to fetch.
     */
    orderBy?: TradeReviewOrderByWithRelationInput | TradeReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeReviews.
     */
    cursor?: TradeReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeReviews.
     */
    skip?: number
    distinct?: TradeReviewScalarFieldEnum | TradeReviewScalarFieldEnum[]
  }

  /**
   * TradeReview create
   */
  export type TradeReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a TradeReview.
     */
    data: XOR<TradeReviewCreateInput, TradeReviewUncheckedCreateInput>
  }

  /**
   * TradeReview createMany
   */
  export type TradeReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeReviews.
     */
    data: TradeReviewCreateManyInput | TradeReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeReview createManyAndReturn
   */
  export type TradeReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TradeReviews.
     */
    data: TradeReviewCreateManyInput | TradeReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeReview update
   */
  export type TradeReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a TradeReview.
     */
    data: XOR<TradeReviewUpdateInput, TradeReviewUncheckedUpdateInput>
    /**
     * Choose, which TradeReview to update.
     */
    where: TradeReviewWhereUniqueInput
  }

  /**
   * TradeReview updateMany
   */
  export type TradeReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeReviews.
     */
    data: XOR<TradeReviewUpdateManyMutationInput, TradeReviewUncheckedUpdateManyInput>
    /**
     * Filter which TradeReviews to update
     */
    where?: TradeReviewWhereInput
  }

  /**
   * TradeReview upsert
   */
  export type TradeReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the TradeReview to update in case it exists.
     */
    where: TradeReviewWhereUniqueInput
    /**
     * In case the TradeReview found by the `where` argument doesn't exist, create a new TradeReview with this data.
     */
    create: XOR<TradeReviewCreateInput, TradeReviewUncheckedCreateInput>
    /**
     * In case the TradeReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeReviewUpdateInput, TradeReviewUncheckedUpdateInput>
  }

  /**
   * TradeReview delete
   */
  export type TradeReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    /**
     * Filter which TradeReview to delete.
     */
    where: TradeReviewWhereUniqueInput
  }

  /**
   * TradeReview deleteMany
   */
  export type TradeReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeReviews to delete
     */
    where?: TradeReviewWhereInput
  }

  /**
   * TradeReview without action
   */
  export type TradeReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    address: string | null
    role: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    address: string | null
    role: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    address: number
    role: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    address?: true
    role?: true
    createdBy?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    address?: true
    role?: true
    createdBy?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    address?: true
    role?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    address: string
    role: string
    createdBy: string | null
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    role?: boolean
    createdBy?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    role?: boolean
    createdBy?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    address?: boolean
    role?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      role: string
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly address: FieldRef<"Role", 'String'>
    readonly role: FieldRef<"Role", 'String'>
    readonly createdBy: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Escrow
   */

  export type AggregateEscrow = {
    _count: EscrowCountAggregateOutputType | null
    _avg: EscrowAvgAggregateOutputType | null
    _sum: EscrowSumAggregateOutputType | null
    _min: EscrowMinAggregateOutputType | null
    _max: EscrowMaxAggregateOutputType | null
  }

  export type EscrowAvgAggregateOutputType = {
    chainId: number | null
    amount: Decimal | null
    feeAmount: Decimal | null
    sellerBond: Decimal | null
    buyerBond: Decimal | null
    createdAtBlock: number | null
    updatedAtBlock: number | null
  }

  export type EscrowSumAggregateOutputType = {
    chainId: number | null
    amount: Decimal | null
    feeAmount: Decimal | null
    sellerBond: Decimal | null
    buyerBond: Decimal | null
    createdAtBlock: bigint | null
    updatedAtBlock: bigint | null
  }

  export type EscrowMinAggregateOutputType = {
    escrowId: Buffer | null
    chainId: number | null
    contractAddress: string | null
    tokenKey: string | null
    amount: Decimal | null
    feeAmount: Decimal | null
    sellerBond: Decimal | null
    buyerBond: Decimal | null
    state: string | null
    seller: string | null
    buyer: string | null
    createdAtBlock: bigint | null
    updatedAtBlock: bigint | null
    txHashCreate: string | null
    txHashLast: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EscrowMaxAggregateOutputType = {
    escrowId: Buffer | null
    chainId: number | null
    contractAddress: string | null
    tokenKey: string | null
    amount: Decimal | null
    feeAmount: Decimal | null
    sellerBond: Decimal | null
    buyerBond: Decimal | null
    state: string | null
    seller: string | null
    buyer: string | null
    createdAtBlock: bigint | null
    updatedAtBlock: bigint | null
    txHashCreate: string | null
    txHashLast: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EscrowCountAggregateOutputType = {
    escrowId: number
    chainId: number
    contractAddress: number
    tokenKey: number
    amount: number
    feeAmount: number
    sellerBond: number
    buyerBond: number
    state: number
    seller: number
    buyer: number
    createdAtBlock: number
    updatedAtBlock: number
    txHashCreate: number
    txHashLast: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EscrowAvgAggregateInputType = {
    chainId?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    createdAtBlock?: true
    updatedAtBlock?: true
  }

  export type EscrowSumAggregateInputType = {
    chainId?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    createdAtBlock?: true
    updatedAtBlock?: true
  }

  export type EscrowMinAggregateInputType = {
    escrowId?: true
    chainId?: true
    contractAddress?: true
    tokenKey?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    state?: true
    seller?: true
    buyer?: true
    createdAtBlock?: true
    updatedAtBlock?: true
    txHashCreate?: true
    txHashLast?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EscrowMaxAggregateInputType = {
    escrowId?: true
    chainId?: true
    contractAddress?: true
    tokenKey?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    state?: true
    seller?: true
    buyer?: true
    createdAtBlock?: true
    updatedAtBlock?: true
    txHashCreate?: true
    txHashLast?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EscrowCountAggregateInputType = {
    escrowId?: true
    chainId?: true
    contractAddress?: true
    tokenKey?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    state?: true
    seller?: true
    buyer?: true
    createdAtBlock?: true
    updatedAtBlock?: true
    txHashCreate?: true
    txHashLast?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EscrowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escrow to aggregate.
     */
    where?: EscrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escrows to fetch.
     */
    orderBy?: EscrowOrderByWithRelationInput | EscrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Escrows
    **/
    _count?: true | EscrowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscrowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscrowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowMaxAggregateInputType
  }

  export type GetEscrowAggregateType<T extends EscrowAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrow[P]>
      : GetScalarType<T[P], AggregateEscrow[P]>
  }




  export type EscrowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowWhereInput
    orderBy?: EscrowOrderByWithAggregationInput | EscrowOrderByWithAggregationInput[]
    by: EscrowScalarFieldEnum[] | EscrowScalarFieldEnum
    having?: EscrowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowCountAggregateInputType | true
    _avg?: EscrowAvgAggregateInputType
    _sum?: EscrowSumAggregateInputType
    _min?: EscrowMinAggregateInputType
    _max?: EscrowMaxAggregateInputType
  }

  export type EscrowGroupByOutputType = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal
    feeAmount: Decimal
    sellerBond: Decimal
    buyerBond: Decimal
    state: string
    seller: string
    buyer: string | null
    createdAtBlock: bigint
    updatedAtBlock: bigint
    txHashCreate: string | null
    txHashLast: string | null
    createdAt: Date
    updatedAt: Date
    _count: EscrowCountAggregateOutputType | null
    _avg: EscrowAvgAggregateOutputType | null
    _sum: EscrowSumAggregateOutputType | null
    _min: EscrowMinAggregateOutputType | null
    _max: EscrowMaxAggregateOutputType | null
  }

  type GetEscrowGroupByPayload<T extends EscrowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowGroupByOutputType[P]>
        }
      >
    >


  export type EscrowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    chainId?: boolean
    contractAddress?: boolean
    tokenKey?: boolean
    amount?: boolean
    feeAmount?: boolean
    sellerBond?: boolean
    buyerBond?: boolean
    state?: boolean
    seller?: boolean
    buyer?: boolean
    createdAtBlock?: boolean
    updatedAtBlock?: boolean
    txHashCreate?: boolean
    txHashLast?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeline?: boolean | Escrow$timelineArgs<ExtArgs>
    messages?: boolean | Escrow$messagesArgs<ExtArgs>
    paymentInstruction?: boolean | Escrow$paymentInstructionArgs<ExtArgs>
    fiatStatuses?: boolean | Escrow$fiatStatusesArgs<ExtArgs>
    evidence?: boolean | Escrow$evidenceArgs<ExtArgs>
    dispute?: boolean | Escrow$disputeArgs<ExtArgs>
    reviews?: boolean | Escrow$reviewsArgs<ExtArgs>
    _count?: boolean | EscrowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrow"]>

  export type EscrowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    chainId?: boolean
    contractAddress?: boolean
    tokenKey?: boolean
    amount?: boolean
    feeAmount?: boolean
    sellerBond?: boolean
    buyerBond?: boolean
    state?: boolean
    seller?: boolean
    buyer?: boolean
    createdAtBlock?: boolean
    updatedAtBlock?: boolean
    txHashCreate?: boolean
    txHashLast?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["escrow"]>

  export type EscrowSelectScalar = {
    escrowId?: boolean
    chainId?: boolean
    contractAddress?: boolean
    tokenKey?: boolean
    amount?: boolean
    feeAmount?: boolean
    sellerBond?: boolean
    buyerBond?: boolean
    state?: boolean
    seller?: boolean
    buyer?: boolean
    createdAtBlock?: boolean
    updatedAtBlock?: boolean
    txHashCreate?: boolean
    txHashLast?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EscrowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeline?: boolean | Escrow$timelineArgs<ExtArgs>
    messages?: boolean | Escrow$messagesArgs<ExtArgs>
    paymentInstruction?: boolean | Escrow$paymentInstructionArgs<ExtArgs>
    fiatStatuses?: boolean | Escrow$fiatStatusesArgs<ExtArgs>
    evidence?: boolean | Escrow$evidenceArgs<ExtArgs>
    dispute?: boolean | Escrow$disputeArgs<ExtArgs>
    reviews?: boolean | Escrow$reviewsArgs<ExtArgs>
    _count?: boolean | EscrowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EscrowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EscrowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Escrow"
    objects: {
      timeline: Prisma.$EscrowTimelinePayload<ExtArgs>[]
      messages: Prisma.$EscrowMessagePayload<ExtArgs>[]
      paymentInstruction: Prisma.$EscrowPaymentInstructionPayload<ExtArgs> | null
      fiatStatuses: Prisma.$EscrowFiatStatusPayload<ExtArgs>[]
      evidence: Prisma.$EvidenceItemPayload<ExtArgs>[]
      dispute: Prisma.$DisputePayload<ExtArgs> | null
      reviews: Prisma.$TradeReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      escrowId: Buffer
      chainId: number
      contractAddress: string
      tokenKey: string
      amount: Prisma.Decimal
      feeAmount: Prisma.Decimal
      sellerBond: Prisma.Decimal
      buyerBond: Prisma.Decimal
      state: string
      seller: string
      buyer: string | null
      createdAtBlock: bigint
      updatedAtBlock: bigint
      txHashCreate: string | null
      txHashLast: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["escrow"]>
    composites: {}
  }

  type EscrowGetPayload<S extends boolean | null | undefined | EscrowDefaultArgs> = $Result.GetResult<Prisma.$EscrowPayload, S>

  type EscrowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowCountAggregateInputType | true
    }

  export interface EscrowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Escrow'], meta: { name: 'Escrow' } }
    /**
     * Find zero or one Escrow that matches the filter.
     * @param {EscrowFindUniqueArgs} args - Arguments to find a Escrow
     * @example
     * // Get one Escrow
     * const escrow = await prisma.escrow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowFindUniqueArgs>(args: SelectSubset<T, EscrowFindUniqueArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Escrow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowFindUniqueOrThrowArgs} args - Arguments to find a Escrow
     * @example
     * // Get one Escrow
     * const escrow = await prisma.escrow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Escrow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFindFirstArgs} args - Arguments to find a Escrow
     * @example
     * // Get one Escrow
     * const escrow = await prisma.escrow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowFindFirstArgs>(args?: SelectSubset<T, EscrowFindFirstArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Escrow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFindFirstOrThrowArgs} args - Arguments to find a Escrow
     * @example
     * // Get one Escrow
     * const escrow = await prisma.escrow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Escrows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escrows
     * const escrows = await prisma.escrow.findMany()
     * 
     * // Get first 10 Escrows
     * const escrows = await prisma.escrow.findMany({ take: 10 })
     * 
     * // Only select the `escrowId`
     * const escrowWithEscrowIdOnly = await prisma.escrow.findMany({ select: { escrowId: true } })
     * 
     */
    findMany<T extends EscrowFindManyArgs>(args?: SelectSubset<T, EscrowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Escrow.
     * @param {EscrowCreateArgs} args - Arguments to create a Escrow.
     * @example
     * // Create one Escrow
     * const Escrow = await prisma.escrow.create({
     *   data: {
     *     // ... data to create a Escrow
     *   }
     * })
     * 
     */
    create<T extends EscrowCreateArgs>(args: SelectSubset<T, EscrowCreateArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Escrows.
     * @param {EscrowCreateManyArgs} args - Arguments to create many Escrows.
     * @example
     * // Create many Escrows
     * const escrow = await prisma.escrow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowCreateManyArgs>(args?: SelectSubset<T, EscrowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escrows and returns the data saved in the database.
     * @param {EscrowCreateManyAndReturnArgs} args - Arguments to create many Escrows.
     * @example
     * // Create many Escrows
     * const escrow = await prisma.escrow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escrows and only return the `escrowId`
     * const escrowWithEscrowIdOnly = await prisma.escrow.createManyAndReturn({ 
     *   select: { escrowId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Escrow.
     * @param {EscrowDeleteArgs} args - Arguments to delete one Escrow.
     * @example
     * // Delete one Escrow
     * const Escrow = await prisma.escrow.delete({
     *   where: {
     *     // ... filter to delete one Escrow
     *   }
     * })
     * 
     */
    delete<T extends EscrowDeleteArgs>(args: SelectSubset<T, EscrowDeleteArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Escrow.
     * @param {EscrowUpdateArgs} args - Arguments to update one Escrow.
     * @example
     * // Update one Escrow
     * const escrow = await prisma.escrow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowUpdateArgs>(args: SelectSubset<T, EscrowUpdateArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Escrows.
     * @param {EscrowDeleteManyArgs} args - Arguments to filter Escrows to delete.
     * @example
     * // Delete a few Escrows
     * const { count } = await prisma.escrow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowDeleteManyArgs>(args?: SelectSubset<T, EscrowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escrows
     * const escrow = await prisma.escrow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowUpdateManyArgs>(args: SelectSubset<T, EscrowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Escrow.
     * @param {EscrowUpsertArgs} args - Arguments to update or create a Escrow.
     * @example
     * // Update or create a Escrow
     * const escrow = await prisma.escrow.upsert({
     *   create: {
     *     // ... data to create a Escrow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escrow we want to update
     *   }
     * })
     */
    upsert<T extends EscrowUpsertArgs>(args: SelectSubset<T, EscrowUpsertArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Escrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowCountArgs} args - Arguments to filter Escrows to count.
     * @example
     * // Count the number of Escrows
     * const count = await prisma.escrow.count({
     *   where: {
     *     // ... the filter for the Escrows we want to count
     *   }
     * })
    **/
    count<T extends EscrowCountArgs>(
      args?: Subset<T, EscrowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowAggregateArgs>(args: Subset<T, EscrowAggregateArgs>): Prisma.PrismaPromise<GetEscrowAggregateType<T>>

    /**
     * Group by Escrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowGroupByArgs['orderBy'] }
        : { orderBy?: EscrowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Escrow model
   */
  readonly fields: EscrowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Escrow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    timeline<T extends Escrow$timelineArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$timelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Escrow$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findMany"> | Null>
    paymentInstruction<T extends Escrow$paymentInstructionArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$paymentInstructionArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    fiatStatuses<T extends Escrow$fiatStatusesArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$fiatStatusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findMany"> | Null>
    evidence<T extends Escrow$evidenceArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$evidenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findMany"> | Null>
    dispute<T extends Escrow$disputeArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$disputeArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviews<T extends Escrow$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Escrow model
   */ 
  interface EscrowFieldRefs {
    readonly escrowId: FieldRef<"Escrow", 'Bytes'>
    readonly chainId: FieldRef<"Escrow", 'Int'>
    readonly contractAddress: FieldRef<"Escrow", 'String'>
    readonly tokenKey: FieldRef<"Escrow", 'String'>
    readonly amount: FieldRef<"Escrow", 'Decimal'>
    readonly feeAmount: FieldRef<"Escrow", 'Decimal'>
    readonly sellerBond: FieldRef<"Escrow", 'Decimal'>
    readonly buyerBond: FieldRef<"Escrow", 'Decimal'>
    readonly state: FieldRef<"Escrow", 'String'>
    readonly seller: FieldRef<"Escrow", 'String'>
    readonly buyer: FieldRef<"Escrow", 'String'>
    readonly createdAtBlock: FieldRef<"Escrow", 'BigInt'>
    readonly updatedAtBlock: FieldRef<"Escrow", 'BigInt'>
    readonly txHashCreate: FieldRef<"Escrow", 'String'>
    readonly txHashLast: FieldRef<"Escrow", 'String'>
    readonly createdAt: FieldRef<"Escrow", 'DateTime'>
    readonly updatedAt: FieldRef<"Escrow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Escrow findUnique
   */
  export type EscrowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrow to fetch.
     */
    where: EscrowWhereUniqueInput
  }

  /**
   * Escrow findUniqueOrThrow
   */
  export type EscrowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrow to fetch.
     */
    where: EscrowWhereUniqueInput
  }

  /**
   * Escrow findFirst
   */
  export type EscrowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrow to fetch.
     */
    where?: EscrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escrows to fetch.
     */
    orderBy?: EscrowOrderByWithRelationInput | EscrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escrows.
     */
    cursor?: EscrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escrows.
     */
    distinct?: EscrowScalarFieldEnum | EscrowScalarFieldEnum[]
  }

  /**
   * Escrow findFirstOrThrow
   */
  export type EscrowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrow to fetch.
     */
    where?: EscrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escrows to fetch.
     */
    orderBy?: EscrowOrderByWithRelationInput | EscrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escrows.
     */
    cursor?: EscrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escrows.
     */
    distinct?: EscrowScalarFieldEnum | EscrowScalarFieldEnum[]
  }

  /**
   * Escrow findMany
   */
  export type EscrowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrows to fetch.
     */
    where?: EscrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escrows to fetch.
     */
    orderBy?: EscrowOrderByWithRelationInput | EscrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Escrows.
     */
    cursor?: EscrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escrows.
     */
    skip?: number
    distinct?: EscrowScalarFieldEnum | EscrowScalarFieldEnum[]
  }

  /**
   * Escrow create
   */
  export type EscrowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * The data needed to create a Escrow.
     */
    data: XOR<EscrowCreateInput, EscrowUncheckedCreateInput>
  }

  /**
   * Escrow createMany
   */
  export type EscrowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Escrows.
     */
    data: EscrowCreateManyInput | EscrowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Escrow createManyAndReturn
   */
  export type EscrowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Escrows.
     */
    data: EscrowCreateManyInput | EscrowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Escrow update
   */
  export type EscrowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * The data needed to update a Escrow.
     */
    data: XOR<EscrowUpdateInput, EscrowUncheckedUpdateInput>
    /**
     * Choose, which Escrow to update.
     */
    where: EscrowWhereUniqueInput
  }

  /**
   * Escrow updateMany
   */
  export type EscrowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Escrows.
     */
    data: XOR<EscrowUpdateManyMutationInput, EscrowUncheckedUpdateManyInput>
    /**
     * Filter which Escrows to update
     */
    where?: EscrowWhereInput
  }

  /**
   * Escrow upsert
   */
  export type EscrowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * The filter to search for the Escrow to update in case it exists.
     */
    where: EscrowWhereUniqueInput
    /**
     * In case the Escrow found by the `where` argument doesn't exist, create a new Escrow with this data.
     */
    create: XOR<EscrowCreateInput, EscrowUncheckedCreateInput>
    /**
     * In case the Escrow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowUpdateInput, EscrowUncheckedUpdateInput>
  }

  /**
   * Escrow delete
   */
  export type EscrowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter which Escrow to delete.
     */
    where: EscrowWhereUniqueInput
  }

  /**
   * Escrow deleteMany
   */
  export type EscrowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escrows to delete
     */
    where?: EscrowWhereInput
  }

  /**
   * Escrow.timeline
   */
  export type Escrow$timelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    where?: EscrowTimelineWhereInput
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    cursor?: EscrowTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscrowTimelineScalarFieldEnum | EscrowTimelineScalarFieldEnum[]
  }

  /**
   * Escrow.messages
   */
  export type Escrow$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    where?: EscrowMessageWhereInput
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    cursor?: EscrowMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscrowMessageScalarFieldEnum | EscrowMessageScalarFieldEnum[]
  }

  /**
   * Escrow.paymentInstruction
   */
  export type Escrow$paymentInstructionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    where?: EscrowPaymentInstructionWhereInput
  }

  /**
   * Escrow.fiatStatuses
   */
  export type Escrow$fiatStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    where?: EscrowFiatStatusWhereInput
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    cursor?: EscrowFiatStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscrowFiatStatusScalarFieldEnum | EscrowFiatStatusScalarFieldEnum[]
  }

  /**
   * Escrow.evidence
   */
  export type Escrow$evidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    where?: EvidenceItemWhereInput
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    cursor?: EvidenceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceItemScalarFieldEnum | EvidenceItemScalarFieldEnum[]
  }

  /**
   * Escrow.dispute
   */
  export type Escrow$disputeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    where?: DisputeWhereInput
  }

  /**
   * Escrow.reviews
   */
  export type Escrow$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeReview
     */
    select?: TradeReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeReviewInclude<ExtArgs> | null
    where?: TradeReviewWhereInput
    orderBy?: TradeReviewOrderByWithRelationInput | TradeReviewOrderByWithRelationInput[]
    cursor?: TradeReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeReviewScalarFieldEnum | TradeReviewScalarFieldEnum[]
  }

  /**
   * Escrow without action
   */
  export type EscrowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
  }


  /**
   * Model EscrowTimeline
   */

  export type AggregateEscrowTimeline = {
    _count: EscrowTimelineCountAggregateOutputType | null
    _avg: EscrowTimelineAvgAggregateOutputType | null
    _sum: EscrowTimelineSumAggregateOutputType | null
    _min: EscrowTimelineMinAggregateOutputType | null
    _max: EscrowTimelineMaxAggregateOutputType | null
  }

  export type EscrowTimelineAvgAggregateOutputType = {
    id: number | null
    chainId: number | null
    blockNumber: number | null
    logIndex: number | null
  }

  export type EscrowTimelineSumAggregateOutputType = {
    id: bigint | null
    chainId: number | null
    blockNumber: bigint | null
    logIndex: number | null
  }

  export type EscrowTimelineMinAggregateOutputType = {
    id: bigint | null
    escrowId: Buffer | null
    chainId: number | null
    eventName: string | null
    stateAfter: string | null
    txHash: string | null
    blockNumber: bigint | null
    logIndex: number | null
    timestamp: Date | null
  }

  export type EscrowTimelineMaxAggregateOutputType = {
    id: bigint | null
    escrowId: Buffer | null
    chainId: number | null
    eventName: string | null
    stateAfter: string | null
    txHash: string | null
    blockNumber: bigint | null
    logIndex: number | null
    timestamp: Date | null
  }

  export type EscrowTimelineCountAggregateOutputType = {
    id: number
    escrowId: number
    chainId: number
    eventName: number
    stateAfter: number
    txHash: number
    blockNumber: number
    logIndex: number
    timestamp: number
    payload: number
    _all: number
  }


  export type EscrowTimelineAvgAggregateInputType = {
    id?: true
    chainId?: true
    blockNumber?: true
    logIndex?: true
  }

  export type EscrowTimelineSumAggregateInputType = {
    id?: true
    chainId?: true
    blockNumber?: true
    logIndex?: true
  }

  export type EscrowTimelineMinAggregateInputType = {
    id?: true
    escrowId?: true
    chainId?: true
    eventName?: true
    stateAfter?: true
    txHash?: true
    blockNumber?: true
    logIndex?: true
    timestamp?: true
  }

  export type EscrowTimelineMaxAggregateInputType = {
    id?: true
    escrowId?: true
    chainId?: true
    eventName?: true
    stateAfter?: true
    txHash?: true
    blockNumber?: true
    logIndex?: true
    timestamp?: true
  }

  export type EscrowTimelineCountAggregateInputType = {
    id?: true
    escrowId?: true
    chainId?: true
    eventName?: true
    stateAfter?: true
    txHash?: true
    blockNumber?: true
    logIndex?: true
    timestamp?: true
    payload?: true
    _all?: true
  }

  export type EscrowTimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowTimeline to aggregate.
     */
    where?: EscrowTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowTimelines to fetch.
     */
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowTimelines
    **/
    _count?: true | EscrowTimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscrowTimelineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscrowTimelineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowTimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowTimelineMaxAggregateInputType
  }

  export type GetEscrowTimelineAggregateType<T extends EscrowTimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowTimeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowTimeline[P]>
      : GetScalarType<T[P], AggregateEscrowTimeline[P]>
  }




  export type EscrowTimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowTimelineWhereInput
    orderBy?: EscrowTimelineOrderByWithAggregationInput | EscrowTimelineOrderByWithAggregationInput[]
    by: EscrowTimelineScalarFieldEnum[] | EscrowTimelineScalarFieldEnum
    having?: EscrowTimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowTimelineCountAggregateInputType | true
    _avg?: EscrowTimelineAvgAggregateInputType
    _sum?: EscrowTimelineSumAggregateInputType
    _min?: EscrowTimelineMinAggregateInputType
    _max?: EscrowTimelineMaxAggregateInputType
  }

  export type EscrowTimelineGroupByOutputType = {
    id: bigint
    escrowId: Buffer
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint
    logIndex: number
    timestamp: Date
    payload: JsonValue
    _count: EscrowTimelineCountAggregateOutputType | null
    _avg: EscrowTimelineAvgAggregateOutputType | null
    _sum: EscrowTimelineSumAggregateOutputType | null
    _min: EscrowTimelineMinAggregateOutputType | null
    _max: EscrowTimelineMaxAggregateOutputType | null
  }

  type GetEscrowTimelineGroupByPayload<T extends EscrowTimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowTimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowTimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowTimelineGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowTimelineGroupByOutputType[P]>
        }
      >
    >


  export type EscrowTimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    chainId?: boolean
    eventName?: boolean
    stateAfter?: boolean
    txHash?: boolean
    blockNumber?: boolean
    logIndex?: boolean
    timestamp?: boolean
    payload?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrowTimeline"]>

  export type EscrowTimelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    chainId?: boolean
    eventName?: boolean
    stateAfter?: boolean
    txHash?: boolean
    blockNumber?: boolean
    logIndex?: boolean
    timestamp?: boolean
    payload?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrowTimeline"]>

  export type EscrowTimelineSelectScalar = {
    id?: boolean
    escrowId?: boolean
    chainId?: boolean
    eventName?: boolean
    stateAfter?: boolean
    txHash?: boolean
    blockNumber?: boolean
    logIndex?: boolean
    timestamp?: boolean
    payload?: boolean
  }

  export type EscrowTimelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }
  export type EscrowTimelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }

  export type $EscrowTimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowTimeline"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      escrowId: Buffer
      chainId: number
      eventName: string
      stateAfter: string
      txHash: string
      blockNumber: bigint
      logIndex: number
      timestamp: Date
      payload: Prisma.JsonValue
    }, ExtArgs["result"]["escrowTimeline"]>
    composites: {}
  }

  type EscrowTimelineGetPayload<S extends boolean | null | undefined | EscrowTimelineDefaultArgs> = $Result.GetResult<Prisma.$EscrowTimelinePayload, S>

  type EscrowTimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowTimelineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowTimelineCountAggregateInputType | true
    }

  export interface EscrowTimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowTimeline'], meta: { name: 'EscrowTimeline' } }
    /**
     * Find zero or one EscrowTimeline that matches the filter.
     * @param {EscrowTimelineFindUniqueArgs} args - Arguments to find a EscrowTimeline
     * @example
     * // Get one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowTimelineFindUniqueArgs>(args: SelectSubset<T, EscrowTimelineFindUniqueArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscrowTimeline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowTimelineFindUniqueOrThrowArgs} args - Arguments to find a EscrowTimeline
     * @example
     * // Get one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowTimelineFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowTimelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscrowTimeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineFindFirstArgs} args - Arguments to find a EscrowTimeline
     * @example
     * // Get one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowTimelineFindFirstArgs>(args?: SelectSubset<T, EscrowTimelineFindFirstArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscrowTimeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineFindFirstOrThrowArgs} args - Arguments to find a EscrowTimeline
     * @example
     * // Get one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowTimelineFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowTimelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscrowTimelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowTimelines
     * const escrowTimelines = await prisma.escrowTimeline.findMany()
     * 
     * // Get first 10 EscrowTimelines
     * const escrowTimelines = await prisma.escrowTimeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrowTimelineWithIdOnly = await prisma.escrowTimeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscrowTimelineFindManyArgs>(args?: SelectSubset<T, EscrowTimelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscrowTimeline.
     * @param {EscrowTimelineCreateArgs} args - Arguments to create a EscrowTimeline.
     * @example
     * // Create one EscrowTimeline
     * const EscrowTimeline = await prisma.escrowTimeline.create({
     *   data: {
     *     // ... data to create a EscrowTimeline
     *   }
     * })
     * 
     */
    create<T extends EscrowTimelineCreateArgs>(args: SelectSubset<T, EscrowTimelineCreateArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscrowTimelines.
     * @param {EscrowTimelineCreateManyArgs} args - Arguments to create many EscrowTimelines.
     * @example
     * // Create many EscrowTimelines
     * const escrowTimeline = await prisma.escrowTimeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowTimelineCreateManyArgs>(args?: SelectSubset<T, EscrowTimelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscrowTimelines and returns the data saved in the database.
     * @param {EscrowTimelineCreateManyAndReturnArgs} args - Arguments to create many EscrowTimelines.
     * @example
     * // Create many EscrowTimelines
     * const escrowTimeline = await prisma.escrowTimeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscrowTimelines and only return the `id`
     * const escrowTimelineWithIdOnly = await prisma.escrowTimeline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowTimelineCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowTimelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscrowTimeline.
     * @param {EscrowTimelineDeleteArgs} args - Arguments to delete one EscrowTimeline.
     * @example
     * // Delete one EscrowTimeline
     * const EscrowTimeline = await prisma.escrowTimeline.delete({
     *   where: {
     *     // ... filter to delete one EscrowTimeline
     *   }
     * })
     * 
     */
    delete<T extends EscrowTimelineDeleteArgs>(args: SelectSubset<T, EscrowTimelineDeleteArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscrowTimeline.
     * @param {EscrowTimelineUpdateArgs} args - Arguments to update one EscrowTimeline.
     * @example
     * // Update one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowTimelineUpdateArgs>(args: SelectSubset<T, EscrowTimelineUpdateArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscrowTimelines.
     * @param {EscrowTimelineDeleteManyArgs} args - Arguments to filter EscrowTimelines to delete.
     * @example
     * // Delete a few EscrowTimelines
     * const { count } = await prisma.escrowTimeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowTimelineDeleteManyArgs>(args?: SelectSubset<T, EscrowTimelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowTimelines
     * const escrowTimeline = await prisma.escrowTimeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowTimelineUpdateManyArgs>(args: SelectSubset<T, EscrowTimelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowTimeline.
     * @param {EscrowTimelineUpsertArgs} args - Arguments to update or create a EscrowTimeline.
     * @example
     * // Update or create a EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.upsert({
     *   create: {
     *     // ... data to create a EscrowTimeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowTimeline we want to update
     *   }
     * })
     */
    upsert<T extends EscrowTimelineUpsertArgs>(args: SelectSubset<T, EscrowTimelineUpsertArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscrowTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineCountArgs} args - Arguments to filter EscrowTimelines to count.
     * @example
     * // Count the number of EscrowTimelines
     * const count = await prisma.escrowTimeline.count({
     *   where: {
     *     // ... the filter for the EscrowTimelines we want to count
     *   }
     * })
    **/
    count<T extends EscrowTimelineCountArgs>(
      args?: Subset<T, EscrowTimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowTimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowTimelineAggregateArgs>(args: Subset<T, EscrowTimelineAggregateArgs>): Prisma.PrismaPromise<GetEscrowTimelineAggregateType<T>>

    /**
     * Group by EscrowTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowTimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowTimelineGroupByArgs['orderBy'] }
        : { orderBy?: EscrowTimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowTimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowTimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowTimeline model
   */
  readonly fields: EscrowTimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowTimeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowTimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscrowDefaultArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscrowTimeline model
   */ 
  interface EscrowTimelineFieldRefs {
    readonly id: FieldRef<"EscrowTimeline", 'BigInt'>
    readonly escrowId: FieldRef<"EscrowTimeline", 'Bytes'>
    readonly chainId: FieldRef<"EscrowTimeline", 'Int'>
    readonly eventName: FieldRef<"EscrowTimeline", 'String'>
    readonly stateAfter: FieldRef<"EscrowTimeline", 'String'>
    readonly txHash: FieldRef<"EscrowTimeline", 'String'>
    readonly blockNumber: FieldRef<"EscrowTimeline", 'BigInt'>
    readonly logIndex: FieldRef<"EscrowTimeline", 'Int'>
    readonly timestamp: FieldRef<"EscrowTimeline", 'DateTime'>
    readonly payload: FieldRef<"EscrowTimeline", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EscrowTimeline findUnique
   */
  export type EscrowTimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimeline to fetch.
     */
    where: EscrowTimelineWhereUniqueInput
  }

  /**
   * EscrowTimeline findUniqueOrThrow
   */
  export type EscrowTimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimeline to fetch.
     */
    where: EscrowTimelineWhereUniqueInput
  }

  /**
   * EscrowTimeline findFirst
   */
  export type EscrowTimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimeline to fetch.
     */
    where?: EscrowTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowTimelines to fetch.
     */
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowTimelines.
     */
    cursor?: EscrowTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowTimelines.
     */
    distinct?: EscrowTimelineScalarFieldEnum | EscrowTimelineScalarFieldEnum[]
  }

  /**
   * EscrowTimeline findFirstOrThrow
   */
  export type EscrowTimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimeline to fetch.
     */
    where?: EscrowTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowTimelines to fetch.
     */
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowTimelines.
     */
    cursor?: EscrowTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowTimelines.
     */
    distinct?: EscrowTimelineScalarFieldEnum | EscrowTimelineScalarFieldEnum[]
  }

  /**
   * EscrowTimeline findMany
   */
  export type EscrowTimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimelines to fetch.
     */
    where?: EscrowTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowTimelines to fetch.
     */
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowTimelines.
     */
    cursor?: EscrowTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowTimelines.
     */
    skip?: number
    distinct?: EscrowTimelineScalarFieldEnum | EscrowTimelineScalarFieldEnum[]
  }

  /**
   * EscrowTimeline create
   */
  export type EscrowTimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * The data needed to create a EscrowTimeline.
     */
    data: XOR<EscrowTimelineCreateInput, EscrowTimelineUncheckedCreateInput>
  }

  /**
   * EscrowTimeline createMany
   */
  export type EscrowTimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowTimelines.
     */
    data: EscrowTimelineCreateManyInput | EscrowTimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowTimeline createManyAndReturn
   */
  export type EscrowTimelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscrowTimelines.
     */
    data: EscrowTimelineCreateManyInput | EscrowTimelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscrowTimeline update
   */
  export type EscrowTimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * The data needed to update a EscrowTimeline.
     */
    data: XOR<EscrowTimelineUpdateInput, EscrowTimelineUncheckedUpdateInput>
    /**
     * Choose, which EscrowTimeline to update.
     */
    where: EscrowTimelineWhereUniqueInput
  }

  /**
   * EscrowTimeline updateMany
   */
  export type EscrowTimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowTimelines.
     */
    data: XOR<EscrowTimelineUpdateManyMutationInput, EscrowTimelineUncheckedUpdateManyInput>
    /**
     * Filter which EscrowTimelines to update
     */
    where?: EscrowTimelineWhereInput
  }

  /**
   * EscrowTimeline upsert
   */
  export type EscrowTimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * The filter to search for the EscrowTimeline to update in case it exists.
     */
    where: EscrowTimelineWhereUniqueInput
    /**
     * In case the EscrowTimeline found by the `where` argument doesn't exist, create a new EscrowTimeline with this data.
     */
    create: XOR<EscrowTimelineCreateInput, EscrowTimelineUncheckedCreateInput>
    /**
     * In case the EscrowTimeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowTimelineUpdateInput, EscrowTimelineUncheckedUpdateInput>
  }

  /**
   * EscrowTimeline delete
   */
  export type EscrowTimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter which EscrowTimeline to delete.
     */
    where: EscrowTimelineWhereUniqueInput
  }

  /**
   * EscrowTimeline deleteMany
   */
  export type EscrowTimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowTimelines to delete
     */
    where?: EscrowTimelineWhereInput
  }

  /**
   * EscrowTimeline without action
   */
  export type EscrowTimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
  }


  /**
   * Model EscrowMessage
   */

  export type AggregateEscrowMessage = {
    _count: EscrowMessageCountAggregateOutputType | null
    _min: EscrowMessageMinAggregateOutputType | null
    _max: EscrowMessageMaxAggregateOutputType | null
  }

  export type EscrowMessageMinAggregateOutputType = {
    id: string | null
    escrowId: Buffer | null
    sender: string | null
    text: string | null
    attachment: string | null
    hash: string | null
    createdAt: Date | null
    editedAt: Date | null
  }

  export type EscrowMessageMaxAggregateOutputType = {
    id: string | null
    escrowId: Buffer | null
    sender: string | null
    text: string | null
    attachment: string | null
    hash: string | null
    createdAt: Date | null
    editedAt: Date | null
  }

  export type EscrowMessageCountAggregateOutputType = {
    id: number
    escrowId: number
    sender: number
    text: number
    attachment: number
    hash: number
    createdAt: number
    editedAt: number
    _all: number
  }


  export type EscrowMessageMinAggregateInputType = {
    id?: true
    escrowId?: true
    sender?: true
    text?: true
    attachment?: true
    hash?: true
    createdAt?: true
    editedAt?: true
  }

  export type EscrowMessageMaxAggregateInputType = {
    id?: true
    escrowId?: true
    sender?: true
    text?: true
    attachment?: true
    hash?: true
    createdAt?: true
    editedAt?: true
  }

  export type EscrowMessageCountAggregateInputType = {
    id?: true
    escrowId?: true
    sender?: true
    text?: true
    attachment?: true
    hash?: true
    createdAt?: true
    editedAt?: true
    _all?: true
  }

  export type EscrowMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowMessage to aggregate.
     */
    where?: EscrowMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowMessages to fetch.
     */
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowMessages
    **/
    _count?: true | EscrowMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowMessageMaxAggregateInputType
  }

  export type GetEscrowMessageAggregateType<T extends EscrowMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowMessage[P]>
      : GetScalarType<T[P], AggregateEscrowMessage[P]>
  }




  export type EscrowMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowMessageWhereInput
    orderBy?: EscrowMessageOrderByWithAggregationInput | EscrowMessageOrderByWithAggregationInput[]
    by: EscrowMessageScalarFieldEnum[] | EscrowMessageScalarFieldEnum
    having?: EscrowMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowMessageCountAggregateInputType | true
    _min?: EscrowMessageMinAggregateInputType
    _max?: EscrowMessageMaxAggregateInputType
  }

  export type EscrowMessageGroupByOutputType = {
    id: string
    escrowId: Buffer | null
    sender: string
    text: string
    attachment: string | null
    hash: string | null
    createdAt: Date
    editedAt: Date | null
    _count: EscrowMessageCountAggregateOutputType | null
    _min: EscrowMessageMinAggregateOutputType | null
    _max: EscrowMessageMaxAggregateOutputType | null
  }

  type GetEscrowMessageGroupByPayload<T extends EscrowMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowMessageGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowMessageGroupByOutputType[P]>
        }
      >
    >


  export type EscrowMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    sender?: boolean
    text?: boolean
    attachment?: boolean
    hash?: boolean
    createdAt?: boolean
    editedAt?: boolean
    Escrow?: boolean | EscrowMessage$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["escrowMessage"]>

  export type EscrowMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    sender?: boolean
    text?: boolean
    attachment?: boolean
    hash?: boolean
    createdAt?: boolean
    editedAt?: boolean
    Escrow?: boolean | EscrowMessage$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["escrowMessage"]>

  export type EscrowMessageSelectScalar = {
    id?: boolean
    escrowId?: boolean
    sender?: boolean
    text?: boolean
    attachment?: boolean
    hash?: boolean
    createdAt?: boolean
    editedAt?: boolean
  }

  export type EscrowMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowMessage$EscrowArgs<ExtArgs>
  }
  export type EscrowMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowMessage$EscrowArgs<ExtArgs>
  }

  export type $EscrowMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowMessage"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      escrowId: Buffer | null
      sender: string
      text: string
      attachment: string | null
      hash: string | null
      createdAt: Date
      editedAt: Date | null
    }, ExtArgs["result"]["escrowMessage"]>
    composites: {}
  }

  type EscrowMessageGetPayload<S extends boolean | null | undefined | EscrowMessageDefaultArgs> = $Result.GetResult<Prisma.$EscrowMessagePayload, S>

  type EscrowMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowMessageCountAggregateInputType | true
    }

  export interface EscrowMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowMessage'], meta: { name: 'EscrowMessage' } }
    /**
     * Find zero or one EscrowMessage that matches the filter.
     * @param {EscrowMessageFindUniqueArgs} args - Arguments to find a EscrowMessage
     * @example
     * // Get one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowMessageFindUniqueArgs>(args: SelectSubset<T, EscrowMessageFindUniqueArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscrowMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowMessageFindUniqueOrThrowArgs} args - Arguments to find a EscrowMessage
     * @example
     * // Get one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscrowMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageFindFirstArgs} args - Arguments to find a EscrowMessage
     * @example
     * // Get one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowMessageFindFirstArgs>(args?: SelectSubset<T, EscrowMessageFindFirstArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscrowMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageFindFirstOrThrowArgs} args - Arguments to find a EscrowMessage
     * @example
     * // Get one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscrowMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowMessages
     * const escrowMessages = await prisma.escrowMessage.findMany()
     * 
     * // Get first 10 EscrowMessages
     * const escrowMessages = await prisma.escrowMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrowMessageWithIdOnly = await prisma.escrowMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscrowMessageFindManyArgs>(args?: SelectSubset<T, EscrowMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscrowMessage.
     * @param {EscrowMessageCreateArgs} args - Arguments to create a EscrowMessage.
     * @example
     * // Create one EscrowMessage
     * const EscrowMessage = await prisma.escrowMessage.create({
     *   data: {
     *     // ... data to create a EscrowMessage
     *   }
     * })
     * 
     */
    create<T extends EscrowMessageCreateArgs>(args: SelectSubset<T, EscrowMessageCreateArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscrowMessages.
     * @param {EscrowMessageCreateManyArgs} args - Arguments to create many EscrowMessages.
     * @example
     * // Create many EscrowMessages
     * const escrowMessage = await prisma.escrowMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowMessageCreateManyArgs>(args?: SelectSubset<T, EscrowMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscrowMessages and returns the data saved in the database.
     * @param {EscrowMessageCreateManyAndReturnArgs} args - Arguments to create many EscrowMessages.
     * @example
     * // Create many EscrowMessages
     * const escrowMessage = await prisma.escrowMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscrowMessages and only return the `id`
     * const escrowMessageWithIdOnly = await prisma.escrowMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscrowMessage.
     * @param {EscrowMessageDeleteArgs} args - Arguments to delete one EscrowMessage.
     * @example
     * // Delete one EscrowMessage
     * const EscrowMessage = await prisma.escrowMessage.delete({
     *   where: {
     *     // ... filter to delete one EscrowMessage
     *   }
     * })
     * 
     */
    delete<T extends EscrowMessageDeleteArgs>(args: SelectSubset<T, EscrowMessageDeleteArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscrowMessage.
     * @param {EscrowMessageUpdateArgs} args - Arguments to update one EscrowMessage.
     * @example
     * // Update one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowMessageUpdateArgs>(args: SelectSubset<T, EscrowMessageUpdateArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscrowMessages.
     * @param {EscrowMessageDeleteManyArgs} args - Arguments to filter EscrowMessages to delete.
     * @example
     * // Delete a few EscrowMessages
     * const { count } = await prisma.escrowMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowMessageDeleteManyArgs>(args?: SelectSubset<T, EscrowMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowMessages
     * const escrowMessage = await prisma.escrowMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowMessageUpdateManyArgs>(args: SelectSubset<T, EscrowMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowMessage.
     * @param {EscrowMessageUpsertArgs} args - Arguments to update or create a EscrowMessage.
     * @example
     * // Update or create a EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.upsert({
     *   create: {
     *     // ... data to create a EscrowMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowMessage we want to update
     *   }
     * })
     */
    upsert<T extends EscrowMessageUpsertArgs>(args: SelectSubset<T, EscrowMessageUpsertArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscrowMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageCountArgs} args - Arguments to filter EscrowMessages to count.
     * @example
     * // Count the number of EscrowMessages
     * const count = await prisma.escrowMessage.count({
     *   where: {
     *     // ... the filter for the EscrowMessages we want to count
     *   }
     * })
    **/
    count<T extends EscrowMessageCountArgs>(
      args?: Subset<T, EscrowMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowMessageAggregateArgs>(args: Subset<T, EscrowMessageAggregateArgs>): Prisma.PrismaPromise<GetEscrowMessageAggregateType<T>>

    /**
     * Group by EscrowMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowMessageGroupByArgs['orderBy'] }
        : { orderBy?: EscrowMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowMessage model
   */
  readonly fields: EscrowMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowMessage$EscrowArgs<ExtArgs> = {}>(args?: Subset<T, EscrowMessage$EscrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscrowMessage model
   */ 
  interface EscrowMessageFieldRefs {
    readonly id: FieldRef<"EscrowMessage", 'String'>
    readonly escrowId: FieldRef<"EscrowMessage", 'Bytes'>
    readonly sender: FieldRef<"EscrowMessage", 'String'>
    readonly text: FieldRef<"EscrowMessage", 'String'>
    readonly attachment: FieldRef<"EscrowMessage", 'String'>
    readonly hash: FieldRef<"EscrowMessage", 'String'>
    readonly createdAt: FieldRef<"EscrowMessage", 'DateTime'>
    readonly editedAt: FieldRef<"EscrowMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EscrowMessage findUnique
   */
  export type EscrowMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessage to fetch.
     */
    where: EscrowMessageWhereUniqueInput
  }

  /**
   * EscrowMessage findUniqueOrThrow
   */
  export type EscrowMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessage to fetch.
     */
    where: EscrowMessageWhereUniqueInput
  }

  /**
   * EscrowMessage findFirst
   */
  export type EscrowMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessage to fetch.
     */
    where?: EscrowMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowMessages to fetch.
     */
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowMessages.
     */
    cursor?: EscrowMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowMessages.
     */
    distinct?: EscrowMessageScalarFieldEnum | EscrowMessageScalarFieldEnum[]
  }

  /**
   * EscrowMessage findFirstOrThrow
   */
  export type EscrowMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessage to fetch.
     */
    where?: EscrowMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowMessages to fetch.
     */
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowMessages.
     */
    cursor?: EscrowMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowMessages.
     */
    distinct?: EscrowMessageScalarFieldEnum | EscrowMessageScalarFieldEnum[]
  }

  /**
   * EscrowMessage findMany
   */
  export type EscrowMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessages to fetch.
     */
    where?: EscrowMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowMessages to fetch.
     */
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowMessages.
     */
    cursor?: EscrowMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowMessages.
     */
    skip?: number
    distinct?: EscrowMessageScalarFieldEnum | EscrowMessageScalarFieldEnum[]
  }

  /**
   * EscrowMessage create
   */
  export type EscrowMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a EscrowMessage.
     */
    data: XOR<EscrowMessageCreateInput, EscrowMessageUncheckedCreateInput>
  }

  /**
   * EscrowMessage createMany
   */
  export type EscrowMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowMessages.
     */
    data: EscrowMessageCreateManyInput | EscrowMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowMessage createManyAndReturn
   */
  export type EscrowMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscrowMessages.
     */
    data: EscrowMessageCreateManyInput | EscrowMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscrowMessage update
   */
  export type EscrowMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a EscrowMessage.
     */
    data: XOR<EscrowMessageUpdateInput, EscrowMessageUncheckedUpdateInput>
    /**
     * Choose, which EscrowMessage to update.
     */
    where: EscrowMessageWhereUniqueInput
  }

  /**
   * EscrowMessage updateMany
   */
  export type EscrowMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowMessages.
     */
    data: XOR<EscrowMessageUpdateManyMutationInput, EscrowMessageUncheckedUpdateManyInput>
    /**
     * Filter which EscrowMessages to update
     */
    where?: EscrowMessageWhereInput
  }

  /**
   * EscrowMessage upsert
   */
  export type EscrowMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the EscrowMessage to update in case it exists.
     */
    where: EscrowMessageWhereUniqueInput
    /**
     * In case the EscrowMessage found by the `where` argument doesn't exist, create a new EscrowMessage with this data.
     */
    create: XOR<EscrowMessageCreateInput, EscrowMessageUncheckedCreateInput>
    /**
     * In case the EscrowMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowMessageUpdateInput, EscrowMessageUncheckedUpdateInput>
  }

  /**
   * EscrowMessage delete
   */
  export type EscrowMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter which EscrowMessage to delete.
     */
    where: EscrowMessageWhereUniqueInput
  }

  /**
   * EscrowMessage deleteMany
   */
  export type EscrowMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowMessages to delete
     */
    where?: EscrowMessageWhereInput
  }

  /**
   * EscrowMessage.Escrow
   */
  export type EscrowMessage$EscrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    where?: EscrowWhereInput
  }

  /**
   * EscrowMessage without action
   */
  export type EscrowMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
  }


  /**
   * Model EscrowPaymentInstruction
   */

  export type AggregateEscrowPaymentInstruction = {
    _count: EscrowPaymentInstructionCountAggregateOutputType | null
    _min: EscrowPaymentInstructionMinAggregateOutputType | null
    _max: EscrowPaymentInstructionMaxAggregateOutputType | null
  }

  export type EscrowPaymentInstructionMinAggregateOutputType = {
    escrowId: Buffer | null
    seller: string | null
    updatedAt: Date | null
  }

  export type EscrowPaymentInstructionMaxAggregateOutputType = {
    escrowId: Buffer | null
    seller: string | null
    updatedAt: Date | null
  }

  export type EscrowPaymentInstructionCountAggregateOutputType = {
    escrowId: number
    seller: number
    content: number
    updatedAt: number
    _all: number
  }


  export type EscrowPaymentInstructionMinAggregateInputType = {
    escrowId?: true
    seller?: true
    updatedAt?: true
  }

  export type EscrowPaymentInstructionMaxAggregateInputType = {
    escrowId?: true
    seller?: true
    updatedAt?: true
  }

  export type EscrowPaymentInstructionCountAggregateInputType = {
    escrowId?: true
    seller?: true
    content?: true
    updatedAt?: true
    _all?: true
  }

  export type EscrowPaymentInstructionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowPaymentInstruction to aggregate.
     */
    where?: EscrowPaymentInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowPaymentInstructions to fetch.
     */
    orderBy?: EscrowPaymentInstructionOrderByWithRelationInput | EscrowPaymentInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowPaymentInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowPaymentInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowPaymentInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowPaymentInstructions
    **/
    _count?: true | EscrowPaymentInstructionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowPaymentInstructionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowPaymentInstructionMaxAggregateInputType
  }

  export type GetEscrowPaymentInstructionAggregateType<T extends EscrowPaymentInstructionAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowPaymentInstruction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowPaymentInstruction[P]>
      : GetScalarType<T[P], AggregateEscrowPaymentInstruction[P]>
  }




  export type EscrowPaymentInstructionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowPaymentInstructionWhereInput
    orderBy?: EscrowPaymentInstructionOrderByWithAggregationInput | EscrowPaymentInstructionOrderByWithAggregationInput[]
    by: EscrowPaymentInstructionScalarFieldEnum[] | EscrowPaymentInstructionScalarFieldEnum
    having?: EscrowPaymentInstructionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowPaymentInstructionCountAggregateInputType | true
    _min?: EscrowPaymentInstructionMinAggregateInputType
    _max?: EscrowPaymentInstructionMaxAggregateInputType
  }

  export type EscrowPaymentInstructionGroupByOutputType = {
    escrowId: Buffer
    seller: string
    content: JsonValue | null
    updatedAt: Date
    _count: EscrowPaymentInstructionCountAggregateOutputType | null
    _min: EscrowPaymentInstructionMinAggregateOutputType | null
    _max: EscrowPaymentInstructionMaxAggregateOutputType | null
  }

  type GetEscrowPaymentInstructionGroupByPayload<T extends EscrowPaymentInstructionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowPaymentInstructionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowPaymentInstructionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowPaymentInstructionGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowPaymentInstructionGroupByOutputType[P]>
        }
      >
    >


  export type EscrowPaymentInstructionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    seller?: boolean
    content?: boolean
    updatedAt?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrowPaymentInstruction"]>

  export type EscrowPaymentInstructionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    seller?: boolean
    content?: boolean
    updatedAt?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrowPaymentInstruction"]>

  export type EscrowPaymentInstructionSelectScalar = {
    escrowId?: boolean
    seller?: boolean
    content?: boolean
    updatedAt?: boolean
  }

  export type EscrowPaymentInstructionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }
  export type EscrowPaymentInstructionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }

  export type $EscrowPaymentInstructionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowPaymentInstruction"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      escrowId: Buffer
      seller: string
      content: Prisma.JsonValue | null
      updatedAt: Date
    }, ExtArgs["result"]["escrowPaymentInstruction"]>
    composites: {}
  }

  type EscrowPaymentInstructionGetPayload<S extends boolean | null | undefined | EscrowPaymentInstructionDefaultArgs> = $Result.GetResult<Prisma.$EscrowPaymentInstructionPayload, S>

  type EscrowPaymentInstructionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowPaymentInstructionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowPaymentInstructionCountAggregateInputType | true
    }

  export interface EscrowPaymentInstructionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowPaymentInstruction'], meta: { name: 'EscrowPaymentInstruction' } }
    /**
     * Find zero or one EscrowPaymentInstruction that matches the filter.
     * @param {EscrowPaymentInstructionFindUniqueArgs} args - Arguments to find a EscrowPaymentInstruction
     * @example
     * // Get one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowPaymentInstructionFindUniqueArgs>(args: SelectSubset<T, EscrowPaymentInstructionFindUniqueArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscrowPaymentInstruction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowPaymentInstructionFindUniqueOrThrowArgs} args - Arguments to find a EscrowPaymentInstruction
     * @example
     * // Get one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowPaymentInstructionFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowPaymentInstructionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscrowPaymentInstruction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionFindFirstArgs} args - Arguments to find a EscrowPaymentInstruction
     * @example
     * // Get one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowPaymentInstructionFindFirstArgs>(args?: SelectSubset<T, EscrowPaymentInstructionFindFirstArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscrowPaymentInstruction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionFindFirstOrThrowArgs} args - Arguments to find a EscrowPaymentInstruction
     * @example
     * // Get one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowPaymentInstructionFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowPaymentInstructionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscrowPaymentInstructions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowPaymentInstructions
     * const escrowPaymentInstructions = await prisma.escrowPaymentInstruction.findMany()
     * 
     * // Get first 10 EscrowPaymentInstructions
     * const escrowPaymentInstructions = await prisma.escrowPaymentInstruction.findMany({ take: 10 })
     * 
     * // Only select the `escrowId`
     * const escrowPaymentInstructionWithEscrowIdOnly = await prisma.escrowPaymentInstruction.findMany({ select: { escrowId: true } })
     * 
     */
    findMany<T extends EscrowPaymentInstructionFindManyArgs>(args?: SelectSubset<T, EscrowPaymentInstructionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscrowPaymentInstruction.
     * @param {EscrowPaymentInstructionCreateArgs} args - Arguments to create a EscrowPaymentInstruction.
     * @example
     * // Create one EscrowPaymentInstruction
     * const EscrowPaymentInstruction = await prisma.escrowPaymentInstruction.create({
     *   data: {
     *     // ... data to create a EscrowPaymentInstruction
     *   }
     * })
     * 
     */
    create<T extends EscrowPaymentInstructionCreateArgs>(args: SelectSubset<T, EscrowPaymentInstructionCreateArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscrowPaymentInstructions.
     * @param {EscrowPaymentInstructionCreateManyArgs} args - Arguments to create many EscrowPaymentInstructions.
     * @example
     * // Create many EscrowPaymentInstructions
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowPaymentInstructionCreateManyArgs>(args?: SelectSubset<T, EscrowPaymentInstructionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscrowPaymentInstructions and returns the data saved in the database.
     * @param {EscrowPaymentInstructionCreateManyAndReturnArgs} args - Arguments to create many EscrowPaymentInstructions.
     * @example
     * // Create many EscrowPaymentInstructions
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscrowPaymentInstructions and only return the `escrowId`
     * const escrowPaymentInstructionWithEscrowIdOnly = await prisma.escrowPaymentInstruction.createManyAndReturn({ 
     *   select: { escrowId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowPaymentInstructionCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowPaymentInstructionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscrowPaymentInstruction.
     * @param {EscrowPaymentInstructionDeleteArgs} args - Arguments to delete one EscrowPaymentInstruction.
     * @example
     * // Delete one EscrowPaymentInstruction
     * const EscrowPaymentInstruction = await prisma.escrowPaymentInstruction.delete({
     *   where: {
     *     // ... filter to delete one EscrowPaymentInstruction
     *   }
     * })
     * 
     */
    delete<T extends EscrowPaymentInstructionDeleteArgs>(args: SelectSubset<T, EscrowPaymentInstructionDeleteArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscrowPaymentInstruction.
     * @param {EscrowPaymentInstructionUpdateArgs} args - Arguments to update one EscrowPaymentInstruction.
     * @example
     * // Update one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowPaymentInstructionUpdateArgs>(args: SelectSubset<T, EscrowPaymentInstructionUpdateArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscrowPaymentInstructions.
     * @param {EscrowPaymentInstructionDeleteManyArgs} args - Arguments to filter EscrowPaymentInstructions to delete.
     * @example
     * // Delete a few EscrowPaymentInstructions
     * const { count } = await prisma.escrowPaymentInstruction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowPaymentInstructionDeleteManyArgs>(args?: SelectSubset<T, EscrowPaymentInstructionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowPaymentInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowPaymentInstructions
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowPaymentInstructionUpdateManyArgs>(args: SelectSubset<T, EscrowPaymentInstructionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowPaymentInstruction.
     * @param {EscrowPaymentInstructionUpsertArgs} args - Arguments to update or create a EscrowPaymentInstruction.
     * @example
     * // Update or create a EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.upsert({
     *   create: {
     *     // ... data to create a EscrowPaymentInstruction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowPaymentInstruction we want to update
     *   }
     * })
     */
    upsert<T extends EscrowPaymentInstructionUpsertArgs>(args: SelectSubset<T, EscrowPaymentInstructionUpsertArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscrowPaymentInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionCountArgs} args - Arguments to filter EscrowPaymentInstructions to count.
     * @example
     * // Count the number of EscrowPaymentInstructions
     * const count = await prisma.escrowPaymentInstruction.count({
     *   where: {
     *     // ... the filter for the EscrowPaymentInstructions we want to count
     *   }
     * })
    **/
    count<T extends EscrowPaymentInstructionCountArgs>(
      args?: Subset<T, EscrowPaymentInstructionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowPaymentInstructionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowPaymentInstruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowPaymentInstructionAggregateArgs>(args: Subset<T, EscrowPaymentInstructionAggregateArgs>): Prisma.PrismaPromise<GetEscrowPaymentInstructionAggregateType<T>>

    /**
     * Group by EscrowPaymentInstruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowPaymentInstructionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowPaymentInstructionGroupByArgs['orderBy'] }
        : { orderBy?: EscrowPaymentInstructionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowPaymentInstructionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowPaymentInstructionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowPaymentInstruction model
   */
  readonly fields: EscrowPaymentInstructionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowPaymentInstruction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowPaymentInstructionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscrowDefaultArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscrowPaymentInstruction model
   */ 
  interface EscrowPaymentInstructionFieldRefs {
    readonly escrowId: FieldRef<"EscrowPaymentInstruction", 'Bytes'>
    readonly seller: FieldRef<"EscrowPaymentInstruction", 'String'>
    readonly content: FieldRef<"EscrowPaymentInstruction", 'Json'>
    readonly updatedAt: FieldRef<"EscrowPaymentInstruction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EscrowPaymentInstruction findUnique
   */
  export type EscrowPaymentInstructionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstruction to fetch.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
  }

  /**
   * EscrowPaymentInstruction findUniqueOrThrow
   */
  export type EscrowPaymentInstructionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstruction to fetch.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
  }

  /**
   * EscrowPaymentInstruction findFirst
   */
  export type EscrowPaymentInstructionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstruction to fetch.
     */
    where?: EscrowPaymentInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowPaymentInstructions to fetch.
     */
    orderBy?: EscrowPaymentInstructionOrderByWithRelationInput | EscrowPaymentInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowPaymentInstructions.
     */
    cursor?: EscrowPaymentInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowPaymentInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowPaymentInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowPaymentInstructions.
     */
    distinct?: EscrowPaymentInstructionScalarFieldEnum | EscrowPaymentInstructionScalarFieldEnum[]
  }

  /**
   * EscrowPaymentInstruction findFirstOrThrow
   */
  export type EscrowPaymentInstructionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstruction to fetch.
     */
    where?: EscrowPaymentInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowPaymentInstructions to fetch.
     */
    orderBy?: EscrowPaymentInstructionOrderByWithRelationInput | EscrowPaymentInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowPaymentInstructions.
     */
    cursor?: EscrowPaymentInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowPaymentInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowPaymentInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowPaymentInstructions.
     */
    distinct?: EscrowPaymentInstructionScalarFieldEnum | EscrowPaymentInstructionScalarFieldEnum[]
  }

  /**
   * EscrowPaymentInstruction findMany
   */
  export type EscrowPaymentInstructionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstructions to fetch.
     */
    where?: EscrowPaymentInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowPaymentInstructions to fetch.
     */
    orderBy?: EscrowPaymentInstructionOrderByWithRelationInput | EscrowPaymentInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowPaymentInstructions.
     */
    cursor?: EscrowPaymentInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowPaymentInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowPaymentInstructions.
     */
    skip?: number
    distinct?: EscrowPaymentInstructionScalarFieldEnum | EscrowPaymentInstructionScalarFieldEnum[]
  }

  /**
   * EscrowPaymentInstruction create
   */
  export type EscrowPaymentInstructionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * The data needed to create a EscrowPaymentInstruction.
     */
    data: XOR<EscrowPaymentInstructionCreateInput, EscrowPaymentInstructionUncheckedCreateInput>
  }

  /**
   * EscrowPaymentInstruction createMany
   */
  export type EscrowPaymentInstructionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowPaymentInstructions.
     */
    data: EscrowPaymentInstructionCreateManyInput | EscrowPaymentInstructionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowPaymentInstruction createManyAndReturn
   */
  export type EscrowPaymentInstructionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscrowPaymentInstructions.
     */
    data: EscrowPaymentInstructionCreateManyInput | EscrowPaymentInstructionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscrowPaymentInstruction update
   */
  export type EscrowPaymentInstructionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * The data needed to update a EscrowPaymentInstruction.
     */
    data: XOR<EscrowPaymentInstructionUpdateInput, EscrowPaymentInstructionUncheckedUpdateInput>
    /**
     * Choose, which EscrowPaymentInstruction to update.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
  }

  /**
   * EscrowPaymentInstruction updateMany
   */
  export type EscrowPaymentInstructionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowPaymentInstructions.
     */
    data: XOR<EscrowPaymentInstructionUpdateManyMutationInput, EscrowPaymentInstructionUncheckedUpdateManyInput>
    /**
     * Filter which EscrowPaymentInstructions to update
     */
    where?: EscrowPaymentInstructionWhereInput
  }

  /**
   * EscrowPaymentInstruction upsert
   */
  export type EscrowPaymentInstructionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * The filter to search for the EscrowPaymentInstruction to update in case it exists.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
    /**
     * In case the EscrowPaymentInstruction found by the `where` argument doesn't exist, create a new EscrowPaymentInstruction with this data.
     */
    create: XOR<EscrowPaymentInstructionCreateInput, EscrowPaymentInstructionUncheckedCreateInput>
    /**
     * In case the EscrowPaymentInstruction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowPaymentInstructionUpdateInput, EscrowPaymentInstructionUncheckedUpdateInput>
  }

  /**
   * EscrowPaymentInstruction delete
   */
  export type EscrowPaymentInstructionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter which EscrowPaymentInstruction to delete.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
  }

  /**
   * EscrowPaymentInstruction deleteMany
   */
  export type EscrowPaymentInstructionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowPaymentInstructions to delete
     */
    where?: EscrowPaymentInstructionWhereInput
  }

  /**
   * EscrowPaymentInstruction without action
   */
  export type EscrowPaymentInstructionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
  }


  /**
   * Model EscrowFiatStatus
   */

  export type AggregateEscrowFiatStatus = {
    _count: EscrowFiatStatusCountAggregateOutputType | null
    _avg: EscrowFiatStatusAvgAggregateOutputType | null
    _sum: EscrowFiatStatusSumAggregateOutputType | null
    _min: EscrowFiatStatusMinAggregateOutputType | null
    _max: EscrowFiatStatusMaxAggregateOutputType | null
  }

  export type EscrowFiatStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type EscrowFiatStatusSumAggregateOutputType = {
    id: bigint | null
  }

  export type EscrowFiatStatusMinAggregateOutputType = {
    id: bigint | null
    escrowId: Buffer | null
    actor: string | null
    status: string | null
    note: string | null
    createdAt: Date | null
  }

  export type EscrowFiatStatusMaxAggregateOutputType = {
    id: bigint | null
    escrowId: Buffer | null
    actor: string | null
    status: string | null
    note: string | null
    createdAt: Date | null
  }

  export type EscrowFiatStatusCountAggregateOutputType = {
    id: number
    escrowId: number
    actor: number
    status: number
    note: number
    createdAt: number
    _all: number
  }


  export type EscrowFiatStatusAvgAggregateInputType = {
    id?: true
  }

  export type EscrowFiatStatusSumAggregateInputType = {
    id?: true
  }

  export type EscrowFiatStatusMinAggregateInputType = {
    id?: true
    escrowId?: true
    actor?: true
    status?: true
    note?: true
    createdAt?: true
  }

  export type EscrowFiatStatusMaxAggregateInputType = {
    id?: true
    escrowId?: true
    actor?: true
    status?: true
    note?: true
    createdAt?: true
  }

  export type EscrowFiatStatusCountAggregateInputType = {
    id?: true
    escrowId?: true
    actor?: true
    status?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type EscrowFiatStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowFiatStatus to aggregate.
     */
    where?: EscrowFiatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowFiatStatuses to fetch.
     */
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowFiatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowFiatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowFiatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowFiatStatuses
    **/
    _count?: true | EscrowFiatStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscrowFiatStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscrowFiatStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowFiatStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowFiatStatusMaxAggregateInputType
  }

  export type GetEscrowFiatStatusAggregateType<T extends EscrowFiatStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowFiatStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowFiatStatus[P]>
      : GetScalarType<T[P], AggregateEscrowFiatStatus[P]>
  }




  export type EscrowFiatStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowFiatStatusWhereInput
    orderBy?: EscrowFiatStatusOrderByWithAggregationInput | EscrowFiatStatusOrderByWithAggregationInput[]
    by: EscrowFiatStatusScalarFieldEnum[] | EscrowFiatStatusScalarFieldEnum
    having?: EscrowFiatStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowFiatStatusCountAggregateInputType | true
    _avg?: EscrowFiatStatusAvgAggregateInputType
    _sum?: EscrowFiatStatusSumAggregateInputType
    _min?: EscrowFiatStatusMinAggregateInputType
    _max?: EscrowFiatStatusMaxAggregateInputType
  }

  export type EscrowFiatStatusGroupByOutputType = {
    id: bigint
    escrowId: Buffer | null
    actor: string
    status: string
    note: string | null
    createdAt: Date
    _count: EscrowFiatStatusCountAggregateOutputType | null
    _avg: EscrowFiatStatusAvgAggregateOutputType | null
    _sum: EscrowFiatStatusSumAggregateOutputType | null
    _min: EscrowFiatStatusMinAggregateOutputType | null
    _max: EscrowFiatStatusMaxAggregateOutputType | null
  }

  type GetEscrowFiatStatusGroupByPayload<T extends EscrowFiatStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowFiatStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowFiatStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowFiatStatusGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowFiatStatusGroupByOutputType[P]>
        }
      >
    >


  export type EscrowFiatStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    actor?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    Escrow?: boolean | EscrowFiatStatus$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["escrowFiatStatus"]>

  export type EscrowFiatStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    actor?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    Escrow?: boolean | EscrowFiatStatus$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["escrowFiatStatus"]>

  export type EscrowFiatStatusSelectScalar = {
    id?: boolean
    escrowId?: boolean
    actor?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type EscrowFiatStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowFiatStatus$EscrowArgs<ExtArgs>
  }
  export type EscrowFiatStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowFiatStatus$EscrowArgs<ExtArgs>
  }

  export type $EscrowFiatStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowFiatStatus"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      escrowId: Buffer | null
      actor: string
      status: string
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["escrowFiatStatus"]>
    composites: {}
  }

  type EscrowFiatStatusGetPayload<S extends boolean | null | undefined | EscrowFiatStatusDefaultArgs> = $Result.GetResult<Prisma.$EscrowFiatStatusPayload, S>

  type EscrowFiatStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowFiatStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowFiatStatusCountAggregateInputType | true
    }

  export interface EscrowFiatStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowFiatStatus'], meta: { name: 'EscrowFiatStatus' } }
    /**
     * Find zero or one EscrowFiatStatus that matches the filter.
     * @param {EscrowFiatStatusFindUniqueArgs} args - Arguments to find a EscrowFiatStatus
     * @example
     * // Get one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowFiatStatusFindUniqueArgs>(args: SelectSubset<T, EscrowFiatStatusFindUniqueArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscrowFiatStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowFiatStatusFindUniqueOrThrowArgs} args - Arguments to find a EscrowFiatStatus
     * @example
     * // Get one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowFiatStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowFiatStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscrowFiatStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusFindFirstArgs} args - Arguments to find a EscrowFiatStatus
     * @example
     * // Get one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowFiatStatusFindFirstArgs>(args?: SelectSubset<T, EscrowFiatStatusFindFirstArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscrowFiatStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusFindFirstOrThrowArgs} args - Arguments to find a EscrowFiatStatus
     * @example
     * // Get one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowFiatStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowFiatStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscrowFiatStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowFiatStatuses
     * const escrowFiatStatuses = await prisma.escrowFiatStatus.findMany()
     * 
     * // Get first 10 EscrowFiatStatuses
     * const escrowFiatStatuses = await prisma.escrowFiatStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrowFiatStatusWithIdOnly = await prisma.escrowFiatStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscrowFiatStatusFindManyArgs>(args?: SelectSubset<T, EscrowFiatStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscrowFiatStatus.
     * @param {EscrowFiatStatusCreateArgs} args - Arguments to create a EscrowFiatStatus.
     * @example
     * // Create one EscrowFiatStatus
     * const EscrowFiatStatus = await prisma.escrowFiatStatus.create({
     *   data: {
     *     // ... data to create a EscrowFiatStatus
     *   }
     * })
     * 
     */
    create<T extends EscrowFiatStatusCreateArgs>(args: SelectSubset<T, EscrowFiatStatusCreateArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscrowFiatStatuses.
     * @param {EscrowFiatStatusCreateManyArgs} args - Arguments to create many EscrowFiatStatuses.
     * @example
     * // Create many EscrowFiatStatuses
     * const escrowFiatStatus = await prisma.escrowFiatStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowFiatStatusCreateManyArgs>(args?: SelectSubset<T, EscrowFiatStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscrowFiatStatuses and returns the data saved in the database.
     * @param {EscrowFiatStatusCreateManyAndReturnArgs} args - Arguments to create many EscrowFiatStatuses.
     * @example
     * // Create many EscrowFiatStatuses
     * const escrowFiatStatus = await prisma.escrowFiatStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscrowFiatStatuses and only return the `id`
     * const escrowFiatStatusWithIdOnly = await prisma.escrowFiatStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowFiatStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowFiatStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscrowFiatStatus.
     * @param {EscrowFiatStatusDeleteArgs} args - Arguments to delete one EscrowFiatStatus.
     * @example
     * // Delete one EscrowFiatStatus
     * const EscrowFiatStatus = await prisma.escrowFiatStatus.delete({
     *   where: {
     *     // ... filter to delete one EscrowFiatStatus
     *   }
     * })
     * 
     */
    delete<T extends EscrowFiatStatusDeleteArgs>(args: SelectSubset<T, EscrowFiatStatusDeleteArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscrowFiatStatus.
     * @param {EscrowFiatStatusUpdateArgs} args - Arguments to update one EscrowFiatStatus.
     * @example
     * // Update one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowFiatStatusUpdateArgs>(args: SelectSubset<T, EscrowFiatStatusUpdateArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscrowFiatStatuses.
     * @param {EscrowFiatStatusDeleteManyArgs} args - Arguments to filter EscrowFiatStatuses to delete.
     * @example
     * // Delete a few EscrowFiatStatuses
     * const { count } = await prisma.escrowFiatStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowFiatStatusDeleteManyArgs>(args?: SelectSubset<T, EscrowFiatStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowFiatStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowFiatStatuses
     * const escrowFiatStatus = await prisma.escrowFiatStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowFiatStatusUpdateManyArgs>(args: SelectSubset<T, EscrowFiatStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowFiatStatus.
     * @param {EscrowFiatStatusUpsertArgs} args - Arguments to update or create a EscrowFiatStatus.
     * @example
     * // Update or create a EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.upsert({
     *   create: {
     *     // ... data to create a EscrowFiatStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowFiatStatus we want to update
     *   }
     * })
     */
    upsert<T extends EscrowFiatStatusUpsertArgs>(args: SelectSubset<T, EscrowFiatStatusUpsertArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscrowFiatStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusCountArgs} args - Arguments to filter EscrowFiatStatuses to count.
     * @example
     * // Count the number of EscrowFiatStatuses
     * const count = await prisma.escrowFiatStatus.count({
     *   where: {
     *     // ... the filter for the EscrowFiatStatuses we want to count
     *   }
     * })
    **/
    count<T extends EscrowFiatStatusCountArgs>(
      args?: Subset<T, EscrowFiatStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowFiatStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowFiatStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowFiatStatusAggregateArgs>(args: Subset<T, EscrowFiatStatusAggregateArgs>): Prisma.PrismaPromise<GetEscrowFiatStatusAggregateType<T>>

    /**
     * Group by EscrowFiatStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowFiatStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowFiatStatusGroupByArgs['orderBy'] }
        : { orderBy?: EscrowFiatStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowFiatStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowFiatStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowFiatStatus model
   */
  readonly fields: EscrowFiatStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowFiatStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowFiatStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowFiatStatus$EscrowArgs<ExtArgs> = {}>(args?: Subset<T, EscrowFiatStatus$EscrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscrowFiatStatus model
   */ 
  interface EscrowFiatStatusFieldRefs {
    readonly id: FieldRef<"EscrowFiatStatus", 'BigInt'>
    readonly escrowId: FieldRef<"EscrowFiatStatus", 'Bytes'>
    readonly actor: FieldRef<"EscrowFiatStatus", 'String'>
    readonly status: FieldRef<"EscrowFiatStatus", 'String'>
    readonly note: FieldRef<"EscrowFiatStatus", 'String'>
    readonly createdAt: FieldRef<"EscrowFiatStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EscrowFiatStatus findUnique
   */
  export type EscrowFiatStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatus to fetch.
     */
    where: EscrowFiatStatusWhereUniqueInput
  }

  /**
   * EscrowFiatStatus findUniqueOrThrow
   */
  export type EscrowFiatStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatus to fetch.
     */
    where: EscrowFiatStatusWhereUniqueInput
  }

  /**
   * EscrowFiatStatus findFirst
   */
  export type EscrowFiatStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatus to fetch.
     */
    where?: EscrowFiatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowFiatStatuses to fetch.
     */
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowFiatStatuses.
     */
    cursor?: EscrowFiatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowFiatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowFiatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowFiatStatuses.
     */
    distinct?: EscrowFiatStatusScalarFieldEnum | EscrowFiatStatusScalarFieldEnum[]
  }

  /**
   * EscrowFiatStatus findFirstOrThrow
   */
  export type EscrowFiatStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatus to fetch.
     */
    where?: EscrowFiatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowFiatStatuses to fetch.
     */
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowFiatStatuses.
     */
    cursor?: EscrowFiatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowFiatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowFiatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowFiatStatuses.
     */
    distinct?: EscrowFiatStatusScalarFieldEnum | EscrowFiatStatusScalarFieldEnum[]
  }

  /**
   * EscrowFiatStatus findMany
   */
  export type EscrowFiatStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatuses to fetch.
     */
    where?: EscrowFiatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowFiatStatuses to fetch.
     */
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowFiatStatuses.
     */
    cursor?: EscrowFiatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowFiatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowFiatStatuses.
     */
    skip?: number
    distinct?: EscrowFiatStatusScalarFieldEnum | EscrowFiatStatusScalarFieldEnum[]
  }

  /**
   * EscrowFiatStatus create
   */
  export type EscrowFiatStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a EscrowFiatStatus.
     */
    data: XOR<EscrowFiatStatusCreateInput, EscrowFiatStatusUncheckedCreateInput>
  }

  /**
   * EscrowFiatStatus createMany
   */
  export type EscrowFiatStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowFiatStatuses.
     */
    data: EscrowFiatStatusCreateManyInput | EscrowFiatStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowFiatStatus createManyAndReturn
   */
  export type EscrowFiatStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscrowFiatStatuses.
     */
    data: EscrowFiatStatusCreateManyInput | EscrowFiatStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscrowFiatStatus update
   */
  export type EscrowFiatStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a EscrowFiatStatus.
     */
    data: XOR<EscrowFiatStatusUpdateInput, EscrowFiatStatusUncheckedUpdateInput>
    /**
     * Choose, which EscrowFiatStatus to update.
     */
    where: EscrowFiatStatusWhereUniqueInput
  }

  /**
   * EscrowFiatStatus updateMany
   */
  export type EscrowFiatStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowFiatStatuses.
     */
    data: XOR<EscrowFiatStatusUpdateManyMutationInput, EscrowFiatStatusUncheckedUpdateManyInput>
    /**
     * Filter which EscrowFiatStatuses to update
     */
    where?: EscrowFiatStatusWhereInput
  }

  /**
   * EscrowFiatStatus upsert
   */
  export type EscrowFiatStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the EscrowFiatStatus to update in case it exists.
     */
    where: EscrowFiatStatusWhereUniqueInput
    /**
     * In case the EscrowFiatStatus found by the `where` argument doesn't exist, create a new EscrowFiatStatus with this data.
     */
    create: XOR<EscrowFiatStatusCreateInput, EscrowFiatStatusUncheckedCreateInput>
    /**
     * In case the EscrowFiatStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowFiatStatusUpdateInput, EscrowFiatStatusUncheckedUpdateInput>
  }

  /**
   * EscrowFiatStatus delete
   */
  export type EscrowFiatStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter which EscrowFiatStatus to delete.
     */
    where: EscrowFiatStatusWhereUniqueInput
  }

  /**
   * EscrowFiatStatus deleteMany
   */
  export type EscrowFiatStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowFiatStatuses to delete
     */
    where?: EscrowFiatStatusWhereInput
  }

  /**
   * EscrowFiatStatus.Escrow
   */
  export type EscrowFiatStatus$EscrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    where?: EscrowWhereInput
  }

  /**
   * EscrowFiatStatus without action
   */
  export type EscrowFiatStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
  }


  /**
   * Model EvidenceItem
   */

  export type AggregateEvidenceItem = {
    _count: EvidenceItemCountAggregateOutputType | null
    _avg: EvidenceItemAvgAggregateOutputType | null
    _sum: EvidenceItemSumAggregateOutputType | null
    _min: EvidenceItemMinAggregateOutputType | null
    _max: EvidenceItemMaxAggregateOutputType | null
  }

  export type EvidenceItemAvgAggregateOutputType = {
    size: number | null
  }

  export type EvidenceItemSumAggregateOutputType = {
    size: bigint | null
  }

  export type EvidenceItemMinAggregateOutputType = {
    id: string | null
    escrowId: Buffer | null
    uploader: string | null
    uri: string | null
    sha256: string | null
    mime: string | null
    size: bigint | null
    description: string | null
    createdAt: Date | null
  }

  export type EvidenceItemMaxAggregateOutputType = {
    id: string | null
    escrowId: Buffer | null
    uploader: string | null
    uri: string | null
    sha256: string | null
    mime: string | null
    size: bigint | null
    description: string | null
    createdAt: Date | null
  }

  export type EvidenceItemCountAggregateOutputType = {
    id: number
    escrowId: number
    uploader: number
    uri: number
    sha256: number
    mime: number
    size: number
    description: number
    createdAt: number
    _all: number
  }


  export type EvidenceItemAvgAggregateInputType = {
    size?: true
  }

  export type EvidenceItemSumAggregateInputType = {
    size?: true
  }

  export type EvidenceItemMinAggregateInputType = {
    id?: true
    escrowId?: true
    uploader?: true
    uri?: true
    sha256?: true
    mime?: true
    size?: true
    description?: true
    createdAt?: true
  }

  export type EvidenceItemMaxAggregateInputType = {
    id?: true
    escrowId?: true
    uploader?: true
    uri?: true
    sha256?: true
    mime?: true
    size?: true
    description?: true
    createdAt?: true
  }

  export type EvidenceItemCountAggregateInputType = {
    id?: true
    escrowId?: true
    uploader?: true
    uri?: true
    sha256?: true
    mime?: true
    size?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type EvidenceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvidenceItem to aggregate.
     */
    where?: EvidenceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvidenceItems to fetch.
     */
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvidenceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvidenceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvidenceItems
    **/
    _count?: true | EvidenceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvidenceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvidenceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenceItemMaxAggregateInputType
  }

  export type GetEvidenceItemAggregateType<T extends EvidenceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidenceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidenceItem[P]>
      : GetScalarType<T[P], AggregateEvidenceItem[P]>
  }




  export type EvidenceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceItemWhereInput
    orderBy?: EvidenceItemOrderByWithAggregationInput | EvidenceItemOrderByWithAggregationInput[]
    by: EvidenceItemScalarFieldEnum[] | EvidenceItemScalarFieldEnum
    having?: EvidenceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenceItemCountAggregateInputType | true
    _avg?: EvidenceItemAvgAggregateInputType
    _sum?: EvidenceItemSumAggregateInputType
    _min?: EvidenceItemMinAggregateInputType
    _max?: EvidenceItemMaxAggregateInputType
  }

  export type EvidenceItemGroupByOutputType = {
    id: string
    escrowId: Buffer | null
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint
    description: string | null
    createdAt: Date
    _count: EvidenceItemCountAggregateOutputType | null
    _avg: EvidenceItemAvgAggregateOutputType | null
    _sum: EvidenceItemSumAggregateOutputType | null
    _min: EvidenceItemMinAggregateOutputType | null
    _max: EvidenceItemMaxAggregateOutputType | null
  }

  type GetEvidenceItemGroupByPayload<T extends EvidenceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenceItemGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenceItemGroupByOutputType[P]>
        }
      >
    >


  export type EvidenceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    uploader?: boolean
    uri?: boolean
    sha256?: boolean
    mime?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
    Escrow?: boolean | EvidenceItem$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["evidenceItem"]>

  export type EvidenceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    uploader?: boolean
    uri?: boolean
    sha256?: boolean
    mime?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
    Escrow?: boolean | EvidenceItem$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["evidenceItem"]>

  export type EvidenceItemSelectScalar = {
    id?: boolean
    escrowId?: boolean
    uploader?: boolean
    uri?: boolean
    sha256?: boolean
    mime?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type EvidenceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EvidenceItem$EscrowArgs<ExtArgs>
  }
  export type EvidenceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EvidenceItem$EscrowArgs<ExtArgs>
  }

  export type $EvidenceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvidenceItem"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      escrowId: Buffer | null
      uploader: string
      uri: string
      sha256: string
      mime: string
      size: bigint
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["evidenceItem"]>
    composites: {}
  }

  type EvidenceItemGetPayload<S extends boolean | null | undefined | EvidenceItemDefaultArgs> = $Result.GetResult<Prisma.$EvidenceItemPayload, S>

  type EvidenceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvidenceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvidenceItemCountAggregateInputType | true
    }

  export interface EvidenceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvidenceItem'], meta: { name: 'EvidenceItem' } }
    /**
     * Find zero or one EvidenceItem that matches the filter.
     * @param {EvidenceItemFindUniqueArgs} args - Arguments to find a EvidenceItem
     * @example
     * // Get one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenceItemFindUniqueArgs>(args: SelectSubset<T, EvidenceItemFindUniqueArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvidenceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvidenceItemFindUniqueOrThrowArgs} args - Arguments to find a EvidenceItem
     * @example
     * // Get one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvidenceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemFindFirstArgs} args - Arguments to find a EvidenceItem
     * @example
     * // Get one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenceItemFindFirstArgs>(args?: SelectSubset<T, EvidenceItemFindFirstArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvidenceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemFindFirstOrThrowArgs} args - Arguments to find a EvidenceItem
     * @example
     * // Get one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvidenceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvidenceItems
     * const evidenceItems = await prisma.evidenceItem.findMany()
     * 
     * // Get first 10 EvidenceItems
     * const evidenceItems = await prisma.evidenceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenceItemWithIdOnly = await prisma.evidenceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenceItemFindManyArgs>(args?: SelectSubset<T, EvidenceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvidenceItem.
     * @param {EvidenceItemCreateArgs} args - Arguments to create a EvidenceItem.
     * @example
     * // Create one EvidenceItem
     * const EvidenceItem = await prisma.evidenceItem.create({
     *   data: {
     *     // ... data to create a EvidenceItem
     *   }
     * })
     * 
     */
    create<T extends EvidenceItemCreateArgs>(args: SelectSubset<T, EvidenceItemCreateArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvidenceItems.
     * @param {EvidenceItemCreateManyArgs} args - Arguments to create many EvidenceItems.
     * @example
     * // Create many EvidenceItems
     * const evidenceItem = await prisma.evidenceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenceItemCreateManyArgs>(args?: SelectSubset<T, EvidenceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvidenceItems and returns the data saved in the database.
     * @param {EvidenceItemCreateManyAndReturnArgs} args - Arguments to create many EvidenceItems.
     * @example
     * // Create many EvidenceItems
     * const evidenceItem = await prisma.evidenceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvidenceItems and only return the `id`
     * const evidenceItemWithIdOnly = await prisma.evidenceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvidenceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvidenceItem.
     * @param {EvidenceItemDeleteArgs} args - Arguments to delete one EvidenceItem.
     * @example
     * // Delete one EvidenceItem
     * const EvidenceItem = await prisma.evidenceItem.delete({
     *   where: {
     *     // ... filter to delete one EvidenceItem
     *   }
     * })
     * 
     */
    delete<T extends EvidenceItemDeleteArgs>(args: SelectSubset<T, EvidenceItemDeleteArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvidenceItem.
     * @param {EvidenceItemUpdateArgs} args - Arguments to update one EvidenceItem.
     * @example
     * // Update one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenceItemUpdateArgs>(args: SelectSubset<T, EvidenceItemUpdateArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvidenceItems.
     * @param {EvidenceItemDeleteManyArgs} args - Arguments to filter EvidenceItems to delete.
     * @example
     * // Delete a few EvidenceItems
     * const { count } = await prisma.evidenceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenceItemDeleteManyArgs>(args?: SelectSubset<T, EvidenceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvidenceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvidenceItems
     * const evidenceItem = await prisma.evidenceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenceItemUpdateManyArgs>(args: SelectSubset<T, EvidenceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvidenceItem.
     * @param {EvidenceItemUpsertArgs} args - Arguments to update or create a EvidenceItem.
     * @example
     * // Update or create a EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.upsert({
     *   create: {
     *     // ... data to create a EvidenceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvidenceItem we want to update
     *   }
     * })
     */
    upsert<T extends EvidenceItemUpsertArgs>(args: SelectSubset<T, EvidenceItemUpsertArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvidenceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemCountArgs} args - Arguments to filter EvidenceItems to count.
     * @example
     * // Count the number of EvidenceItems
     * const count = await prisma.evidenceItem.count({
     *   where: {
     *     // ... the filter for the EvidenceItems we want to count
     *   }
     * })
    **/
    count<T extends EvidenceItemCountArgs>(
      args?: Subset<T, EvidenceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvidenceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenceItemAggregateArgs>(args: Subset<T, EvidenceItemAggregateArgs>): Prisma.PrismaPromise<GetEvidenceItemAggregateType<T>>

    /**
     * Group by EvidenceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenceItemGroupByArgs['orderBy'] }
        : { orderBy?: EvidenceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvidenceItem model
   */
  readonly fields: EvidenceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvidenceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EvidenceItem$EscrowArgs<ExtArgs> = {}>(args?: Subset<T, EvidenceItem$EscrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvidenceItem model
   */ 
  interface EvidenceItemFieldRefs {
    readonly id: FieldRef<"EvidenceItem", 'String'>
    readonly escrowId: FieldRef<"EvidenceItem", 'Bytes'>
    readonly uploader: FieldRef<"EvidenceItem", 'String'>
    readonly uri: FieldRef<"EvidenceItem", 'String'>
    readonly sha256: FieldRef<"EvidenceItem", 'String'>
    readonly mime: FieldRef<"EvidenceItem", 'String'>
    readonly size: FieldRef<"EvidenceItem", 'BigInt'>
    readonly description: FieldRef<"EvidenceItem", 'String'>
    readonly createdAt: FieldRef<"EvidenceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvidenceItem findUnique
   */
  export type EvidenceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItem to fetch.
     */
    where: EvidenceItemWhereUniqueInput
  }

  /**
   * EvidenceItem findUniqueOrThrow
   */
  export type EvidenceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItem to fetch.
     */
    where: EvidenceItemWhereUniqueInput
  }

  /**
   * EvidenceItem findFirst
   */
  export type EvidenceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItem to fetch.
     */
    where?: EvidenceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvidenceItems to fetch.
     */
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvidenceItems.
     */
    cursor?: EvidenceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvidenceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvidenceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvidenceItems.
     */
    distinct?: EvidenceItemScalarFieldEnum | EvidenceItemScalarFieldEnum[]
  }

  /**
   * EvidenceItem findFirstOrThrow
   */
  export type EvidenceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItem to fetch.
     */
    where?: EvidenceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvidenceItems to fetch.
     */
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvidenceItems.
     */
    cursor?: EvidenceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvidenceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvidenceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvidenceItems.
     */
    distinct?: EvidenceItemScalarFieldEnum | EvidenceItemScalarFieldEnum[]
  }

  /**
   * EvidenceItem findMany
   */
  export type EvidenceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItems to fetch.
     */
    where?: EvidenceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvidenceItems to fetch.
     */
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvidenceItems.
     */
    cursor?: EvidenceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvidenceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvidenceItems.
     */
    skip?: number
    distinct?: EvidenceItemScalarFieldEnum | EvidenceItemScalarFieldEnum[]
  }

  /**
   * EvidenceItem create
   */
  export type EvidenceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a EvidenceItem.
     */
    data: XOR<EvidenceItemCreateInput, EvidenceItemUncheckedCreateInput>
  }

  /**
   * EvidenceItem createMany
   */
  export type EvidenceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvidenceItems.
     */
    data: EvidenceItemCreateManyInput | EvidenceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvidenceItem createManyAndReturn
   */
  export type EvidenceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvidenceItems.
     */
    data: EvidenceItemCreateManyInput | EvidenceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvidenceItem update
   */
  export type EvidenceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a EvidenceItem.
     */
    data: XOR<EvidenceItemUpdateInput, EvidenceItemUncheckedUpdateInput>
    /**
     * Choose, which EvidenceItem to update.
     */
    where: EvidenceItemWhereUniqueInput
  }

  /**
   * EvidenceItem updateMany
   */
  export type EvidenceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvidenceItems.
     */
    data: XOR<EvidenceItemUpdateManyMutationInput, EvidenceItemUncheckedUpdateManyInput>
    /**
     * Filter which EvidenceItems to update
     */
    where?: EvidenceItemWhereInput
  }

  /**
   * EvidenceItem upsert
   */
  export type EvidenceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the EvidenceItem to update in case it exists.
     */
    where: EvidenceItemWhereUniqueInput
    /**
     * In case the EvidenceItem found by the `where` argument doesn't exist, create a new EvidenceItem with this data.
     */
    create: XOR<EvidenceItemCreateInput, EvidenceItemUncheckedCreateInput>
    /**
     * In case the EvidenceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenceItemUpdateInput, EvidenceItemUncheckedUpdateInput>
  }

  /**
   * EvidenceItem delete
   */
  export type EvidenceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter which EvidenceItem to delete.
     */
    where: EvidenceItemWhereUniqueInput
  }

  /**
   * EvidenceItem deleteMany
   */
  export type EvidenceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvidenceItems to delete
     */
    where?: EvidenceItemWhereInput
  }

  /**
   * EvidenceItem.Escrow
   */
  export type EvidenceItem$EscrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    where?: EscrowWhereInput
  }

  /**
   * EvidenceItem without action
   */
  export type EvidenceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
  }


  /**
   * Model Dispute
   */

  export type AggregateDispute = {
    _count: DisputeCountAggregateOutputType | null
    _avg: DisputeAvgAggregateOutputType | null
    _sum: DisputeSumAggregateOutputType | null
    _min: DisputeMinAggregateOutputType | null
    _max: DisputeMaxAggregateOutputType | null
  }

  export type DisputeAvgAggregateOutputType = {
    escalationLevel: number | null
  }

  export type DisputeSumAggregateOutputType = {
    escalationLevel: number | null
  }

  export type DisputeMinAggregateOutputType = {
    escrowId: Buffer | null
    openedBy: string | null
    reasonCode: string | null
    summary: string | null
    status: string | null
    arbitratorAssigned: string | null
    outcome: string | null
    ref: Buffer | null
    escalationLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputeMaxAggregateOutputType = {
    escrowId: Buffer | null
    openedBy: string | null
    reasonCode: string | null
    summary: string | null
    status: string | null
    arbitratorAssigned: string | null
    outcome: string | null
    ref: Buffer | null
    escalationLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputeCountAggregateOutputType = {
    escrowId: number
    openedBy: number
    reasonCode: number
    summary: number
    status: number
    arbitratorAssigned: number
    outcome: number
    ref: number
    escalationLevel: number
    aiAnalysis: number
    tier2Analysis: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisputeAvgAggregateInputType = {
    escalationLevel?: true
  }

  export type DisputeSumAggregateInputType = {
    escalationLevel?: true
  }

  export type DisputeMinAggregateInputType = {
    escrowId?: true
    openedBy?: true
    reasonCode?: true
    summary?: true
    status?: true
    arbitratorAssigned?: true
    outcome?: true
    ref?: true
    escalationLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputeMaxAggregateInputType = {
    escrowId?: true
    openedBy?: true
    reasonCode?: true
    summary?: true
    status?: true
    arbitratorAssigned?: true
    outcome?: true
    ref?: true
    escalationLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputeCountAggregateInputType = {
    escrowId?: true
    openedBy?: true
    reasonCode?: true
    summary?: true
    status?: true
    arbitratorAssigned?: true
    outcome?: true
    ref?: true
    escalationLevel?: true
    aiAnalysis?: true
    tier2Analysis?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisputeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispute to aggregate.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Disputes
    **/
    _count?: true | DisputeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisputeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisputeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputeMaxAggregateInputType
  }

  export type GetDisputeAggregateType<T extends DisputeAggregateArgs> = {
        [P in keyof T & keyof AggregateDispute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispute[P]>
      : GetScalarType<T[P], AggregateDispute[P]>
  }




  export type DisputeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithAggregationInput | DisputeOrderByWithAggregationInput[]
    by: DisputeScalarFieldEnum[] | DisputeScalarFieldEnum
    having?: DisputeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputeCountAggregateInputType | true
    _avg?: DisputeAvgAggregateInputType
    _sum?: DisputeSumAggregateInputType
    _min?: DisputeMinAggregateInputType
    _max?: DisputeMaxAggregateInputType
  }

  export type DisputeGroupByOutputType = {
    escrowId: Buffer
    openedBy: string
    reasonCode: string | null
    summary: string | null
    status: string
    arbitratorAssigned: string | null
    outcome: string | null
    ref: Buffer | null
    escalationLevel: number
    aiAnalysis: JsonValue | null
    tier2Analysis: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DisputeCountAggregateOutputType | null
    _avg: DisputeAvgAggregateOutputType | null
    _sum: DisputeSumAggregateOutputType | null
    _min: DisputeMinAggregateOutputType | null
    _max: DisputeMaxAggregateOutputType | null
  }

  type GetDisputeGroupByPayload<T extends DisputeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputeGroupByOutputType[P]>
            : GetScalarType<T[P], DisputeGroupByOutputType[P]>
        }
      >
    >


  export type DisputeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    openedBy?: boolean
    reasonCode?: boolean
    summary?: boolean
    status?: boolean
    arbitratorAssigned?: boolean
    outcome?: boolean
    ref?: boolean
    escalationLevel?: boolean
    aiAnalysis?: boolean
    tier2Analysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    openedBy?: boolean
    reasonCode?: boolean
    summary?: boolean
    status?: boolean
    arbitratorAssigned?: boolean
    outcome?: boolean
    ref?: boolean
    escalationLevel?: boolean
    aiAnalysis?: boolean
    tier2Analysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectScalar = {
    escrowId?: boolean
    openedBy?: boolean
    reasonCode?: boolean
    summary?: boolean
    status?: boolean
    arbitratorAssigned?: boolean
    outcome?: boolean
    ref?: boolean
    escalationLevel?: boolean
    aiAnalysis?: boolean
    tier2Analysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DisputeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }
  export type DisputeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }

  export type $DisputePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dispute"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      escrowId: Buffer
      openedBy: string
      reasonCode: string | null
      summary: string | null
      status: string
      arbitratorAssigned: string | null
      outcome: string | null
      ref: Buffer | null
      escalationLevel: number
      aiAnalysis: Prisma.JsonValue | null
      tier2Analysis: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dispute"]>
    composites: {}
  }

  type DisputeGetPayload<S extends boolean | null | undefined | DisputeDefaultArgs> = $Result.GetResult<Prisma.$DisputePayload, S>

  type DisputeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DisputeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DisputeCountAggregateInputType | true
    }

  export interface DisputeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dispute'], meta: { name: 'Dispute' } }
    /**
     * Find zero or one Dispute that matches the filter.
     * @param {DisputeFindUniqueArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisputeFindUniqueArgs>(args: SelectSubset<T, DisputeFindUniqueArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dispute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DisputeFindUniqueOrThrowArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisputeFindUniqueOrThrowArgs>(args: SelectSubset<T, DisputeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dispute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindFirstArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisputeFindFirstArgs>(args?: SelectSubset<T, DisputeFindFirstArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dispute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindFirstOrThrowArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisputeFindFirstOrThrowArgs>(args?: SelectSubset<T, DisputeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Disputes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disputes
     * const disputes = await prisma.dispute.findMany()
     * 
     * // Get first 10 Disputes
     * const disputes = await prisma.dispute.findMany({ take: 10 })
     * 
     * // Only select the `escrowId`
     * const disputeWithEscrowIdOnly = await prisma.dispute.findMany({ select: { escrowId: true } })
     * 
     */
    findMany<T extends DisputeFindManyArgs>(args?: SelectSubset<T, DisputeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dispute.
     * @param {DisputeCreateArgs} args - Arguments to create a Dispute.
     * @example
     * // Create one Dispute
     * const Dispute = await prisma.dispute.create({
     *   data: {
     *     // ... data to create a Dispute
     *   }
     * })
     * 
     */
    create<T extends DisputeCreateArgs>(args: SelectSubset<T, DisputeCreateArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Disputes.
     * @param {DisputeCreateManyArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const dispute = await prisma.dispute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisputeCreateManyArgs>(args?: SelectSubset<T, DisputeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Disputes and returns the data saved in the database.
     * @param {DisputeCreateManyAndReturnArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const dispute = await prisma.dispute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Disputes and only return the `escrowId`
     * const disputeWithEscrowIdOnly = await prisma.dispute.createManyAndReturn({ 
     *   select: { escrowId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisputeCreateManyAndReturnArgs>(args?: SelectSubset<T, DisputeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dispute.
     * @param {DisputeDeleteArgs} args - Arguments to delete one Dispute.
     * @example
     * // Delete one Dispute
     * const Dispute = await prisma.dispute.delete({
     *   where: {
     *     // ... filter to delete one Dispute
     *   }
     * })
     * 
     */
    delete<T extends DisputeDeleteArgs>(args: SelectSubset<T, DisputeDeleteArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dispute.
     * @param {DisputeUpdateArgs} args - Arguments to update one Dispute.
     * @example
     * // Update one Dispute
     * const dispute = await prisma.dispute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisputeUpdateArgs>(args: SelectSubset<T, DisputeUpdateArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Disputes.
     * @param {DisputeDeleteManyArgs} args - Arguments to filter Disputes to delete.
     * @example
     * // Delete a few Disputes
     * const { count } = await prisma.dispute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisputeDeleteManyArgs>(args?: SelectSubset<T, DisputeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disputes
     * const dispute = await prisma.dispute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisputeUpdateManyArgs>(args: SelectSubset<T, DisputeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dispute.
     * @param {DisputeUpsertArgs} args - Arguments to update or create a Dispute.
     * @example
     * // Update or create a Dispute
     * const dispute = await prisma.dispute.upsert({
     *   create: {
     *     // ... data to create a Dispute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispute we want to update
     *   }
     * })
     */
    upsert<T extends DisputeUpsertArgs>(args: SelectSubset<T, DisputeUpsertArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeCountArgs} args - Arguments to filter Disputes to count.
     * @example
     * // Count the number of Disputes
     * const count = await prisma.dispute.count({
     *   where: {
     *     // ... the filter for the Disputes we want to count
     *   }
     * })
    **/
    count<T extends DisputeCountArgs>(
      args?: Subset<T, DisputeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputeAggregateArgs>(args: Subset<T, DisputeAggregateArgs>): Prisma.PrismaPromise<GetDisputeAggregateType<T>>

    /**
     * Group by Dispute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisputeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisputeGroupByArgs['orderBy'] }
        : { orderBy?: DisputeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisputeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dispute model
   */
  readonly fields: DisputeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dispute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisputeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscrowDefaultArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dispute model
   */ 
  interface DisputeFieldRefs {
    readonly escrowId: FieldRef<"Dispute", 'Bytes'>
    readonly openedBy: FieldRef<"Dispute", 'String'>
    readonly reasonCode: FieldRef<"Dispute", 'String'>
    readonly summary: FieldRef<"Dispute", 'String'>
    readonly status: FieldRef<"Dispute", 'String'>
    readonly arbitratorAssigned: FieldRef<"Dispute", 'String'>
    readonly outcome: FieldRef<"Dispute", 'String'>
    readonly ref: FieldRef<"Dispute", 'Bytes'>
    readonly escalationLevel: FieldRef<"Dispute", 'Int'>
    readonly aiAnalysis: FieldRef<"Dispute", 'Json'>
    readonly tier2Analysis: FieldRef<"Dispute", 'Json'>
    readonly createdAt: FieldRef<"Dispute", 'DateTime'>
    readonly updatedAt: FieldRef<"Dispute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dispute findUnique
   */
  export type DisputeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute findUniqueOrThrow
   */
  export type DisputeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute findFirst
   */
  export type DisputeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disputes.
     */
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute findFirstOrThrow
   */
  export type DisputeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disputes.
     */
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute findMany
   */
  export type DisputeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Disputes to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute create
   */
  export type DisputeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The data needed to create a Dispute.
     */
    data: XOR<DisputeCreateInput, DisputeUncheckedCreateInput>
  }

  /**
   * Dispute createMany
   */
  export type DisputeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Disputes.
     */
    data: DisputeCreateManyInput | DisputeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dispute createManyAndReturn
   */
  export type DisputeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Disputes.
     */
    data: DisputeCreateManyInput | DisputeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispute update
   */
  export type DisputeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The data needed to update a Dispute.
     */
    data: XOR<DisputeUpdateInput, DisputeUncheckedUpdateInput>
    /**
     * Choose, which Dispute to update.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute updateMany
   */
  export type DisputeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Disputes.
     */
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyInput>
    /**
     * Filter which Disputes to update
     */
    where?: DisputeWhereInput
  }

  /**
   * Dispute upsert
   */
  export type DisputeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The filter to search for the Dispute to update in case it exists.
     */
    where: DisputeWhereUniqueInput
    /**
     * In case the Dispute found by the `where` argument doesn't exist, create a new Dispute with this data.
     */
    create: XOR<DisputeCreateInput, DisputeUncheckedCreateInput>
    /**
     * In case the Dispute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisputeUpdateInput, DisputeUncheckedUpdateInput>
  }

  /**
   * Dispute delete
   */
  export type DisputeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter which Dispute to delete.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute deleteMany
   */
  export type DisputeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disputes to delete
     */
    where?: DisputeWhereInput
  }

  /**
   * Dispute without action
   */
  export type DisputeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
  }


  /**
   * Model IndexerCheckpoint
   */

  export type AggregateIndexerCheckpoint = {
    _count: IndexerCheckpointCountAggregateOutputType | null
    _avg: IndexerCheckpointAvgAggregateOutputType | null
    _sum: IndexerCheckpointSumAggregateOutputType | null
    _min: IndexerCheckpointMinAggregateOutputType | null
    _max: IndexerCheckpointMaxAggregateOutputType | null
  }

  export type IndexerCheckpointAvgAggregateOutputType = {
    chainId: number | null
    lastSyncedBlock: number | null
  }

  export type IndexerCheckpointSumAggregateOutputType = {
    chainId: number | null
    lastSyncedBlock: bigint | null
  }

  export type IndexerCheckpointMinAggregateOutputType = {
    chainId: number | null
    contractAddress: string | null
    lastSyncedBlock: bigint | null
    updatedAt: Date | null
  }

  export type IndexerCheckpointMaxAggregateOutputType = {
    chainId: number | null
    contractAddress: string | null
    lastSyncedBlock: bigint | null
    updatedAt: Date | null
  }

  export type IndexerCheckpointCountAggregateOutputType = {
    chainId: number
    contractAddress: number
    lastSyncedBlock: number
    updatedAt: number
    _all: number
  }


  export type IndexerCheckpointAvgAggregateInputType = {
    chainId?: true
    lastSyncedBlock?: true
  }

  export type IndexerCheckpointSumAggregateInputType = {
    chainId?: true
    lastSyncedBlock?: true
  }

  export type IndexerCheckpointMinAggregateInputType = {
    chainId?: true
    contractAddress?: true
    lastSyncedBlock?: true
    updatedAt?: true
  }

  export type IndexerCheckpointMaxAggregateInputType = {
    chainId?: true
    contractAddress?: true
    lastSyncedBlock?: true
    updatedAt?: true
  }

  export type IndexerCheckpointCountAggregateInputType = {
    chainId?: true
    contractAddress?: true
    lastSyncedBlock?: true
    updatedAt?: true
    _all?: true
  }

  export type IndexerCheckpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndexerCheckpoint to aggregate.
     */
    where?: IndexerCheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndexerCheckpoints to fetch.
     */
    orderBy?: IndexerCheckpointOrderByWithRelationInput | IndexerCheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndexerCheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndexerCheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndexerCheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndexerCheckpoints
    **/
    _count?: true | IndexerCheckpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndexerCheckpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndexerCheckpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndexerCheckpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndexerCheckpointMaxAggregateInputType
  }

  export type GetIndexerCheckpointAggregateType<T extends IndexerCheckpointAggregateArgs> = {
        [P in keyof T & keyof AggregateIndexerCheckpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndexerCheckpoint[P]>
      : GetScalarType<T[P], AggregateIndexerCheckpoint[P]>
  }




  export type IndexerCheckpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndexerCheckpointWhereInput
    orderBy?: IndexerCheckpointOrderByWithAggregationInput | IndexerCheckpointOrderByWithAggregationInput[]
    by: IndexerCheckpointScalarFieldEnum[] | IndexerCheckpointScalarFieldEnum
    having?: IndexerCheckpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndexerCheckpointCountAggregateInputType | true
    _avg?: IndexerCheckpointAvgAggregateInputType
    _sum?: IndexerCheckpointSumAggregateInputType
    _min?: IndexerCheckpointMinAggregateInputType
    _max?: IndexerCheckpointMaxAggregateInputType
  }

  export type IndexerCheckpointGroupByOutputType = {
    chainId: number
    contractAddress: string
    lastSyncedBlock: bigint
    updatedAt: Date
    _count: IndexerCheckpointCountAggregateOutputType | null
    _avg: IndexerCheckpointAvgAggregateOutputType | null
    _sum: IndexerCheckpointSumAggregateOutputType | null
    _min: IndexerCheckpointMinAggregateOutputType | null
    _max: IndexerCheckpointMaxAggregateOutputType | null
  }

  type GetIndexerCheckpointGroupByPayload<T extends IndexerCheckpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndexerCheckpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndexerCheckpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndexerCheckpointGroupByOutputType[P]>
            : GetScalarType<T[P], IndexerCheckpointGroupByOutputType[P]>
        }
      >
    >


  export type IndexerCheckpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chainId?: boolean
    contractAddress?: boolean
    lastSyncedBlock?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["indexerCheckpoint"]>

  export type IndexerCheckpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chainId?: boolean
    contractAddress?: boolean
    lastSyncedBlock?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["indexerCheckpoint"]>

  export type IndexerCheckpointSelectScalar = {
    chainId?: boolean
    contractAddress?: boolean
    lastSyncedBlock?: boolean
    updatedAt?: boolean
  }


  export type $IndexerCheckpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndexerCheckpoint"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      chainId: number
      contractAddress: string
      lastSyncedBlock: bigint
      updatedAt: Date
    }, ExtArgs["result"]["indexerCheckpoint"]>
    composites: {}
  }

  type IndexerCheckpointGetPayload<S extends boolean | null | undefined | IndexerCheckpointDefaultArgs> = $Result.GetResult<Prisma.$IndexerCheckpointPayload, S>

  type IndexerCheckpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndexerCheckpointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndexerCheckpointCountAggregateInputType | true
    }

  export interface IndexerCheckpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndexerCheckpoint'], meta: { name: 'IndexerCheckpoint' } }
    /**
     * Find zero or one IndexerCheckpoint that matches the filter.
     * @param {IndexerCheckpointFindUniqueArgs} args - Arguments to find a IndexerCheckpoint
     * @example
     * // Get one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndexerCheckpointFindUniqueArgs>(args: SelectSubset<T, IndexerCheckpointFindUniqueArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IndexerCheckpoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndexerCheckpointFindUniqueOrThrowArgs} args - Arguments to find a IndexerCheckpoint
     * @example
     * // Get one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndexerCheckpointFindUniqueOrThrowArgs>(args: SelectSubset<T, IndexerCheckpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IndexerCheckpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointFindFirstArgs} args - Arguments to find a IndexerCheckpoint
     * @example
     * // Get one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndexerCheckpointFindFirstArgs>(args?: SelectSubset<T, IndexerCheckpointFindFirstArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IndexerCheckpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointFindFirstOrThrowArgs} args - Arguments to find a IndexerCheckpoint
     * @example
     * // Get one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndexerCheckpointFindFirstOrThrowArgs>(args?: SelectSubset<T, IndexerCheckpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IndexerCheckpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndexerCheckpoints
     * const indexerCheckpoints = await prisma.indexerCheckpoint.findMany()
     * 
     * // Get first 10 IndexerCheckpoints
     * const indexerCheckpoints = await prisma.indexerCheckpoint.findMany({ take: 10 })
     * 
     * // Only select the `chainId`
     * const indexerCheckpointWithChainIdOnly = await prisma.indexerCheckpoint.findMany({ select: { chainId: true } })
     * 
     */
    findMany<T extends IndexerCheckpointFindManyArgs>(args?: SelectSubset<T, IndexerCheckpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IndexerCheckpoint.
     * @param {IndexerCheckpointCreateArgs} args - Arguments to create a IndexerCheckpoint.
     * @example
     * // Create one IndexerCheckpoint
     * const IndexerCheckpoint = await prisma.indexerCheckpoint.create({
     *   data: {
     *     // ... data to create a IndexerCheckpoint
     *   }
     * })
     * 
     */
    create<T extends IndexerCheckpointCreateArgs>(args: SelectSubset<T, IndexerCheckpointCreateArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IndexerCheckpoints.
     * @param {IndexerCheckpointCreateManyArgs} args - Arguments to create many IndexerCheckpoints.
     * @example
     * // Create many IndexerCheckpoints
     * const indexerCheckpoint = await prisma.indexerCheckpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndexerCheckpointCreateManyArgs>(args?: SelectSubset<T, IndexerCheckpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndexerCheckpoints and returns the data saved in the database.
     * @param {IndexerCheckpointCreateManyAndReturnArgs} args - Arguments to create many IndexerCheckpoints.
     * @example
     * // Create many IndexerCheckpoints
     * const indexerCheckpoint = await prisma.indexerCheckpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndexerCheckpoints and only return the `chainId`
     * const indexerCheckpointWithChainIdOnly = await prisma.indexerCheckpoint.createManyAndReturn({ 
     *   select: { chainId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndexerCheckpointCreateManyAndReturnArgs>(args?: SelectSubset<T, IndexerCheckpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IndexerCheckpoint.
     * @param {IndexerCheckpointDeleteArgs} args - Arguments to delete one IndexerCheckpoint.
     * @example
     * // Delete one IndexerCheckpoint
     * const IndexerCheckpoint = await prisma.indexerCheckpoint.delete({
     *   where: {
     *     // ... filter to delete one IndexerCheckpoint
     *   }
     * })
     * 
     */
    delete<T extends IndexerCheckpointDeleteArgs>(args: SelectSubset<T, IndexerCheckpointDeleteArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IndexerCheckpoint.
     * @param {IndexerCheckpointUpdateArgs} args - Arguments to update one IndexerCheckpoint.
     * @example
     * // Update one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndexerCheckpointUpdateArgs>(args: SelectSubset<T, IndexerCheckpointUpdateArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IndexerCheckpoints.
     * @param {IndexerCheckpointDeleteManyArgs} args - Arguments to filter IndexerCheckpoints to delete.
     * @example
     * // Delete a few IndexerCheckpoints
     * const { count } = await prisma.indexerCheckpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndexerCheckpointDeleteManyArgs>(args?: SelectSubset<T, IndexerCheckpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndexerCheckpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndexerCheckpoints
     * const indexerCheckpoint = await prisma.indexerCheckpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndexerCheckpointUpdateManyArgs>(args: SelectSubset<T, IndexerCheckpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndexerCheckpoint.
     * @param {IndexerCheckpointUpsertArgs} args - Arguments to update or create a IndexerCheckpoint.
     * @example
     * // Update or create a IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.upsert({
     *   create: {
     *     // ... data to create a IndexerCheckpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndexerCheckpoint we want to update
     *   }
     * })
     */
    upsert<T extends IndexerCheckpointUpsertArgs>(args: SelectSubset<T, IndexerCheckpointUpsertArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IndexerCheckpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointCountArgs} args - Arguments to filter IndexerCheckpoints to count.
     * @example
     * // Count the number of IndexerCheckpoints
     * const count = await prisma.indexerCheckpoint.count({
     *   where: {
     *     // ... the filter for the IndexerCheckpoints we want to count
     *   }
     * })
    **/
    count<T extends IndexerCheckpointCountArgs>(
      args?: Subset<T, IndexerCheckpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndexerCheckpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndexerCheckpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndexerCheckpointAggregateArgs>(args: Subset<T, IndexerCheckpointAggregateArgs>): Prisma.PrismaPromise<GetIndexerCheckpointAggregateType<T>>

    /**
     * Group by IndexerCheckpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndexerCheckpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndexerCheckpointGroupByArgs['orderBy'] }
        : { orderBy?: IndexerCheckpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndexerCheckpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndexerCheckpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndexerCheckpoint model
   */
  readonly fields: IndexerCheckpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndexerCheckpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndexerCheckpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndexerCheckpoint model
   */ 
  interface IndexerCheckpointFieldRefs {
    readonly chainId: FieldRef<"IndexerCheckpoint", 'Int'>
    readonly contractAddress: FieldRef<"IndexerCheckpoint", 'String'>
    readonly lastSyncedBlock: FieldRef<"IndexerCheckpoint", 'BigInt'>
    readonly updatedAt: FieldRef<"IndexerCheckpoint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndexerCheckpoint findUnique
   */
  export type IndexerCheckpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoint to fetch.
     */
    where: IndexerCheckpointWhereUniqueInput
  }

  /**
   * IndexerCheckpoint findUniqueOrThrow
   */
  export type IndexerCheckpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoint to fetch.
     */
    where: IndexerCheckpointWhereUniqueInput
  }

  /**
   * IndexerCheckpoint findFirst
   */
  export type IndexerCheckpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoint to fetch.
     */
    where?: IndexerCheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndexerCheckpoints to fetch.
     */
    orderBy?: IndexerCheckpointOrderByWithRelationInput | IndexerCheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndexerCheckpoints.
     */
    cursor?: IndexerCheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndexerCheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndexerCheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndexerCheckpoints.
     */
    distinct?: IndexerCheckpointScalarFieldEnum | IndexerCheckpointScalarFieldEnum[]
  }

  /**
   * IndexerCheckpoint findFirstOrThrow
   */
  export type IndexerCheckpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoint to fetch.
     */
    where?: IndexerCheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndexerCheckpoints to fetch.
     */
    orderBy?: IndexerCheckpointOrderByWithRelationInput | IndexerCheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndexerCheckpoints.
     */
    cursor?: IndexerCheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndexerCheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndexerCheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndexerCheckpoints.
     */
    distinct?: IndexerCheckpointScalarFieldEnum | IndexerCheckpointScalarFieldEnum[]
  }

  /**
   * IndexerCheckpoint findMany
   */
  export type IndexerCheckpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoints to fetch.
     */
    where?: IndexerCheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndexerCheckpoints to fetch.
     */
    orderBy?: IndexerCheckpointOrderByWithRelationInput | IndexerCheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndexerCheckpoints.
     */
    cursor?: IndexerCheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndexerCheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndexerCheckpoints.
     */
    skip?: number
    distinct?: IndexerCheckpointScalarFieldEnum | IndexerCheckpointScalarFieldEnum[]
  }

  /**
   * IndexerCheckpoint create
   */
  export type IndexerCheckpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * The data needed to create a IndexerCheckpoint.
     */
    data: XOR<IndexerCheckpointCreateInput, IndexerCheckpointUncheckedCreateInput>
  }

  /**
   * IndexerCheckpoint createMany
   */
  export type IndexerCheckpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndexerCheckpoints.
     */
    data: IndexerCheckpointCreateManyInput | IndexerCheckpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndexerCheckpoint createManyAndReturn
   */
  export type IndexerCheckpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IndexerCheckpoints.
     */
    data: IndexerCheckpointCreateManyInput | IndexerCheckpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndexerCheckpoint update
   */
  export type IndexerCheckpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * The data needed to update a IndexerCheckpoint.
     */
    data: XOR<IndexerCheckpointUpdateInput, IndexerCheckpointUncheckedUpdateInput>
    /**
     * Choose, which IndexerCheckpoint to update.
     */
    where: IndexerCheckpointWhereUniqueInput
  }

  /**
   * IndexerCheckpoint updateMany
   */
  export type IndexerCheckpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndexerCheckpoints.
     */
    data: XOR<IndexerCheckpointUpdateManyMutationInput, IndexerCheckpointUncheckedUpdateManyInput>
    /**
     * Filter which IndexerCheckpoints to update
     */
    where?: IndexerCheckpointWhereInput
  }

  /**
   * IndexerCheckpoint upsert
   */
  export type IndexerCheckpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * The filter to search for the IndexerCheckpoint to update in case it exists.
     */
    where: IndexerCheckpointWhereUniqueInput
    /**
     * In case the IndexerCheckpoint found by the `where` argument doesn't exist, create a new IndexerCheckpoint with this data.
     */
    create: XOR<IndexerCheckpointCreateInput, IndexerCheckpointUncheckedCreateInput>
    /**
     * In case the IndexerCheckpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndexerCheckpointUpdateInput, IndexerCheckpointUncheckedUpdateInput>
  }

  /**
   * IndexerCheckpoint delete
   */
  export type IndexerCheckpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter which IndexerCheckpoint to delete.
     */
    where: IndexerCheckpointWhereUniqueInput
  }

  /**
   * IndexerCheckpoint deleteMany
   */
  export type IndexerCheckpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndexerCheckpoints to delete
     */
    where?: IndexerCheckpointWhereInput
  }

  /**
   * IndexerCheckpoint without action
   */
  export type IndexerCheckpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
  }


  /**
   * Model TokenRegistry
   */

  export type AggregateTokenRegistry = {
    _count: TokenRegistryCountAggregateOutputType | null
    _avg: TokenRegistryAvgAggregateOutputType | null
    _sum: TokenRegistrySumAggregateOutputType | null
    _min: TokenRegistryMinAggregateOutputType | null
    _max: TokenRegistryMaxAggregateOutputType | null
  }

  export type TokenRegistryAvgAggregateOutputType = {
    chainId: number | null
    decimals: number | null
  }

  export type TokenRegistrySumAggregateOutputType = {
    chainId: number | null
    decimals: number | null
  }

  export type TokenRegistryMinAggregateOutputType = {
    chainId: number | null
    tokenKey: string | null
    symbol: string | null
    decimals: number | null
    name: string | null
    enabled: boolean | null
  }

  export type TokenRegistryMaxAggregateOutputType = {
    chainId: number | null
    tokenKey: string | null
    symbol: string | null
    decimals: number | null
    name: string | null
    enabled: boolean | null
  }

  export type TokenRegistryCountAggregateOutputType = {
    chainId: number
    tokenKey: number
    symbol: number
    decimals: number
    name: number
    enabled: number
    _all: number
  }


  export type TokenRegistryAvgAggregateInputType = {
    chainId?: true
    decimals?: true
  }

  export type TokenRegistrySumAggregateInputType = {
    chainId?: true
    decimals?: true
  }

  export type TokenRegistryMinAggregateInputType = {
    chainId?: true
    tokenKey?: true
    symbol?: true
    decimals?: true
    name?: true
    enabled?: true
  }

  export type TokenRegistryMaxAggregateInputType = {
    chainId?: true
    tokenKey?: true
    symbol?: true
    decimals?: true
    name?: true
    enabled?: true
  }

  export type TokenRegistryCountAggregateInputType = {
    chainId?: true
    tokenKey?: true
    symbol?: true
    decimals?: true
    name?: true
    enabled?: true
    _all?: true
  }

  export type TokenRegistryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenRegistry to aggregate.
     */
    where?: TokenRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRegistries to fetch.
     */
    orderBy?: TokenRegistryOrderByWithRelationInput | TokenRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenRegistries
    **/
    _count?: true | TokenRegistryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenRegistryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenRegistrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenRegistryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenRegistryMaxAggregateInputType
  }

  export type GetTokenRegistryAggregateType<T extends TokenRegistryAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenRegistry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenRegistry[P]>
      : GetScalarType<T[P], AggregateTokenRegistry[P]>
  }




  export type TokenRegistryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenRegistryWhereInput
    orderBy?: TokenRegistryOrderByWithAggregationInput | TokenRegistryOrderByWithAggregationInput[]
    by: TokenRegistryScalarFieldEnum[] | TokenRegistryScalarFieldEnum
    having?: TokenRegistryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenRegistryCountAggregateInputType | true
    _avg?: TokenRegistryAvgAggregateInputType
    _sum?: TokenRegistrySumAggregateInputType
    _min?: TokenRegistryMinAggregateInputType
    _max?: TokenRegistryMaxAggregateInputType
  }

  export type TokenRegistryGroupByOutputType = {
    chainId: number
    tokenKey: string
    symbol: string
    decimals: number
    name: string
    enabled: boolean
    _count: TokenRegistryCountAggregateOutputType | null
    _avg: TokenRegistryAvgAggregateOutputType | null
    _sum: TokenRegistrySumAggregateOutputType | null
    _min: TokenRegistryMinAggregateOutputType | null
    _max: TokenRegistryMaxAggregateOutputType | null
  }

  type GetTokenRegistryGroupByPayload<T extends TokenRegistryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenRegistryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenRegistryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenRegistryGroupByOutputType[P]>
            : GetScalarType<T[P], TokenRegistryGroupByOutputType[P]>
        }
      >
    >


  export type TokenRegistrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chainId?: boolean
    tokenKey?: boolean
    symbol?: boolean
    decimals?: boolean
    name?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["tokenRegistry"]>

  export type TokenRegistrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chainId?: boolean
    tokenKey?: boolean
    symbol?: boolean
    decimals?: boolean
    name?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["tokenRegistry"]>

  export type TokenRegistrySelectScalar = {
    chainId?: boolean
    tokenKey?: boolean
    symbol?: boolean
    decimals?: boolean
    name?: boolean
    enabled?: boolean
  }


  export type $TokenRegistryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenRegistry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      chainId: number
      tokenKey: string
      symbol: string
      decimals: number
      name: string
      enabled: boolean
    }, ExtArgs["result"]["tokenRegistry"]>
    composites: {}
  }

  type TokenRegistryGetPayload<S extends boolean | null | undefined | TokenRegistryDefaultArgs> = $Result.GetResult<Prisma.$TokenRegistryPayload, S>

  type TokenRegistryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenRegistryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenRegistryCountAggregateInputType | true
    }

  export interface TokenRegistryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenRegistry'], meta: { name: 'TokenRegistry' } }
    /**
     * Find zero or one TokenRegistry that matches the filter.
     * @param {TokenRegistryFindUniqueArgs} args - Arguments to find a TokenRegistry
     * @example
     * // Get one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenRegistryFindUniqueArgs>(args: SelectSubset<T, TokenRegistryFindUniqueArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TokenRegistry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenRegistryFindUniqueOrThrowArgs} args - Arguments to find a TokenRegistry
     * @example
     * // Get one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenRegistryFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenRegistryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TokenRegistry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryFindFirstArgs} args - Arguments to find a TokenRegistry
     * @example
     * // Get one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenRegistryFindFirstArgs>(args?: SelectSubset<T, TokenRegistryFindFirstArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TokenRegistry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryFindFirstOrThrowArgs} args - Arguments to find a TokenRegistry
     * @example
     * // Get one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenRegistryFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenRegistryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TokenRegistries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenRegistries
     * const tokenRegistries = await prisma.tokenRegistry.findMany()
     * 
     * // Get first 10 TokenRegistries
     * const tokenRegistries = await prisma.tokenRegistry.findMany({ take: 10 })
     * 
     * // Only select the `chainId`
     * const tokenRegistryWithChainIdOnly = await prisma.tokenRegistry.findMany({ select: { chainId: true } })
     * 
     */
    findMany<T extends TokenRegistryFindManyArgs>(args?: SelectSubset<T, TokenRegistryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TokenRegistry.
     * @param {TokenRegistryCreateArgs} args - Arguments to create a TokenRegistry.
     * @example
     * // Create one TokenRegistry
     * const TokenRegistry = await prisma.tokenRegistry.create({
     *   data: {
     *     // ... data to create a TokenRegistry
     *   }
     * })
     * 
     */
    create<T extends TokenRegistryCreateArgs>(args: SelectSubset<T, TokenRegistryCreateArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TokenRegistries.
     * @param {TokenRegistryCreateManyArgs} args - Arguments to create many TokenRegistries.
     * @example
     * // Create many TokenRegistries
     * const tokenRegistry = await prisma.tokenRegistry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenRegistryCreateManyArgs>(args?: SelectSubset<T, TokenRegistryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenRegistries and returns the data saved in the database.
     * @param {TokenRegistryCreateManyAndReturnArgs} args - Arguments to create many TokenRegistries.
     * @example
     * // Create many TokenRegistries
     * const tokenRegistry = await prisma.tokenRegistry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenRegistries and only return the `chainId`
     * const tokenRegistryWithChainIdOnly = await prisma.tokenRegistry.createManyAndReturn({ 
     *   select: { chainId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenRegistryCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenRegistryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TokenRegistry.
     * @param {TokenRegistryDeleteArgs} args - Arguments to delete one TokenRegistry.
     * @example
     * // Delete one TokenRegistry
     * const TokenRegistry = await prisma.tokenRegistry.delete({
     *   where: {
     *     // ... filter to delete one TokenRegistry
     *   }
     * })
     * 
     */
    delete<T extends TokenRegistryDeleteArgs>(args: SelectSubset<T, TokenRegistryDeleteArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TokenRegistry.
     * @param {TokenRegistryUpdateArgs} args - Arguments to update one TokenRegistry.
     * @example
     * // Update one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenRegistryUpdateArgs>(args: SelectSubset<T, TokenRegistryUpdateArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TokenRegistries.
     * @param {TokenRegistryDeleteManyArgs} args - Arguments to filter TokenRegistries to delete.
     * @example
     * // Delete a few TokenRegistries
     * const { count } = await prisma.tokenRegistry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenRegistryDeleteManyArgs>(args?: SelectSubset<T, TokenRegistryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenRegistries
     * const tokenRegistry = await prisma.tokenRegistry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenRegistryUpdateManyArgs>(args: SelectSubset<T, TokenRegistryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenRegistry.
     * @param {TokenRegistryUpsertArgs} args - Arguments to update or create a TokenRegistry.
     * @example
     * // Update or create a TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.upsert({
     *   create: {
     *     // ... data to create a TokenRegistry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenRegistry we want to update
     *   }
     * })
     */
    upsert<T extends TokenRegistryUpsertArgs>(args: SelectSubset<T, TokenRegistryUpsertArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TokenRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryCountArgs} args - Arguments to filter TokenRegistries to count.
     * @example
     * // Count the number of TokenRegistries
     * const count = await prisma.tokenRegistry.count({
     *   where: {
     *     // ... the filter for the TokenRegistries we want to count
     *   }
     * })
    **/
    count<T extends TokenRegistryCountArgs>(
      args?: Subset<T, TokenRegistryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenRegistryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenRegistryAggregateArgs>(args: Subset<T, TokenRegistryAggregateArgs>): Prisma.PrismaPromise<GetTokenRegistryAggregateType<T>>

    /**
     * Group by TokenRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenRegistryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenRegistryGroupByArgs['orderBy'] }
        : { orderBy?: TokenRegistryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenRegistryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenRegistryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenRegistry model
   */
  readonly fields: TokenRegistryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenRegistry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenRegistryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenRegistry model
   */ 
  interface TokenRegistryFieldRefs {
    readonly chainId: FieldRef<"TokenRegistry", 'Int'>
    readonly tokenKey: FieldRef<"TokenRegistry", 'String'>
    readonly symbol: FieldRef<"TokenRegistry", 'String'>
    readonly decimals: FieldRef<"TokenRegistry", 'Int'>
    readonly name: FieldRef<"TokenRegistry", 'String'>
    readonly enabled: FieldRef<"TokenRegistry", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TokenRegistry findUnique
   */
  export type TokenRegistryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistry to fetch.
     */
    where: TokenRegistryWhereUniqueInput
  }

  /**
   * TokenRegistry findUniqueOrThrow
   */
  export type TokenRegistryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistry to fetch.
     */
    where: TokenRegistryWhereUniqueInput
  }

  /**
   * TokenRegistry findFirst
   */
  export type TokenRegistryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistry to fetch.
     */
    where?: TokenRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRegistries to fetch.
     */
    orderBy?: TokenRegistryOrderByWithRelationInput | TokenRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenRegistries.
     */
    cursor?: TokenRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenRegistries.
     */
    distinct?: TokenRegistryScalarFieldEnum | TokenRegistryScalarFieldEnum[]
  }

  /**
   * TokenRegistry findFirstOrThrow
   */
  export type TokenRegistryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistry to fetch.
     */
    where?: TokenRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRegistries to fetch.
     */
    orderBy?: TokenRegistryOrderByWithRelationInput | TokenRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenRegistries.
     */
    cursor?: TokenRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenRegistries.
     */
    distinct?: TokenRegistryScalarFieldEnum | TokenRegistryScalarFieldEnum[]
  }

  /**
   * TokenRegistry findMany
   */
  export type TokenRegistryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistries to fetch.
     */
    where?: TokenRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRegistries to fetch.
     */
    orderBy?: TokenRegistryOrderByWithRelationInput | TokenRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenRegistries.
     */
    cursor?: TokenRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRegistries.
     */
    skip?: number
    distinct?: TokenRegistryScalarFieldEnum | TokenRegistryScalarFieldEnum[]
  }

  /**
   * TokenRegistry create
   */
  export type TokenRegistryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * The data needed to create a TokenRegistry.
     */
    data: XOR<TokenRegistryCreateInput, TokenRegistryUncheckedCreateInput>
  }

  /**
   * TokenRegistry createMany
   */
  export type TokenRegistryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenRegistries.
     */
    data: TokenRegistryCreateManyInput | TokenRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenRegistry createManyAndReturn
   */
  export type TokenRegistryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TokenRegistries.
     */
    data: TokenRegistryCreateManyInput | TokenRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenRegistry update
   */
  export type TokenRegistryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * The data needed to update a TokenRegistry.
     */
    data: XOR<TokenRegistryUpdateInput, TokenRegistryUncheckedUpdateInput>
    /**
     * Choose, which TokenRegistry to update.
     */
    where: TokenRegistryWhereUniqueInput
  }

  /**
   * TokenRegistry updateMany
   */
  export type TokenRegistryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenRegistries.
     */
    data: XOR<TokenRegistryUpdateManyMutationInput, TokenRegistryUncheckedUpdateManyInput>
    /**
     * Filter which TokenRegistries to update
     */
    where?: TokenRegistryWhereInput
  }

  /**
   * TokenRegistry upsert
   */
  export type TokenRegistryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * The filter to search for the TokenRegistry to update in case it exists.
     */
    where: TokenRegistryWhereUniqueInput
    /**
     * In case the TokenRegistry found by the `where` argument doesn't exist, create a new TokenRegistry with this data.
     */
    create: XOR<TokenRegistryCreateInput, TokenRegistryUncheckedCreateInput>
    /**
     * In case the TokenRegistry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenRegistryUpdateInput, TokenRegistryUncheckedUpdateInput>
  }

  /**
   * TokenRegistry delete
   */
  export type TokenRegistryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter which TokenRegistry to delete.
     */
    where: TokenRegistryWhereUniqueInput
  }

  /**
   * TokenRegistry deleteMany
   */
  export type TokenRegistryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenRegistries to delete
     */
    where?: TokenRegistryWhereInput
  }

  /**
   * TokenRegistry without action
   */
  export type TokenRegistryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorAddress: string | null
    action: string | null
    target: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorAddress: string | null
    action: string | null
    target: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorAddress: number
    action: number
    target: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorAddress?: true
    action?: true
    target?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorAddress?: true
    action?: true
    target?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorAddress?: true
    action?: true
    target?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorAddress: string | null
    action: string
    target: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorAddress?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorAddress?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorAddress?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorAddress: string | null
      action: string
      target: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorAddress: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly target: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model Nonce
   */

  export type AggregateNonce = {
    _count: NonceCountAggregateOutputType | null
    _avg: NonceAvgAggregateOutputType | null
    _sum: NonceSumAggregateOutputType | null
    _min: NonceMinAggregateOutputType | null
    _max: NonceMaxAggregateOutputType | null
  }

  export type NonceAvgAggregateOutputType = {
    chainId: number | null
  }

  export type NonceSumAggregateOutputType = {
    chainId: number | null
  }

  export type NonceMinAggregateOutputType = {
    id: string | null
    address: string | null
    value: string | null
    chainId: number | null
    domain: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type NonceMaxAggregateOutputType = {
    id: string | null
    address: string | null
    value: string | null
    chainId: number | null
    domain: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type NonceCountAggregateOutputType = {
    id: number
    address: number
    value: number
    chainId: number
    domain: number
    issuedAt: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type NonceAvgAggregateInputType = {
    chainId?: true
  }

  export type NonceSumAggregateInputType = {
    chainId?: true
  }

  export type NonceMinAggregateInputType = {
    id?: true
    address?: true
    value?: true
    chainId?: true
    domain?: true
    issuedAt?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type NonceMaxAggregateInputType = {
    id?: true
    address?: true
    value?: true
    chainId?: true
    domain?: true
    issuedAt?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type NonceCountAggregateInputType = {
    id?: true
    address?: true
    value?: true
    chainId?: true
    domain?: true
    issuedAt?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type NonceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nonce to aggregate.
     */
    where?: NonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nonces to fetch.
     */
    orderBy?: NonceOrderByWithRelationInput | NonceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nonces
    **/
    _count?: true | NonceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NonceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NonceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NonceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NonceMaxAggregateInputType
  }

  export type GetNonceAggregateType<T extends NonceAggregateArgs> = {
        [P in keyof T & keyof AggregateNonce]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNonce[P]>
      : GetScalarType<T[P], AggregateNonce[P]>
  }




  export type NonceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonceWhereInput
    orderBy?: NonceOrderByWithAggregationInput | NonceOrderByWithAggregationInput[]
    by: NonceScalarFieldEnum[] | NonceScalarFieldEnum
    having?: NonceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NonceCountAggregateInputType | true
    _avg?: NonceAvgAggregateInputType
    _sum?: NonceSumAggregateInputType
    _min?: NonceMinAggregateInputType
    _max?: NonceMaxAggregateInputType
  }

  export type NonceGroupByOutputType = {
    id: string
    address: string
    value: string
    chainId: number
    domain: string | null
    issuedAt: Date
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: NonceCountAggregateOutputType | null
    _avg: NonceAvgAggregateOutputType | null
    _sum: NonceSumAggregateOutputType | null
    _min: NonceMinAggregateOutputType | null
    _max: NonceMaxAggregateOutputType | null
  }

  type GetNonceGroupByPayload<T extends NonceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NonceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NonceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NonceGroupByOutputType[P]>
            : GetScalarType<T[P], NonceGroupByOutputType[P]>
        }
      >
    >


  export type NonceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    value?: boolean
    chainId?: boolean
    domain?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nonce"]>

  export type NonceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    value?: boolean
    chainId?: boolean
    domain?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nonce"]>

  export type NonceSelectScalar = {
    id?: boolean
    address?: boolean
    value?: boolean
    chainId?: boolean
    domain?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }


  export type $NoncePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nonce"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      /**
       * hashed nonce value
       */
      value: string
      chainId: number
      domain: string | null
      issuedAt: Date
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["nonce"]>
    composites: {}
  }

  type NonceGetPayload<S extends boolean | null | undefined | NonceDefaultArgs> = $Result.GetResult<Prisma.$NoncePayload, S>

  type NonceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NonceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NonceCountAggregateInputType | true
    }

  export interface NonceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nonce'], meta: { name: 'Nonce' } }
    /**
     * Find zero or one Nonce that matches the filter.
     * @param {NonceFindUniqueArgs} args - Arguments to find a Nonce
     * @example
     * // Get one Nonce
     * const nonce = await prisma.nonce.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NonceFindUniqueArgs>(args: SelectSubset<T, NonceFindUniqueArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Nonce that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NonceFindUniqueOrThrowArgs} args - Arguments to find a Nonce
     * @example
     * // Get one Nonce
     * const nonce = await prisma.nonce.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NonceFindUniqueOrThrowArgs>(args: SelectSubset<T, NonceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Nonce that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceFindFirstArgs} args - Arguments to find a Nonce
     * @example
     * // Get one Nonce
     * const nonce = await prisma.nonce.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NonceFindFirstArgs>(args?: SelectSubset<T, NonceFindFirstArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Nonce that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceFindFirstOrThrowArgs} args - Arguments to find a Nonce
     * @example
     * // Get one Nonce
     * const nonce = await prisma.nonce.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NonceFindFirstOrThrowArgs>(args?: SelectSubset<T, NonceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Nonces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nonces
     * const nonces = await prisma.nonce.findMany()
     * 
     * // Get first 10 Nonces
     * const nonces = await prisma.nonce.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nonceWithIdOnly = await prisma.nonce.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NonceFindManyArgs>(args?: SelectSubset<T, NonceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Nonce.
     * @param {NonceCreateArgs} args - Arguments to create a Nonce.
     * @example
     * // Create one Nonce
     * const Nonce = await prisma.nonce.create({
     *   data: {
     *     // ... data to create a Nonce
     *   }
     * })
     * 
     */
    create<T extends NonceCreateArgs>(args: SelectSubset<T, NonceCreateArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Nonces.
     * @param {NonceCreateManyArgs} args - Arguments to create many Nonces.
     * @example
     * // Create many Nonces
     * const nonce = await prisma.nonce.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NonceCreateManyArgs>(args?: SelectSubset<T, NonceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nonces and returns the data saved in the database.
     * @param {NonceCreateManyAndReturnArgs} args - Arguments to create many Nonces.
     * @example
     * // Create many Nonces
     * const nonce = await prisma.nonce.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nonces and only return the `id`
     * const nonceWithIdOnly = await prisma.nonce.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NonceCreateManyAndReturnArgs>(args?: SelectSubset<T, NonceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Nonce.
     * @param {NonceDeleteArgs} args - Arguments to delete one Nonce.
     * @example
     * // Delete one Nonce
     * const Nonce = await prisma.nonce.delete({
     *   where: {
     *     // ... filter to delete one Nonce
     *   }
     * })
     * 
     */
    delete<T extends NonceDeleteArgs>(args: SelectSubset<T, NonceDeleteArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Nonce.
     * @param {NonceUpdateArgs} args - Arguments to update one Nonce.
     * @example
     * // Update one Nonce
     * const nonce = await prisma.nonce.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NonceUpdateArgs>(args: SelectSubset<T, NonceUpdateArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Nonces.
     * @param {NonceDeleteManyArgs} args - Arguments to filter Nonces to delete.
     * @example
     * // Delete a few Nonces
     * const { count } = await prisma.nonce.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NonceDeleteManyArgs>(args?: SelectSubset<T, NonceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nonces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nonces
     * const nonce = await prisma.nonce.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NonceUpdateManyArgs>(args: SelectSubset<T, NonceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Nonce.
     * @param {NonceUpsertArgs} args - Arguments to update or create a Nonce.
     * @example
     * // Update or create a Nonce
     * const nonce = await prisma.nonce.upsert({
     *   create: {
     *     // ... data to create a Nonce
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nonce we want to update
     *   }
     * })
     */
    upsert<T extends NonceUpsertArgs>(args: SelectSubset<T, NonceUpsertArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Nonces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceCountArgs} args - Arguments to filter Nonces to count.
     * @example
     * // Count the number of Nonces
     * const count = await prisma.nonce.count({
     *   where: {
     *     // ... the filter for the Nonces we want to count
     *   }
     * })
    **/
    count<T extends NonceCountArgs>(
      args?: Subset<T, NonceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NonceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nonce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NonceAggregateArgs>(args: Subset<T, NonceAggregateArgs>): Prisma.PrismaPromise<GetNonceAggregateType<T>>

    /**
     * Group by Nonce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NonceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NonceGroupByArgs['orderBy'] }
        : { orderBy?: NonceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NonceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNonceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nonce model
   */
  readonly fields: NonceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nonce.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NonceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nonce model
   */ 
  interface NonceFieldRefs {
    readonly id: FieldRef<"Nonce", 'String'>
    readonly address: FieldRef<"Nonce", 'String'>
    readonly value: FieldRef<"Nonce", 'String'>
    readonly chainId: FieldRef<"Nonce", 'Int'>
    readonly domain: FieldRef<"Nonce", 'String'>
    readonly issuedAt: FieldRef<"Nonce", 'DateTime'>
    readonly expiresAt: FieldRef<"Nonce", 'DateTime'>
    readonly used: FieldRef<"Nonce", 'Boolean'>
    readonly createdAt: FieldRef<"Nonce", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Nonce findUnique
   */
  export type NonceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonce to fetch.
     */
    where: NonceWhereUniqueInput
  }

  /**
   * Nonce findUniqueOrThrow
   */
  export type NonceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonce to fetch.
     */
    where: NonceWhereUniqueInput
  }

  /**
   * Nonce findFirst
   */
  export type NonceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonce to fetch.
     */
    where?: NonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nonces to fetch.
     */
    orderBy?: NonceOrderByWithRelationInput | NonceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nonces.
     */
    cursor?: NonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nonces.
     */
    distinct?: NonceScalarFieldEnum | NonceScalarFieldEnum[]
  }

  /**
   * Nonce findFirstOrThrow
   */
  export type NonceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonce to fetch.
     */
    where?: NonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nonces to fetch.
     */
    orderBy?: NonceOrderByWithRelationInput | NonceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nonces.
     */
    cursor?: NonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nonces.
     */
    distinct?: NonceScalarFieldEnum | NonceScalarFieldEnum[]
  }

  /**
   * Nonce findMany
   */
  export type NonceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonces to fetch.
     */
    where?: NonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nonces to fetch.
     */
    orderBy?: NonceOrderByWithRelationInput | NonceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nonces.
     */
    cursor?: NonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nonces.
     */
    skip?: number
    distinct?: NonceScalarFieldEnum | NonceScalarFieldEnum[]
  }

  /**
   * Nonce create
   */
  export type NonceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * The data needed to create a Nonce.
     */
    data: XOR<NonceCreateInput, NonceUncheckedCreateInput>
  }

  /**
   * Nonce createMany
   */
  export type NonceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nonces.
     */
    data: NonceCreateManyInput | NonceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nonce createManyAndReturn
   */
  export type NonceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Nonces.
     */
    data: NonceCreateManyInput | NonceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nonce update
   */
  export type NonceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * The data needed to update a Nonce.
     */
    data: XOR<NonceUpdateInput, NonceUncheckedUpdateInput>
    /**
     * Choose, which Nonce to update.
     */
    where: NonceWhereUniqueInput
  }

  /**
   * Nonce updateMany
   */
  export type NonceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nonces.
     */
    data: XOR<NonceUpdateManyMutationInput, NonceUncheckedUpdateManyInput>
    /**
     * Filter which Nonces to update
     */
    where?: NonceWhereInput
  }

  /**
   * Nonce upsert
   */
  export type NonceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * The filter to search for the Nonce to update in case it exists.
     */
    where: NonceWhereUniqueInput
    /**
     * In case the Nonce found by the `where` argument doesn't exist, create a new Nonce with this data.
     */
    create: XOR<NonceCreateInput, NonceUncheckedCreateInput>
    /**
     * In case the Nonce was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NonceUpdateInput, NonceUncheckedUpdateInput>
  }

  /**
   * Nonce delete
   */
  export type NonceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter which Nonce to delete.
     */
    where: NonceWhereUniqueInput
  }

  /**
   * Nonce deleteMany
   */
  export type NonceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nonces to delete
     */
    where?: NonceWhereInput
  }

  /**
   * Nonce without action
   */
  export type NonceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    address: string | null
    webhookUrl: string | null
    telegramId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    address: string | null
    webhookUrl: string | null
    telegramId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    address: number
    webhookUrl: number
    telegramId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    address?: true
    webhookUrl?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    address?: true
    webhookUrl?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    address?: true
    webhookUrl?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    address: string
    webhookUrl: string | null
    telegramId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    webhookUrl?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    webhookUrl?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    address?: boolean
    webhookUrl?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      address: string
      webhookUrl: string | null
      telegramId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `address`
     * const notificationPreferenceWithAddressOnly = await prisma.notificationPreference.findMany({ select: { address: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `address`
     * const notificationPreferenceWithAddressOnly = await prisma.notificationPreference.createManyAndReturn({ 
     *   select: { address: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */ 
  interface NotificationPreferenceFieldRefs {
    readonly address: FieldRef<"NotificationPreference", 'String'>
    readonly webhookUrl: FieldRef<"NotificationPreference", 'String'>
    readonly telegramId: FieldRef<"NotificationPreference", 'String'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    address: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    address: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    address: number
    type: number
    title: number
    message: number
    read: number
    link: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    address?: true
    type?: true
    title?: true
    message?: true
    read?: true
    link?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    address?: true
    type?: true
    title?: true
    message?: true
    read?: true
    link?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    address?: true
    type?: true
    title?: true
    message?: true
    read?: true
    link?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    address: string
    type: string
    title: string
    message: string
    read: boolean
    link: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    address?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      type: string
      title: string
      message: string
      read: boolean
      link: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly address: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ReferralCode
   */

  export type AggregateReferralCode = {
    _count: ReferralCodeCountAggregateOutputType | null
    _min: ReferralCodeMinAggregateOutputType | null
    _max: ReferralCodeMaxAggregateOutputType | null
  }

  export type ReferralCodeMinAggregateOutputType = {
    id: string | null
    address: string | null
    code: string | null
    referralLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCodeMaxAggregateOutputType = {
    id: string | null
    address: string | null
    code: string | null
    referralLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCodeCountAggregateOutputType = {
    id: number
    address: number
    code: number
    referralLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralCodeMinAggregateInputType = {
    id?: true
    address?: true
    code?: true
    referralLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCodeMaxAggregateInputType = {
    id?: true
    address?: true
    code?: true
    referralLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCodeCountAggregateInputType = {
    id?: true
    address?: true
    code?: true
    referralLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralCode to aggregate.
     */
    where?: ReferralCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralCodes to fetch.
     */
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralCodes
    **/
    _count?: true | ReferralCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralCodeMaxAggregateInputType
  }

  export type GetReferralCodeAggregateType<T extends ReferralCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralCode[P]>
      : GetScalarType<T[P], AggregateReferralCode[P]>
  }




  export type ReferralCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralCodeWhereInput
    orderBy?: ReferralCodeOrderByWithAggregationInput | ReferralCodeOrderByWithAggregationInput[]
    by: ReferralCodeScalarFieldEnum[] | ReferralCodeScalarFieldEnum
    having?: ReferralCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCodeCountAggregateInputType | true
    _min?: ReferralCodeMinAggregateInputType
    _max?: ReferralCodeMaxAggregateInputType
  }

  export type ReferralCodeGroupByOutputType = {
    id: string
    address: string
    code: string
    referralLink: string
    createdAt: Date
    updatedAt: Date
    _count: ReferralCodeCountAggregateOutputType | null
    _min: ReferralCodeMinAggregateOutputType | null
    _max: ReferralCodeMaxAggregateOutputType | null
  }

  type GetReferralCodeGroupByPayload<T extends ReferralCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralCodeGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralCodeGroupByOutputType[P]>
        }
      >
    >


  export type ReferralCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    code?: boolean
    referralLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    referrals?: boolean | ReferralCode$referralsArgs<ExtArgs>
    _count?: boolean | ReferralCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralCode"]>

  export type ReferralCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    code?: boolean
    referralLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralCode"]>

  export type ReferralCodeSelectScalar = {
    id?: boolean
    address?: boolean
    code?: boolean
    referralLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    referrals?: boolean | ReferralCode$referralsArgs<ExtArgs>
    _count?: boolean | ReferralCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReferralCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      code: string
      referralLink: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referralCode"]>
    composites: {}
  }

  type ReferralCodeGetPayload<S extends boolean | null | undefined | ReferralCodeDefaultArgs> = $Result.GetResult<Prisma.$ReferralCodePayload, S>

  type ReferralCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCodeCountAggregateInputType | true
    }

  export interface ReferralCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralCode'], meta: { name: 'ReferralCode' } }
    /**
     * Find zero or one ReferralCode that matches the filter.
     * @param {ReferralCodeFindUniqueArgs} args - Arguments to find a ReferralCode
     * @example
     * // Get one ReferralCode
     * const referralCode = await prisma.referralCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralCodeFindUniqueArgs>(args: SelectSubset<T, ReferralCodeFindUniqueArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralCodeFindUniqueOrThrowArgs} args - Arguments to find a ReferralCode
     * @example
     * // Get one ReferralCode
     * const referralCode = await prisma.referralCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeFindFirstArgs} args - Arguments to find a ReferralCode
     * @example
     * // Get one ReferralCode
     * const referralCode = await prisma.referralCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralCodeFindFirstArgs>(args?: SelectSubset<T, ReferralCodeFindFirstArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeFindFirstOrThrowArgs} args - Arguments to find a ReferralCode
     * @example
     * // Get one ReferralCode
     * const referralCode = await prisma.referralCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralCodes
     * const referralCodes = await prisma.referralCode.findMany()
     * 
     * // Get first 10 ReferralCodes
     * const referralCodes = await prisma.referralCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralCodeWithIdOnly = await prisma.referralCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralCodeFindManyArgs>(args?: SelectSubset<T, ReferralCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralCode.
     * @param {ReferralCodeCreateArgs} args - Arguments to create a ReferralCode.
     * @example
     * // Create one ReferralCode
     * const ReferralCode = await prisma.referralCode.create({
     *   data: {
     *     // ... data to create a ReferralCode
     *   }
     * })
     * 
     */
    create<T extends ReferralCodeCreateArgs>(args: SelectSubset<T, ReferralCodeCreateArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralCodes.
     * @param {ReferralCodeCreateManyArgs} args - Arguments to create many ReferralCodes.
     * @example
     * // Create many ReferralCodes
     * const referralCode = await prisma.referralCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCodeCreateManyArgs>(args?: SelectSubset<T, ReferralCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralCodes and returns the data saved in the database.
     * @param {ReferralCodeCreateManyAndReturnArgs} args - Arguments to create many ReferralCodes.
     * @example
     * // Create many ReferralCodes
     * const referralCode = await prisma.referralCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralCodes and only return the `id`
     * const referralCodeWithIdOnly = await prisma.referralCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralCode.
     * @param {ReferralCodeDeleteArgs} args - Arguments to delete one ReferralCode.
     * @example
     * // Delete one ReferralCode
     * const ReferralCode = await prisma.referralCode.delete({
     *   where: {
     *     // ... filter to delete one ReferralCode
     *   }
     * })
     * 
     */
    delete<T extends ReferralCodeDeleteArgs>(args: SelectSubset<T, ReferralCodeDeleteArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralCode.
     * @param {ReferralCodeUpdateArgs} args - Arguments to update one ReferralCode.
     * @example
     * // Update one ReferralCode
     * const referralCode = await prisma.referralCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralCodeUpdateArgs>(args: SelectSubset<T, ReferralCodeUpdateArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralCodes.
     * @param {ReferralCodeDeleteManyArgs} args - Arguments to filter ReferralCodes to delete.
     * @example
     * // Delete a few ReferralCodes
     * const { count } = await prisma.referralCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralCodeDeleteManyArgs>(args?: SelectSubset<T, ReferralCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralCodes
     * const referralCode = await prisma.referralCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralCodeUpdateManyArgs>(args: SelectSubset<T, ReferralCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralCode.
     * @param {ReferralCodeUpsertArgs} args - Arguments to update or create a ReferralCode.
     * @example
     * // Update or create a ReferralCode
     * const referralCode = await prisma.referralCode.upsert({
     *   create: {
     *     // ... data to create a ReferralCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralCode we want to update
     *   }
     * })
     */
    upsert<T extends ReferralCodeUpsertArgs>(args: SelectSubset<T, ReferralCodeUpsertArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeCountArgs} args - Arguments to filter ReferralCodes to count.
     * @example
     * // Count the number of ReferralCodes
     * const count = await prisma.referralCode.count({
     *   where: {
     *     // ... the filter for the ReferralCodes we want to count
     *   }
     * })
    **/
    count<T extends ReferralCodeCountArgs>(
      args?: Subset<T, ReferralCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralCodeAggregateArgs>(args: Subset<T, ReferralCodeAggregateArgs>): Prisma.PrismaPromise<GetReferralCodeAggregateType<T>>

    /**
     * Group by ReferralCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralCodeGroupByArgs['orderBy'] }
        : { orderBy?: ReferralCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralCode model
   */
  readonly fields: ReferralCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referrals<T extends ReferralCode$referralsArgs<ExtArgs> = {}>(args?: Subset<T, ReferralCode$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralCode model
   */ 
  interface ReferralCodeFieldRefs {
    readonly id: FieldRef<"ReferralCode", 'String'>
    readonly address: FieldRef<"ReferralCode", 'String'>
    readonly code: FieldRef<"ReferralCode", 'String'>
    readonly referralLink: FieldRef<"ReferralCode", 'String'>
    readonly createdAt: FieldRef<"ReferralCode", 'DateTime'>
    readonly updatedAt: FieldRef<"ReferralCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralCode findUnique
   */
  export type ReferralCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCode to fetch.
     */
    where: ReferralCodeWhereUniqueInput
  }

  /**
   * ReferralCode findUniqueOrThrow
   */
  export type ReferralCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCode to fetch.
     */
    where: ReferralCodeWhereUniqueInput
  }

  /**
   * ReferralCode findFirst
   */
  export type ReferralCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCode to fetch.
     */
    where?: ReferralCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralCodes to fetch.
     */
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralCodes.
     */
    cursor?: ReferralCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralCodes.
     */
    distinct?: ReferralCodeScalarFieldEnum | ReferralCodeScalarFieldEnum[]
  }

  /**
   * ReferralCode findFirstOrThrow
   */
  export type ReferralCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCode to fetch.
     */
    where?: ReferralCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralCodes to fetch.
     */
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralCodes.
     */
    cursor?: ReferralCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralCodes.
     */
    distinct?: ReferralCodeScalarFieldEnum | ReferralCodeScalarFieldEnum[]
  }

  /**
   * ReferralCode findMany
   */
  export type ReferralCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter, which ReferralCodes to fetch.
     */
    where?: ReferralCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralCodes to fetch.
     */
    orderBy?: ReferralCodeOrderByWithRelationInput | ReferralCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralCodes.
     */
    cursor?: ReferralCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralCodes.
     */
    skip?: number
    distinct?: ReferralCodeScalarFieldEnum | ReferralCodeScalarFieldEnum[]
  }

  /**
   * ReferralCode create
   */
  export type ReferralCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralCode.
     */
    data: XOR<ReferralCodeCreateInput, ReferralCodeUncheckedCreateInput>
  }

  /**
   * ReferralCode createMany
   */
  export type ReferralCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralCodes.
     */
    data: ReferralCodeCreateManyInput | ReferralCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralCode createManyAndReturn
   */
  export type ReferralCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralCodes.
     */
    data: ReferralCodeCreateManyInput | ReferralCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralCode update
   */
  export type ReferralCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralCode.
     */
    data: XOR<ReferralCodeUpdateInput, ReferralCodeUncheckedUpdateInput>
    /**
     * Choose, which ReferralCode to update.
     */
    where: ReferralCodeWhereUniqueInput
  }

  /**
   * ReferralCode updateMany
   */
  export type ReferralCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralCodes.
     */
    data: XOR<ReferralCodeUpdateManyMutationInput, ReferralCodeUncheckedUpdateManyInput>
    /**
     * Filter which ReferralCodes to update
     */
    where?: ReferralCodeWhereInput
  }

  /**
   * ReferralCode upsert
   */
  export type ReferralCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralCode to update in case it exists.
     */
    where: ReferralCodeWhereUniqueInput
    /**
     * In case the ReferralCode found by the `where` argument doesn't exist, create a new ReferralCode with this data.
     */
    create: XOR<ReferralCodeCreateInput, ReferralCodeUncheckedCreateInput>
    /**
     * In case the ReferralCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralCodeUpdateInput, ReferralCodeUncheckedUpdateInput>
  }

  /**
   * ReferralCode delete
   */
  export type ReferralCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
    /**
     * Filter which ReferralCode to delete.
     */
    where: ReferralCodeWhereUniqueInput
  }

  /**
   * ReferralCode deleteMany
   */
  export type ReferralCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralCodes to delete
     */
    where?: ReferralCodeWhereInput
  }

  /**
   * ReferralCode.referrals
   */
  export type ReferralCode$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * ReferralCode without action
   */
  export type ReferralCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralCode
     */
    select?: ReferralCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralCodeInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrerAddress: string | null
    refereeAddress: string | null
    referralCodeId: string | null
    qualified: boolean | null
    qualifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrerAddress: string | null
    refereeAddress: string | null
    referralCodeId: string | null
    qualified: boolean | null
    qualifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerAddress: number
    refereeAddress: number
    referralCodeId: number
    qualified: number
    qualifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralMinAggregateInputType = {
    id?: true
    referrerAddress?: true
    refereeAddress?: true
    referralCodeId?: true
    qualified?: true
    qualifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerAddress?: true
    refereeAddress?: true
    referralCodeId?: true
    qualified?: true
    qualifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerAddress?: true
    refereeAddress?: true
    referralCodeId?: true
    qualified?: true
    qualifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrerAddress: string
    refereeAddress: string
    referralCodeId: string
    qualified: boolean
    qualifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerAddress?: boolean
    refereeAddress?: boolean
    referralCodeId?: boolean
    qualified?: boolean
    qualifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    referralCode?: boolean | ReferralCodeDefaultArgs<ExtArgs>
    commissions?: boolean | Referral$commissionsArgs<ExtArgs>
    _count?: boolean | ReferralCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerAddress?: boolean
    refereeAddress?: boolean
    referralCodeId?: boolean
    qualified?: boolean
    qualifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    referralCode?: boolean | ReferralCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerAddress?: boolean
    refereeAddress?: boolean
    referralCodeId?: boolean
    qualified?: boolean
    qualifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    referralCode?: boolean | ReferralCodeDefaultArgs<ExtArgs>
    commissions?: boolean | Referral$commissionsArgs<ExtArgs>
    _count?: boolean | ReferralCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    referralCode?: boolean | ReferralCodeDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referee: Prisma.$UserPayload<ExtArgs>
      referralCode: Prisma.$ReferralCodePayload<ExtArgs>
      commissions: Prisma.$CommissionLedgerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerAddress: string
      refereeAddress: string
      referralCodeId: string
      qualified: boolean
      qualifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referralCode<T extends ReferralCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferralCodeDefaultArgs<ExtArgs>>): Prisma__ReferralCodeClient<$Result.GetResult<Prisma.$ReferralCodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    commissions<T extends Referral$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Referral$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */ 
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrerAddress: FieldRef<"Referral", 'String'>
    readonly refereeAddress: FieldRef<"Referral", 'String'>
    readonly referralCodeId: FieldRef<"Referral", 'String'>
    readonly qualified: FieldRef<"Referral", 'Boolean'>
    readonly qualifiedAt: FieldRef<"Referral", 'DateTime'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
    readonly updatedAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral.commissions
   */
  export type Referral$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    where?: CommissionLedgerWhereInput
    orderBy?: CommissionLedgerOrderByWithRelationInput | CommissionLedgerOrderByWithRelationInput[]
    cursor?: CommissionLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionLedgerScalarFieldEnum | CommissionLedgerScalarFieldEnum[]
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model CommissionLedger
   */

  export type AggregateCommissionLedger = {
    _count: CommissionLedgerCountAggregateOutputType | null
    _avg: CommissionLedgerAvgAggregateOutputType | null
    _sum: CommissionLedgerSumAggregateOutputType | null
    _min: CommissionLedgerMinAggregateOutputType | null
    _max: CommissionLedgerMaxAggregateOutputType | null
  }

  export type CommissionLedgerAvgAggregateOutputType = {
    feeAmount: Decimal | null
    commissionRate: Decimal | null
    commissionAmount: Decimal | null
  }

  export type CommissionLedgerSumAggregateOutputType = {
    feeAmount: Decimal | null
    commissionRate: Decimal | null
    commissionAmount: Decimal | null
  }

  export type CommissionLedgerMinAggregateOutputType = {
    id: string | null
    referralId: string | null
    feeAmount: Decimal | null
    commissionRate: Decimal | null
    commissionAmount: Decimal | null
    feeType: string | null
    createdAt: Date | null
  }

  export type CommissionLedgerMaxAggregateOutputType = {
    id: string | null
    referralId: string | null
    feeAmount: Decimal | null
    commissionRate: Decimal | null
    commissionAmount: Decimal | null
    feeType: string | null
    createdAt: Date | null
  }

  export type CommissionLedgerCountAggregateOutputType = {
    id: number
    referralId: number
    feeAmount: number
    commissionRate: number
    commissionAmount: number
    feeType: number
    createdAt: number
    _all: number
  }


  export type CommissionLedgerAvgAggregateInputType = {
    feeAmount?: true
    commissionRate?: true
    commissionAmount?: true
  }

  export type CommissionLedgerSumAggregateInputType = {
    feeAmount?: true
    commissionRate?: true
    commissionAmount?: true
  }

  export type CommissionLedgerMinAggregateInputType = {
    id?: true
    referralId?: true
    feeAmount?: true
    commissionRate?: true
    commissionAmount?: true
    feeType?: true
    createdAt?: true
  }

  export type CommissionLedgerMaxAggregateInputType = {
    id?: true
    referralId?: true
    feeAmount?: true
    commissionRate?: true
    commissionAmount?: true
    feeType?: true
    createdAt?: true
  }

  export type CommissionLedgerCountAggregateInputType = {
    id?: true
    referralId?: true
    feeAmount?: true
    commissionRate?: true
    commissionAmount?: true
    feeType?: true
    createdAt?: true
    _all?: true
  }

  export type CommissionLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionLedger to aggregate.
     */
    where?: CommissionLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionLedgers to fetch.
     */
    orderBy?: CommissionLedgerOrderByWithRelationInput | CommissionLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommissionLedgers
    **/
    _count?: true | CommissionLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionLedgerMaxAggregateInputType
  }

  export type GetCommissionLedgerAggregateType<T extends CommissionLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateCommissionLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommissionLedger[P]>
      : GetScalarType<T[P], AggregateCommissionLedger[P]>
  }




  export type CommissionLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionLedgerWhereInput
    orderBy?: CommissionLedgerOrderByWithAggregationInput | CommissionLedgerOrderByWithAggregationInput[]
    by: CommissionLedgerScalarFieldEnum[] | CommissionLedgerScalarFieldEnum
    having?: CommissionLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionLedgerCountAggregateInputType | true
    _avg?: CommissionLedgerAvgAggregateInputType
    _sum?: CommissionLedgerSumAggregateInputType
    _min?: CommissionLedgerMinAggregateInputType
    _max?: CommissionLedgerMaxAggregateInputType
  }

  export type CommissionLedgerGroupByOutputType = {
    id: string
    referralId: string
    feeAmount: Decimal
    commissionRate: Decimal
    commissionAmount: Decimal
    feeType: string
    createdAt: Date
    _count: CommissionLedgerCountAggregateOutputType | null
    _avg: CommissionLedgerAvgAggregateOutputType | null
    _sum: CommissionLedgerSumAggregateOutputType | null
    _min: CommissionLedgerMinAggregateOutputType | null
    _max: CommissionLedgerMaxAggregateOutputType | null
  }

  type GetCommissionLedgerGroupByPayload<T extends CommissionLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionLedgerGroupByOutputType[P]>
        }
      >
    >


  export type CommissionLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referralId?: boolean
    feeAmount?: boolean
    commissionRate?: boolean
    commissionAmount?: boolean
    feeType?: boolean
    createdAt?: boolean
    referral?: boolean | ReferralDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionLedger"]>

  export type CommissionLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referralId?: boolean
    feeAmount?: boolean
    commissionRate?: boolean
    commissionAmount?: boolean
    feeType?: boolean
    createdAt?: boolean
    referral?: boolean | ReferralDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionLedger"]>

  export type CommissionLedgerSelectScalar = {
    id?: boolean
    referralId?: boolean
    feeAmount?: boolean
    commissionRate?: boolean
    commissionAmount?: boolean
    feeType?: boolean
    createdAt?: boolean
  }

  export type CommissionLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referral?: boolean | ReferralDefaultArgs<ExtArgs>
  }
  export type CommissionLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referral?: boolean | ReferralDefaultArgs<ExtArgs>
  }

  export type $CommissionLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommissionLedger"
    objects: {
      referral: Prisma.$ReferralPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referralId: string
      feeAmount: Prisma.Decimal
      commissionRate: Prisma.Decimal
      commissionAmount: Prisma.Decimal
      feeType: string
      createdAt: Date
    }, ExtArgs["result"]["commissionLedger"]>
    composites: {}
  }

  type CommissionLedgerGetPayload<S extends boolean | null | undefined | CommissionLedgerDefaultArgs> = $Result.GetResult<Prisma.$CommissionLedgerPayload, S>

  type CommissionLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommissionLedgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommissionLedgerCountAggregateInputType | true
    }

  export interface CommissionLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommissionLedger'], meta: { name: 'CommissionLedger' } }
    /**
     * Find zero or one CommissionLedger that matches the filter.
     * @param {CommissionLedgerFindUniqueArgs} args - Arguments to find a CommissionLedger
     * @example
     * // Get one CommissionLedger
     * const commissionLedger = await prisma.commissionLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionLedgerFindUniqueArgs>(args: SelectSubset<T, CommissionLedgerFindUniqueArgs<ExtArgs>>): Prisma__CommissionLedgerClient<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommissionLedger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommissionLedgerFindUniqueOrThrowArgs} args - Arguments to find a CommissionLedger
     * @example
     * // Get one CommissionLedger
     * const commissionLedger = await prisma.commissionLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionLedgerClient<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommissionLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionLedgerFindFirstArgs} args - Arguments to find a CommissionLedger
     * @example
     * // Get one CommissionLedger
     * const commissionLedger = await prisma.commissionLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionLedgerFindFirstArgs>(args?: SelectSubset<T, CommissionLedgerFindFirstArgs<ExtArgs>>): Prisma__CommissionLedgerClient<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommissionLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionLedgerFindFirstOrThrowArgs} args - Arguments to find a CommissionLedger
     * @example
     * // Get one CommissionLedger
     * const commissionLedger = await prisma.commissionLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionLedgerClient<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommissionLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommissionLedgers
     * const commissionLedgers = await prisma.commissionLedger.findMany()
     * 
     * // Get first 10 CommissionLedgers
     * const commissionLedgers = await prisma.commissionLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionLedgerWithIdOnly = await prisma.commissionLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionLedgerFindManyArgs>(args?: SelectSubset<T, CommissionLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommissionLedger.
     * @param {CommissionLedgerCreateArgs} args - Arguments to create a CommissionLedger.
     * @example
     * // Create one CommissionLedger
     * const CommissionLedger = await prisma.commissionLedger.create({
     *   data: {
     *     // ... data to create a CommissionLedger
     *   }
     * })
     * 
     */
    create<T extends CommissionLedgerCreateArgs>(args: SelectSubset<T, CommissionLedgerCreateArgs<ExtArgs>>): Prisma__CommissionLedgerClient<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommissionLedgers.
     * @param {CommissionLedgerCreateManyArgs} args - Arguments to create many CommissionLedgers.
     * @example
     * // Create many CommissionLedgers
     * const commissionLedger = await prisma.commissionLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionLedgerCreateManyArgs>(args?: SelectSubset<T, CommissionLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommissionLedgers and returns the data saved in the database.
     * @param {CommissionLedgerCreateManyAndReturnArgs} args - Arguments to create many CommissionLedgers.
     * @example
     * // Create many CommissionLedgers
     * const commissionLedger = await prisma.commissionLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommissionLedgers and only return the `id`
     * const commissionLedgerWithIdOnly = await prisma.commissionLedger.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommissionLedger.
     * @param {CommissionLedgerDeleteArgs} args - Arguments to delete one CommissionLedger.
     * @example
     * // Delete one CommissionLedger
     * const CommissionLedger = await prisma.commissionLedger.delete({
     *   where: {
     *     // ... filter to delete one CommissionLedger
     *   }
     * })
     * 
     */
    delete<T extends CommissionLedgerDeleteArgs>(args: SelectSubset<T, CommissionLedgerDeleteArgs<ExtArgs>>): Prisma__CommissionLedgerClient<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommissionLedger.
     * @param {CommissionLedgerUpdateArgs} args - Arguments to update one CommissionLedger.
     * @example
     * // Update one CommissionLedger
     * const commissionLedger = await prisma.commissionLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionLedgerUpdateArgs>(args: SelectSubset<T, CommissionLedgerUpdateArgs<ExtArgs>>): Prisma__CommissionLedgerClient<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommissionLedgers.
     * @param {CommissionLedgerDeleteManyArgs} args - Arguments to filter CommissionLedgers to delete.
     * @example
     * // Delete a few CommissionLedgers
     * const { count } = await prisma.commissionLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionLedgerDeleteManyArgs>(args?: SelectSubset<T, CommissionLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommissionLedgers
     * const commissionLedger = await prisma.commissionLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionLedgerUpdateManyArgs>(args: SelectSubset<T, CommissionLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommissionLedger.
     * @param {CommissionLedgerUpsertArgs} args - Arguments to update or create a CommissionLedger.
     * @example
     * // Update or create a CommissionLedger
     * const commissionLedger = await prisma.commissionLedger.upsert({
     *   create: {
     *     // ... data to create a CommissionLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommissionLedger we want to update
     *   }
     * })
     */
    upsert<T extends CommissionLedgerUpsertArgs>(args: SelectSubset<T, CommissionLedgerUpsertArgs<ExtArgs>>): Prisma__CommissionLedgerClient<$Result.GetResult<Prisma.$CommissionLedgerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommissionLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionLedgerCountArgs} args - Arguments to filter CommissionLedgers to count.
     * @example
     * // Count the number of CommissionLedgers
     * const count = await prisma.commissionLedger.count({
     *   where: {
     *     // ... the filter for the CommissionLedgers we want to count
     *   }
     * })
    **/
    count<T extends CommissionLedgerCountArgs>(
      args?: Subset<T, CommissionLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommissionLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionLedgerAggregateArgs>(args: Subset<T, CommissionLedgerAggregateArgs>): Prisma.PrismaPromise<GetCommissionLedgerAggregateType<T>>

    /**
     * Group by CommissionLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionLedgerGroupByArgs['orderBy'] }
        : { orderBy?: CommissionLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommissionLedger model
   */
  readonly fields: CommissionLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommissionLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referral<T extends ReferralDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferralDefaultArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommissionLedger model
   */ 
  interface CommissionLedgerFieldRefs {
    readonly id: FieldRef<"CommissionLedger", 'String'>
    readonly referralId: FieldRef<"CommissionLedger", 'String'>
    readonly feeAmount: FieldRef<"CommissionLedger", 'Decimal'>
    readonly commissionRate: FieldRef<"CommissionLedger", 'Decimal'>
    readonly commissionAmount: FieldRef<"CommissionLedger", 'Decimal'>
    readonly feeType: FieldRef<"CommissionLedger", 'String'>
    readonly createdAt: FieldRef<"CommissionLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommissionLedger findUnique
   */
  export type CommissionLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CommissionLedger to fetch.
     */
    where: CommissionLedgerWhereUniqueInput
  }

  /**
   * CommissionLedger findUniqueOrThrow
   */
  export type CommissionLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CommissionLedger to fetch.
     */
    where: CommissionLedgerWhereUniqueInput
  }

  /**
   * CommissionLedger findFirst
   */
  export type CommissionLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CommissionLedger to fetch.
     */
    where?: CommissionLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionLedgers to fetch.
     */
    orderBy?: CommissionLedgerOrderByWithRelationInput | CommissionLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionLedgers.
     */
    cursor?: CommissionLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionLedgers.
     */
    distinct?: CommissionLedgerScalarFieldEnum | CommissionLedgerScalarFieldEnum[]
  }

  /**
   * CommissionLedger findFirstOrThrow
   */
  export type CommissionLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CommissionLedger to fetch.
     */
    where?: CommissionLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionLedgers to fetch.
     */
    orderBy?: CommissionLedgerOrderByWithRelationInput | CommissionLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionLedgers.
     */
    cursor?: CommissionLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionLedgers.
     */
    distinct?: CommissionLedgerScalarFieldEnum | CommissionLedgerScalarFieldEnum[]
  }

  /**
   * CommissionLedger findMany
   */
  export type CommissionLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CommissionLedgers to fetch.
     */
    where?: CommissionLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionLedgers to fetch.
     */
    orderBy?: CommissionLedgerOrderByWithRelationInput | CommissionLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommissionLedgers.
     */
    cursor?: CommissionLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionLedgers.
     */
    skip?: number
    distinct?: CommissionLedgerScalarFieldEnum | CommissionLedgerScalarFieldEnum[]
  }

  /**
   * CommissionLedger create
   */
  export type CommissionLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a CommissionLedger.
     */
    data: XOR<CommissionLedgerCreateInput, CommissionLedgerUncheckedCreateInput>
  }

  /**
   * CommissionLedger createMany
   */
  export type CommissionLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommissionLedgers.
     */
    data: CommissionLedgerCreateManyInput | CommissionLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommissionLedger createManyAndReturn
   */
  export type CommissionLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommissionLedgers.
     */
    data: CommissionLedgerCreateManyInput | CommissionLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommissionLedger update
   */
  export type CommissionLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a CommissionLedger.
     */
    data: XOR<CommissionLedgerUpdateInput, CommissionLedgerUncheckedUpdateInput>
    /**
     * Choose, which CommissionLedger to update.
     */
    where: CommissionLedgerWhereUniqueInput
  }

  /**
   * CommissionLedger updateMany
   */
  export type CommissionLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommissionLedgers.
     */
    data: XOR<CommissionLedgerUpdateManyMutationInput, CommissionLedgerUncheckedUpdateManyInput>
    /**
     * Filter which CommissionLedgers to update
     */
    where?: CommissionLedgerWhereInput
  }

  /**
   * CommissionLedger upsert
   */
  export type CommissionLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the CommissionLedger to update in case it exists.
     */
    where: CommissionLedgerWhereUniqueInput
    /**
     * In case the CommissionLedger found by the `where` argument doesn't exist, create a new CommissionLedger with this data.
     */
    create: XOR<CommissionLedgerCreateInput, CommissionLedgerUncheckedCreateInput>
    /**
     * In case the CommissionLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionLedgerUpdateInput, CommissionLedgerUncheckedUpdateInput>
  }

  /**
   * CommissionLedger delete
   */
  export type CommissionLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
    /**
     * Filter which CommissionLedger to delete.
     */
    where: CommissionLedgerWhereUniqueInput
  }

  /**
   * CommissionLedger deleteMany
   */
  export type CommissionLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionLedgers to delete
     */
    where?: CommissionLedgerWhereInput
  }

  /**
   * CommissionLedger without action
   */
  export type CommissionLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionLedger
     */
    select?: CommissionLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionLedgerInclude<ExtArgs> | null
  }


  /**
   * Model ReferralWallet
   */

  export type AggregateReferralWallet = {
    _count: ReferralWalletCountAggregateOutputType | null
    _avg: ReferralWalletAvgAggregateOutputType | null
    _sum: ReferralWalletSumAggregateOutputType | null
    _min: ReferralWalletMinAggregateOutputType | null
    _max: ReferralWalletMaxAggregateOutputType | null
  }

  export type ReferralWalletAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type ReferralWalletSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type ReferralWalletMinAggregateOutputType = {
    id: string | null
    address: string | null
    balance: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralWalletMaxAggregateOutputType = {
    id: string | null
    address: string | null
    balance: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralWalletCountAggregateOutputType = {
    id: number
    address: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralWalletAvgAggregateInputType = {
    balance?: true
  }

  export type ReferralWalletSumAggregateInputType = {
    balance?: true
  }

  export type ReferralWalletMinAggregateInputType = {
    id?: true
    address?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralWalletMaxAggregateInputType = {
    id?: true
    address?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralWalletCountAggregateInputType = {
    id?: true
    address?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralWallet to aggregate.
     */
    where?: ReferralWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralWallets to fetch.
     */
    orderBy?: ReferralWalletOrderByWithRelationInput | ReferralWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralWallets
    **/
    _count?: true | ReferralWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralWalletMaxAggregateInputType
  }

  export type GetReferralWalletAggregateType<T extends ReferralWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralWallet[P]>
      : GetScalarType<T[P], AggregateReferralWallet[P]>
  }




  export type ReferralWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWalletWhereInput
    orderBy?: ReferralWalletOrderByWithAggregationInput | ReferralWalletOrderByWithAggregationInput[]
    by: ReferralWalletScalarFieldEnum[] | ReferralWalletScalarFieldEnum
    having?: ReferralWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralWalletCountAggregateInputType | true
    _avg?: ReferralWalletAvgAggregateInputType
    _sum?: ReferralWalletSumAggregateInputType
    _min?: ReferralWalletMinAggregateInputType
    _max?: ReferralWalletMaxAggregateInputType
  }

  export type ReferralWalletGroupByOutputType = {
    id: string
    address: string
    balance: Decimal
    createdAt: Date
    updatedAt: Date
    _count: ReferralWalletCountAggregateOutputType | null
    _avg: ReferralWalletAvgAggregateOutputType | null
    _sum: ReferralWalletSumAggregateOutputType | null
    _min: ReferralWalletMinAggregateOutputType | null
    _max: ReferralWalletMaxAggregateOutputType | null
  }

  type GetReferralWalletGroupByPayload<T extends ReferralWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralWalletGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralWalletGroupByOutputType[P]>
        }
      >
    >


  export type ReferralWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | ReferralWallet$transactionsArgs<ExtArgs>
    _count?: boolean | ReferralWalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralWallet"]>

  export type ReferralWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralWallet"]>

  export type ReferralWalletSelectScalar = {
    id?: boolean
    address?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | ReferralWallet$transactionsArgs<ExtArgs>
    _count?: boolean | ReferralWalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReferralWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralWallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$ReferralWalletTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      balance: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referralWallet"]>
    composites: {}
  }

  type ReferralWalletGetPayload<S extends boolean | null | undefined | ReferralWalletDefaultArgs> = $Result.GetResult<Prisma.$ReferralWalletPayload, S>

  type ReferralWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralWalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralWalletCountAggregateInputType | true
    }

  export interface ReferralWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralWallet'], meta: { name: 'ReferralWallet' } }
    /**
     * Find zero or one ReferralWallet that matches the filter.
     * @param {ReferralWalletFindUniqueArgs} args - Arguments to find a ReferralWallet
     * @example
     * // Get one ReferralWallet
     * const referralWallet = await prisma.referralWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralWalletFindUniqueArgs>(args: SelectSubset<T, ReferralWalletFindUniqueArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralWallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralWalletFindUniqueOrThrowArgs} args - Arguments to find a ReferralWallet
     * @example
     * // Get one ReferralWallet
     * const referralWallet = await prisma.referralWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletFindFirstArgs} args - Arguments to find a ReferralWallet
     * @example
     * // Get one ReferralWallet
     * const referralWallet = await prisma.referralWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralWalletFindFirstArgs>(args?: SelectSubset<T, ReferralWalletFindFirstArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletFindFirstOrThrowArgs} args - Arguments to find a ReferralWallet
     * @example
     * // Get one ReferralWallet
     * const referralWallet = await prisma.referralWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralWallets
     * const referralWallets = await prisma.referralWallet.findMany()
     * 
     * // Get first 10 ReferralWallets
     * const referralWallets = await prisma.referralWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWalletWithIdOnly = await prisma.referralWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralWalletFindManyArgs>(args?: SelectSubset<T, ReferralWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralWallet.
     * @param {ReferralWalletCreateArgs} args - Arguments to create a ReferralWallet.
     * @example
     * // Create one ReferralWallet
     * const ReferralWallet = await prisma.referralWallet.create({
     *   data: {
     *     // ... data to create a ReferralWallet
     *   }
     * })
     * 
     */
    create<T extends ReferralWalletCreateArgs>(args: SelectSubset<T, ReferralWalletCreateArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralWallets.
     * @param {ReferralWalletCreateManyArgs} args - Arguments to create many ReferralWallets.
     * @example
     * // Create many ReferralWallets
     * const referralWallet = await prisma.referralWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralWalletCreateManyArgs>(args?: SelectSubset<T, ReferralWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralWallets and returns the data saved in the database.
     * @param {ReferralWalletCreateManyAndReturnArgs} args - Arguments to create many ReferralWallets.
     * @example
     * // Create many ReferralWallets
     * const referralWallet = await prisma.referralWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralWallets and only return the `id`
     * const referralWalletWithIdOnly = await prisma.referralWallet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralWallet.
     * @param {ReferralWalletDeleteArgs} args - Arguments to delete one ReferralWallet.
     * @example
     * // Delete one ReferralWallet
     * const ReferralWallet = await prisma.referralWallet.delete({
     *   where: {
     *     // ... filter to delete one ReferralWallet
     *   }
     * })
     * 
     */
    delete<T extends ReferralWalletDeleteArgs>(args: SelectSubset<T, ReferralWalletDeleteArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralWallet.
     * @param {ReferralWalletUpdateArgs} args - Arguments to update one ReferralWallet.
     * @example
     * // Update one ReferralWallet
     * const referralWallet = await prisma.referralWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralWalletUpdateArgs>(args: SelectSubset<T, ReferralWalletUpdateArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralWallets.
     * @param {ReferralWalletDeleteManyArgs} args - Arguments to filter ReferralWallets to delete.
     * @example
     * // Delete a few ReferralWallets
     * const { count } = await prisma.referralWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralWalletDeleteManyArgs>(args?: SelectSubset<T, ReferralWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralWallets
     * const referralWallet = await prisma.referralWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralWalletUpdateManyArgs>(args: SelectSubset<T, ReferralWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralWallet.
     * @param {ReferralWalletUpsertArgs} args - Arguments to update or create a ReferralWallet.
     * @example
     * // Update or create a ReferralWallet
     * const referralWallet = await prisma.referralWallet.upsert({
     *   create: {
     *     // ... data to create a ReferralWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralWallet we want to update
     *   }
     * })
     */
    upsert<T extends ReferralWalletUpsertArgs>(args: SelectSubset<T, ReferralWalletUpsertArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletCountArgs} args - Arguments to filter ReferralWallets to count.
     * @example
     * // Count the number of ReferralWallets
     * const count = await prisma.referralWallet.count({
     *   where: {
     *     // ... the filter for the ReferralWallets we want to count
     *   }
     * })
    **/
    count<T extends ReferralWalletCountArgs>(
      args?: Subset<T, ReferralWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralWalletAggregateArgs>(args: Subset<T, ReferralWalletAggregateArgs>): Prisma.PrismaPromise<GetReferralWalletAggregateType<T>>

    /**
     * Group by ReferralWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralWalletGroupByArgs['orderBy'] }
        : { orderBy?: ReferralWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralWallet model
   */
  readonly fields: ReferralWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends ReferralWallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, ReferralWallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralWallet model
   */ 
  interface ReferralWalletFieldRefs {
    readonly id: FieldRef<"ReferralWallet", 'String'>
    readonly address: FieldRef<"ReferralWallet", 'String'>
    readonly balance: FieldRef<"ReferralWallet", 'Decimal'>
    readonly createdAt: FieldRef<"ReferralWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"ReferralWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralWallet findUnique
   */
  export type ReferralWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWallet to fetch.
     */
    where: ReferralWalletWhereUniqueInput
  }

  /**
   * ReferralWallet findUniqueOrThrow
   */
  export type ReferralWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWallet to fetch.
     */
    where: ReferralWalletWhereUniqueInput
  }

  /**
   * ReferralWallet findFirst
   */
  export type ReferralWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWallet to fetch.
     */
    where?: ReferralWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralWallets to fetch.
     */
    orderBy?: ReferralWalletOrderByWithRelationInput | ReferralWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralWallets.
     */
    cursor?: ReferralWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralWallets.
     */
    distinct?: ReferralWalletScalarFieldEnum | ReferralWalletScalarFieldEnum[]
  }

  /**
   * ReferralWallet findFirstOrThrow
   */
  export type ReferralWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWallet to fetch.
     */
    where?: ReferralWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralWallets to fetch.
     */
    orderBy?: ReferralWalletOrderByWithRelationInput | ReferralWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralWallets.
     */
    cursor?: ReferralWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralWallets.
     */
    distinct?: ReferralWalletScalarFieldEnum | ReferralWalletScalarFieldEnum[]
  }

  /**
   * ReferralWallet findMany
   */
  export type ReferralWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWallets to fetch.
     */
    where?: ReferralWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralWallets to fetch.
     */
    orderBy?: ReferralWalletOrderByWithRelationInput | ReferralWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralWallets.
     */
    cursor?: ReferralWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralWallets.
     */
    skip?: number
    distinct?: ReferralWalletScalarFieldEnum | ReferralWalletScalarFieldEnum[]
  }

  /**
   * ReferralWallet create
   */
  export type ReferralWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralWallet.
     */
    data: XOR<ReferralWalletCreateInput, ReferralWalletUncheckedCreateInput>
  }

  /**
   * ReferralWallet createMany
   */
  export type ReferralWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralWallets.
     */
    data: ReferralWalletCreateManyInput | ReferralWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralWallet createManyAndReturn
   */
  export type ReferralWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralWallets.
     */
    data: ReferralWalletCreateManyInput | ReferralWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralWallet update
   */
  export type ReferralWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralWallet.
     */
    data: XOR<ReferralWalletUpdateInput, ReferralWalletUncheckedUpdateInput>
    /**
     * Choose, which ReferralWallet to update.
     */
    where: ReferralWalletWhereUniqueInput
  }

  /**
   * ReferralWallet updateMany
   */
  export type ReferralWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralWallets.
     */
    data: XOR<ReferralWalletUpdateManyMutationInput, ReferralWalletUncheckedUpdateManyInput>
    /**
     * Filter which ReferralWallets to update
     */
    where?: ReferralWalletWhereInput
  }

  /**
   * ReferralWallet upsert
   */
  export type ReferralWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralWallet to update in case it exists.
     */
    where: ReferralWalletWhereUniqueInput
    /**
     * In case the ReferralWallet found by the `where` argument doesn't exist, create a new ReferralWallet with this data.
     */
    create: XOR<ReferralWalletCreateInput, ReferralWalletUncheckedCreateInput>
    /**
     * In case the ReferralWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralWalletUpdateInput, ReferralWalletUncheckedUpdateInput>
  }

  /**
   * ReferralWallet delete
   */
  export type ReferralWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
    /**
     * Filter which ReferralWallet to delete.
     */
    where: ReferralWalletWhereUniqueInput
  }

  /**
   * ReferralWallet deleteMany
   */
  export type ReferralWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralWallets to delete
     */
    where?: ReferralWalletWhereInput
  }

  /**
   * ReferralWallet.transactions
   */
  export type ReferralWallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    where?: ReferralWalletTransactionWhereInput
    orderBy?: ReferralWalletTransactionOrderByWithRelationInput | ReferralWalletTransactionOrderByWithRelationInput[]
    cursor?: ReferralWalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralWalletTransactionScalarFieldEnum | ReferralWalletTransactionScalarFieldEnum[]
  }

  /**
   * ReferralWallet without action
   */
  export type ReferralWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWallet
     */
    select?: ReferralWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletInclude<ExtArgs> | null
  }


  /**
   * Model ReferralWalletTransaction
   */

  export type AggregateReferralWalletTransaction = {
    _count: ReferralWalletTransactionCountAggregateOutputType | null
    _avg: ReferralWalletTransactionAvgAggregateOutputType | null
    _sum: ReferralWalletTransactionSumAggregateOutputType | null
    _min: ReferralWalletTransactionMinAggregateOutputType | null
    _max: ReferralWalletTransactionMaxAggregateOutputType | null
  }

  export type ReferralWalletTransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ReferralWalletTransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ReferralWalletTransactionMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: Decimal | null
    type: string | null
    status: string | null
    targetAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralWalletTransactionMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: Decimal | null
    type: string | null
    status: string | null
    targetAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralWalletTransactionCountAggregateOutputType = {
    id: number
    walletId: number
    amount: number
    type: number
    status: number
    targetAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralWalletTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type ReferralWalletTransactionSumAggregateInputType = {
    amount?: true
  }

  export type ReferralWalletTransactionMinAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    status?: true
    targetAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralWalletTransactionMaxAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    status?: true
    targetAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralWalletTransactionCountAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    status?: true
    targetAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralWalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralWalletTransaction to aggregate.
     */
    where?: ReferralWalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralWalletTransactions to fetch.
     */
    orderBy?: ReferralWalletTransactionOrderByWithRelationInput | ReferralWalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralWalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralWalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralWalletTransactions
    **/
    _count?: true | ReferralWalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralWalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralWalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralWalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralWalletTransactionMaxAggregateInputType
  }

  export type GetReferralWalletTransactionAggregateType<T extends ReferralWalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralWalletTransaction[P]>
      : GetScalarType<T[P], AggregateReferralWalletTransaction[P]>
  }




  export type ReferralWalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWalletTransactionWhereInput
    orderBy?: ReferralWalletTransactionOrderByWithAggregationInput | ReferralWalletTransactionOrderByWithAggregationInput[]
    by: ReferralWalletTransactionScalarFieldEnum[] | ReferralWalletTransactionScalarFieldEnum
    having?: ReferralWalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralWalletTransactionCountAggregateInputType | true
    _avg?: ReferralWalletTransactionAvgAggregateInputType
    _sum?: ReferralWalletTransactionSumAggregateInputType
    _min?: ReferralWalletTransactionMinAggregateInputType
    _max?: ReferralWalletTransactionMaxAggregateInputType
  }

  export type ReferralWalletTransactionGroupByOutputType = {
    id: string
    walletId: string
    amount: Decimal
    type: string
    status: string
    targetAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReferralWalletTransactionCountAggregateOutputType | null
    _avg: ReferralWalletTransactionAvgAggregateOutputType | null
    _sum: ReferralWalletTransactionSumAggregateOutputType | null
    _min: ReferralWalletTransactionMinAggregateOutputType | null
    _max: ReferralWalletTransactionMaxAggregateOutputType | null
  }

  type GetReferralWalletTransactionGroupByPayload<T extends ReferralWalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralWalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralWalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralWalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralWalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type ReferralWalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    targetAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wallet?: boolean | ReferralWalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralWalletTransaction"]>

  export type ReferralWalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    targetAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wallet?: boolean | ReferralWalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralWalletTransaction"]>

  export type ReferralWalletTransactionSelectScalar = {
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    targetAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralWalletTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | ReferralWalletDefaultArgs<ExtArgs>
  }
  export type ReferralWalletTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | ReferralWalletDefaultArgs<ExtArgs>
  }

  export type $ReferralWalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralWalletTransaction"
    objects: {
      wallet: Prisma.$ReferralWalletPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      amount: Prisma.Decimal
      /**
       * withdrawal | transfer
       */
      type: string
      /**
       * pending | completed | failed
       */
      status: string
      targetAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referralWalletTransaction"]>
    composites: {}
  }

  type ReferralWalletTransactionGetPayload<S extends boolean | null | undefined | ReferralWalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$ReferralWalletTransactionPayload, S>

  type ReferralWalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralWalletTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralWalletTransactionCountAggregateInputType | true
    }

  export interface ReferralWalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralWalletTransaction'], meta: { name: 'ReferralWalletTransaction' } }
    /**
     * Find zero or one ReferralWalletTransaction that matches the filter.
     * @param {ReferralWalletTransactionFindUniqueArgs} args - Arguments to find a ReferralWalletTransaction
     * @example
     * // Get one ReferralWalletTransaction
     * const referralWalletTransaction = await prisma.referralWalletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralWalletTransactionFindUniqueArgs>(args: SelectSubset<T, ReferralWalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__ReferralWalletTransactionClient<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralWalletTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralWalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a ReferralWalletTransaction
     * @example
     * // Get one ReferralWalletTransaction
     * const referralWalletTransaction = await prisma.referralWalletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralWalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralWalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralWalletTransactionClient<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralWalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletTransactionFindFirstArgs} args - Arguments to find a ReferralWalletTransaction
     * @example
     * // Get one ReferralWalletTransaction
     * const referralWalletTransaction = await prisma.referralWalletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralWalletTransactionFindFirstArgs>(args?: SelectSubset<T, ReferralWalletTransactionFindFirstArgs<ExtArgs>>): Prisma__ReferralWalletTransactionClient<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralWalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletTransactionFindFirstOrThrowArgs} args - Arguments to find a ReferralWalletTransaction
     * @example
     * // Get one ReferralWalletTransaction
     * const referralWalletTransaction = await prisma.referralWalletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralWalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralWalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralWalletTransactionClient<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralWalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralWalletTransactions
     * const referralWalletTransactions = await prisma.referralWalletTransaction.findMany()
     * 
     * // Get first 10 ReferralWalletTransactions
     * const referralWalletTransactions = await prisma.referralWalletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWalletTransactionWithIdOnly = await prisma.referralWalletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralWalletTransactionFindManyArgs>(args?: SelectSubset<T, ReferralWalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralWalletTransaction.
     * @param {ReferralWalletTransactionCreateArgs} args - Arguments to create a ReferralWalletTransaction.
     * @example
     * // Create one ReferralWalletTransaction
     * const ReferralWalletTransaction = await prisma.referralWalletTransaction.create({
     *   data: {
     *     // ... data to create a ReferralWalletTransaction
     *   }
     * })
     * 
     */
    create<T extends ReferralWalletTransactionCreateArgs>(args: SelectSubset<T, ReferralWalletTransactionCreateArgs<ExtArgs>>): Prisma__ReferralWalletTransactionClient<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralWalletTransactions.
     * @param {ReferralWalletTransactionCreateManyArgs} args - Arguments to create many ReferralWalletTransactions.
     * @example
     * // Create many ReferralWalletTransactions
     * const referralWalletTransaction = await prisma.referralWalletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralWalletTransactionCreateManyArgs>(args?: SelectSubset<T, ReferralWalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralWalletTransactions and returns the data saved in the database.
     * @param {ReferralWalletTransactionCreateManyAndReturnArgs} args - Arguments to create many ReferralWalletTransactions.
     * @example
     * // Create many ReferralWalletTransactions
     * const referralWalletTransaction = await prisma.referralWalletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralWalletTransactions and only return the `id`
     * const referralWalletTransactionWithIdOnly = await prisma.referralWalletTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralWalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralWalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralWalletTransaction.
     * @param {ReferralWalletTransactionDeleteArgs} args - Arguments to delete one ReferralWalletTransaction.
     * @example
     * // Delete one ReferralWalletTransaction
     * const ReferralWalletTransaction = await prisma.referralWalletTransaction.delete({
     *   where: {
     *     // ... filter to delete one ReferralWalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends ReferralWalletTransactionDeleteArgs>(args: SelectSubset<T, ReferralWalletTransactionDeleteArgs<ExtArgs>>): Prisma__ReferralWalletTransactionClient<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralWalletTransaction.
     * @param {ReferralWalletTransactionUpdateArgs} args - Arguments to update one ReferralWalletTransaction.
     * @example
     * // Update one ReferralWalletTransaction
     * const referralWalletTransaction = await prisma.referralWalletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralWalletTransactionUpdateArgs>(args: SelectSubset<T, ReferralWalletTransactionUpdateArgs<ExtArgs>>): Prisma__ReferralWalletTransactionClient<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralWalletTransactions.
     * @param {ReferralWalletTransactionDeleteManyArgs} args - Arguments to filter ReferralWalletTransactions to delete.
     * @example
     * // Delete a few ReferralWalletTransactions
     * const { count } = await prisma.referralWalletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralWalletTransactionDeleteManyArgs>(args?: SelectSubset<T, ReferralWalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralWalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralWalletTransactions
     * const referralWalletTransaction = await prisma.referralWalletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralWalletTransactionUpdateManyArgs>(args: SelectSubset<T, ReferralWalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralWalletTransaction.
     * @param {ReferralWalletTransactionUpsertArgs} args - Arguments to update or create a ReferralWalletTransaction.
     * @example
     * // Update or create a ReferralWalletTransaction
     * const referralWalletTransaction = await prisma.referralWalletTransaction.upsert({
     *   create: {
     *     // ... data to create a ReferralWalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralWalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends ReferralWalletTransactionUpsertArgs>(args: SelectSubset<T, ReferralWalletTransactionUpsertArgs<ExtArgs>>): Prisma__ReferralWalletTransactionClient<$Result.GetResult<Prisma.$ReferralWalletTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralWalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletTransactionCountArgs} args - Arguments to filter ReferralWalletTransactions to count.
     * @example
     * // Count the number of ReferralWalletTransactions
     * const count = await prisma.referralWalletTransaction.count({
     *   where: {
     *     // ... the filter for the ReferralWalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends ReferralWalletTransactionCountArgs>(
      args?: Subset<T, ReferralWalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralWalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralWalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralWalletTransactionAggregateArgs>(args: Subset<T, ReferralWalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetReferralWalletTransactionAggregateType<T>>

    /**
     * Group by ReferralWalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralWalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralWalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralWalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: ReferralWalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralWalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralWalletTransaction model
   */
  readonly fields: ReferralWalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralWalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralWalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends ReferralWalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferralWalletDefaultArgs<ExtArgs>>): Prisma__ReferralWalletClient<$Result.GetResult<Prisma.$ReferralWalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralWalletTransaction model
   */ 
  interface ReferralWalletTransactionFieldRefs {
    readonly id: FieldRef<"ReferralWalletTransaction", 'String'>
    readonly walletId: FieldRef<"ReferralWalletTransaction", 'String'>
    readonly amount: FieldRef<"ReferralWalletTransaction", 'Decimal'>
    readonly type: FieldRef<"ReferralWalletTransaction", 'String'>
    readonly status: FieldRef<"ReferralWalletTransaction", 'String'>
    readonly targetAddress: FieldRef<"ReferralWalletTransaction", 'String'>
    readonly createdAt: FieldRef<"ReferralWalletTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"ReferralWalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralWalletTransaction findUnique
   */
  export type ReferralWalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWalletTransaction to fetch.
     */
    where: ReferralWalletTransactionWhereUniqueInput
  }

  /**
   * ReferralWalletTransaction findUniqueOrThrow
   */
  export type ReferralWalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWalletTransaction to fetch.
     */
    where: ReferralWalletTransactionWhereUniqueInput
  }

  /**
   * ReferralWalletTransaction findFirst
   */
  export type ReferralWalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWalletTransaction to fetch.
     */
    where?: ReferralWalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralWalletTransactions to fetch.
     */
    orderBy?: ReferralWalletTransactionOrderByWithRelationInput | ReferralWalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralWalletTransactions.
     */
    cursor?: ReferralWalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralWalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralWalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralWalletTransactions.
     */
    distinct?: ReferralWalletTransactionScalarFieldEnum | ReferralWalletTransactionScalarFieldEnum[]
  }

  /**
   * ReferralWalletTransaction findFirstOrThrow
   */
  export type ReferralWalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWalletTransaction to fetch.
     */
    where?: ReferralWalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralWalletTransactions to fetch.
     */
    orderBy?: ReferralWalletTransactionOrderByWithRelationInput | ReferralWalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralWalletTransactions.
     */
    cursor?: ReferralWalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralWalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralWalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralWalletTransactions.
     */
    distinct?: ReferralWalletTransactionScalarFieldEnum | ReferralWalletTransactionScalarFieldEnum[]
  }

  /**
   * ReferralWalletTransaction findMany
   */
  export type ReferralWalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralWalletTransactions to fetch.
     */
    where?: ReferralWalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralWalletTransactions to fetch.
     */
    orderBy?: ReferralWalletTransactionOrderByWithRelationInput | ReferralWalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralWalletTransactions.
     */
    cursor?: ReferralWalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralWalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralWalletTransactions.
     */
    skip?: number
    distinct?: ReferralWalletTransactionScalarFieldEnum | ReferralWalletTransactionScalarFieldEnum[]
  }

  /**
   * ReferralWalletTransaction create
   */
  export type ReferralWalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralWalletTransaction.
     */
    data: XOR<ReferralWalletTransactionCreateInput, ReferralWalletTransactionUncheckedCreateInput>
  }

  /**
   * ReferralWalletTransaction createMany
   */
  export type ReferralWalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralWalletTransactions.
     */
    data: ReferralWalletTransactionCreateManyInput | ReferralWalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralWalletTransaction createManyAndReturn
   */
  export type ReferralWalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralWalletTransactions.
     */
    data: ReferralWalletTransactionCreateManyInput | ReferralWalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralWalletTransaction update
   */
  export type ReferralWalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralWalletTransaction.
     */
    data: XOR<ReferralWalletTransactionUpdateInput, ReferralWalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which ReferralWalletTransaction to update.
     */
    where: ReferralWalletTransactionWhereUniqueInput
  }

  /**
   * ReferralWalletTransaction updateMany
   */
  export type ReferralWalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralWalletTransactions.
     */
    data: XOR<ReferralWalletTransactionUpdateManyMutationInput, ReferralWalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which ReferralWalletTransactions to update
     */
    where?: ReferralWalletTransactionWhereInput
  }

  /**
   * ReferralWalletTransaction upsert
   */
  export type ReferralWalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralWalletTransaction to update in case it exists.
     */
    where: ReferralWalletTransactionWhereUniqueInput
    /**
     * In case the ReferralWalletTransaction found by the `where` argument doesn't exist, create a new ReferralWalletTransaction with this data.
     */
    create: XOR<ReferralWalletTransactionCreateInput, ReferralWalletTransactionUncheckedCreateInput>
    /**
     * In case the ReferralWalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralWalletTransactionUpdateInput, ReferralWalletTransactionUncheckedUpdateInput>
  }

  /**
   * ReferralWalletTransaction delete
   */
  export type ReferralWalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
    /**
     * Filter which ReferralWalletTransaction to delete.
     */
    where: ReferralWalletTransactionWhereUniqueInput
  }

  /**
   * ReferralWalletTransaction deleteMany
   */
  export type ReferralWalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralWalletTransactions to delete
     */
    where?: ReferralWalletTransactionWhereInput
  }

  /**
   * ReferralWalletTransaction without action
   */
  export type ReferralWalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralWalletTransaction
     */
    select?: ReferralWalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralWalletTransactionInclude<ExtArgs> | null
  }


  /**
   * Model PrimeStatus
   */

  export type AggregatePrimeStatus = {
    _count: PrimeStatusCountAggregateOutputType | null
    _avg: PrimeStatusAvgAggregateOutputType | null
    _sum: PrimeStatusSumAggregateOutputType | null
    _min: PrimeStatusMinAggregateOutputType | null
    _max: PrimeStatusMaxAggregateOutputType | null
  }

  export type PrimeStatusAvgAggregateOutputType = {
    referralCount: number | null
    qualifiedReferralCount: number | null
  }

  export type PrimeStatusSumAggregateOutputType = {
    referralCount: number | null
    qualifiedReferralCount: number | null
  }

  export type PrimeStatusMinAggregateOutputType = {
    id: string | null
    address: string | null
    isPrime: boolean | null
    primeActivatedAt: Date | null
    referralCount: number | null
    qualifiedReferralCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrimeStatusMaxAggregateOutputType = {
    id: string | null
    address: string | null
    isPrime: boolean | null
    primeActivatedAt: Date | null
    referralCount: number | null
    qualifiedReferralCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrimeStatusCountAggregateOutputType = {
    id: number
    address: number
    isPrime: number
    primeActivatedAt: number
    referralCount: number
    qualifiedReferralCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrimeStatusAvgAggregateInputType = {
    referralCount?: true
    qualifiedReferralCount?: true
  }

  export type PrimeStatusSumAggregateInputType = {
    referralCount?: true
    qualifiedReferralCount?: true
  }

  export type PrimeStatusMinAggregateInputType = {
    id?: true
    address?: true
    isPrime?: true
    primeActivatedAt?: true
    referralCount?: true
    qualifiedReferralCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrimeStatusMaxAggregateInputType = {
    id?: true
    address?: true
    isPrime?: true
    primeActivatedAt?: true
    referralCount?: true
    qualifiedReferralCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrimeStatusCountAggregateInputType = {
    id?: true
    address?: true
    isPrime?: true
    primeActivatedAt?: true
    referralCount?: true
    qualifiedReferralCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrimeStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrimeStatus to aggregate.
     */
    where?: PrimeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrimeStatuses to fetch.
     */
    orderBy?: PrimeStatusOrderByWithRelationInput | PrimeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrimeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrimeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrimeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrimeStatuses
    **/
    _count?: true | PrimeStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrimeStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrimeStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrimeStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrimeStatusMaxAggregateInputType
  }

  export type GetPrimeStatusAggregateType<T extends PrimeStatusAggregateArgs> = {
        [P in keyof T & keyof AggregatePrimeStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrimeStatus[P]>
      : GetScalarType<T[P], AggregatePrimeStatus[P]>
  }




  export type PrimeStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrimeStatusWhereInput
    orderBy?: PrimeStatusOrderByWithAggregationInput | PrimeStatusOrderByWithAggregationInput[]
    by: PrimeStatusScalarFieldEnum[] | PrimeStatusScalarFieldEnum
    having?: PrimeStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrimeStatusCountAggregateInputType | true
    _avg?: PrimeStatusAvgAggregateInputType
    _sum?: PrimeStatusSumAggregateInputType
    _min?: PrimeStatusMinAggregateInputType
    _max?: PrimeStatusMaxAggregateInputType
  }

  export type PrimeStatusGroupByOutputType = {
    id: string
    address: string
    isPrime: boolean
    primeActivatedAt: Date | null
    referralCount: number
    qualifiedReferralCount: number
    createdAt: Date
    updatedAt: Date
    _count: PrimeStatusCountAggregateOutputType | null
    _avg: PrimeStatusAvgAggregateOutputType | null
    _sum: PrimeStatusSumAggregateOutputType | null
    _min: PrimeStatusMinAggregateOutputType | null
    _max: PrimeStatusMaxAggregateOutputType | null
  }

  type GetPrimeStatusGroupByPayload<T extends PrimeStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrimeStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrimeStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrimeStatusGroupByOutputType[P]>
            : GetScalarType<T[P], PrimeStatusGroupByOutputType[P]>
        }
      >
    >


  export type PrimeStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    isPrime?: boolean
    primeActivatedAt?: boolean
    referralCount?: boolean
    qualifiedReferralCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["primeStatus"]>

  export type PrimeStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    isPrime?: boolean
    primeActivatedAt?: boolean
    referralCount?: boolean
    qualifiedReferralCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["primeStatus"]>

  export type PrimeStatusSelectScalar = {
    id?: boolean
    address?: boolean
    isPrime?: boolean
    primeActivatedAt?: boolean
    referralCount?: boolean
    qualifiedReferralCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrimeStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrimeStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PrimeStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrimeStatus"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      isPrime: boolean
      primeActivatedAt: Date | null
      referralCount: number
      qualifiedReferralCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["primeStatus"]>
    composites: {}
  }

  type PrimeStatusGetPayload<S extends boolean | null | undefined | PrimeStatusDefaultArgs> = $Result.GetResult<Prisma.$PrimeStatusPayload, S>

  type PrimeStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrimeStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrimeStatusCountAggregateInputType | true
    }

  export interface PrimeStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrimeStatus'], meta: { name: 'PrimeStatus' } }
    /**
     * Find zero or one PrimeStatus that matches the filter.
     * @param {PrimeStatusFindUniqueArgs} args - Arguments to find a PrimeStatus
     * @example
     * // Get one PrimeStatus
     * const primeStatus = await prisma.primeStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrimeStatusFindUniqueArgs>(args: SelectSubset<T, PrimeStatusFindUniqueArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrimeStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrimeStatusFindUniqueOrThrowArgs} args - Arguments to find a PrimeStatus
     * @example
     * // Get one PrimeStatus
     * const primeStatus = await prisma.primeStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrimeStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, PrimeStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrimeStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrimeStatusFindFirstArgs} args - Arguments to find a PrimeStatus
     * @example
     * // Get one PrimeStatus
     * const primeStatus = await prisma.primeStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrimeStatusFindFirstArgs>(args?: SelectSubset<T, PrimeStatusFindFirstArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrimeStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrimeStatusFindFirstOrThrowArgs} args - Arguments to find a PrimeStatus
     * @example
     * // Get one PrimeStatus
     * const primeStatus = await prisma.primeStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrimeStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, PrimeStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrimeStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrimeStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrimeStatuses
     * const primeStatuses = await prisma.primeStatus.findMany()
     * 
     * // Get first 10 PrimeStatuses
     * const primeStatuses = await prisma.primeStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const primeStatusWithIdOnly = await prisma.primeStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrimeStatusFindManyArgs>(args?: SelectSubset<T, PrimeStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrimeStatus.
     * @param {PrimeStatusCreateArgs} args - Arguments to create a PrimeStatus.
     * @example
     * // Create one PrimeStatus
     * const PrimeStatus = await prisma.primeStatus.create({
     *   data: {
     *     // ... data to create a PrimeStatus
     *   }
     * })
     * 
     */
    create<T extends PrimeStatusCreateArgs>(args: SelectSubset<T, PrimeStatusCreateArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrimeStatuses.
     * @param {PrimeStatusCreateManyArgs} args - Arguments to create many PrimeStatuses.
     * @example
     * // Create many PrimeStatuses
     * const primeStatus = await prisma.primeStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrimeStatusCreateManyArgs>(args?: SelectSubset<T, PrimeStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrimeStatuses and returns the data saved in the database.
     * @param {PrimeStatusCreateManyAndReturnArgs} args - Arguments to create many PrimeStatuses.
     * @example
     * // Create many PrimeStatuses
     * const primeStatus = await prisma.primeStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrimeStatuses and only return the `id`
     * const primeStatusWithIdOnly = await prisma.primeStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrimeStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, PrimeStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrimeStatus.
     * @param {PrimeStatusDeleteArgs} args - Arguments to delete one PrimeStatus.
     * @example
     * // Delete one PrimeStatus
     * const PrimeStatus = await prisma.primeStatus.delete({
     *   where: {
     *     // ... filter to delete one PrimeStatus
     *   }
     * })
     * 
     */
    delete<T extends PrimeStatusDeleteArgs>(args: SelectSubset<T, PrimeStatusDeleteArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrimeStatus.
     * @param {PrimeStatusUpdateArgs} args - Arguments to update one PrimeStatus.
     * @example
     * // Update one PrimeStatus
     * const primeStatus = await prisma.primeStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrimeStatusUpdateArgs>(args: SelectSubset<T, PrimeStatusUpdateArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrimeStatuses.
     * @param {PrimeStatusDeleteManyArgs} args - Arguments to filter PrimeStatuses to delete.
     * @example
     * // Delete a few PrimeStatuses
     * const { count } = await prisma.primeStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrimeStatusDeleteManyArgs>(args?: SelectSubset<T, PrimeStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrimeStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrimeStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrimeStatuses
     * const primeStatus = await prisma.primeStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrimeStatusUpdateManyArgs>(args: SelectSubset<T, PrimeStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrimeStatus.
     * @param {PrimeStatusUpsertArgs} args - Arguments to update or create a PrimeStatus.
     * @example
     * // Update or create a PrimeStatus
     * const primeStatus = await prisma.primeStatus.upsert({
     *   create: {
     *     // ... data to create a PrimeStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrimeStatus we want to update
     *   }
     * })
     */
    upsert<T extends PrimeStatusUpsertArgs>(args: SelectSubset<T, PrimeStatusUpsertArgs<ExtArgs>>): Prisma__PrimeStatusClient<$Result.GetResult<Prisma.$PrimeStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrimeStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrimeStatusCountArgs} args - Arguments to filter PrimeStatuses to count.
     * @example
     * // Count the number of PrimeStatuses
     * const count = await prisma.primeStatus.count({
     *   where: {
     *     // ... the filter for the PrimeStatuses we want to count
     *   }
     * })
    **/
    count<T extends PrimeStatusCountArgs>(
      args?: Subset<T, PrimeStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrimeStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrimeStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrimeStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrimeStatusAggregateArgs>(args: Subset<T, PrimeStatusAggregateArgs>): Prisma.PrismaPromise<GetPrimeStatusAggregateType<T>>

    /**
     * Group by PrimeStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrimeStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrimeStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrimeStatusGroupByArgs['orderBy'] }
        : { orderBy?: PrimeStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrimeStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrimeStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrimeStatus model
   */
  readonly fields: PrimeStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrimeStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrimeStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrimeStatus model
   */ 
  interface PrimeStatusFieldRefs {
    readonly id: FieldRef<"PrimeStatus", 'String'>
    readonly address: FieldRef<"PrimeStatus", 'String'>
    readonly isPrime: FieldRef<"PrimeStatus", 'Boolean'>
    readonly primeActivatedAt: FieldRef<"PrimeStatus", 'DateTime'>
    readonly referralCount: FieldRef<"PrimeStatus", 'Int'>
    readonly qualifiedReferralCount: FieldRef<"PrimeStatus", 'Int'>
    readonly createdAt: FieldRef<"PrimeStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"PrimeStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrimeStatus findUnique
   */
  export type PrimeStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * Filter, which PrimeStatus to fetch.
     */
    where: PrimeStatusWhereUniqueInput
  }

  /**
   * PrimeStatus findUniqueOrThrow
   */
  export type PrimeStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * Filter, which PrimeStatus to fetch.
     */
    where: PrimeStatusWhereUniqueInput
  }

  /**
   * PrimeStatus findFirst
   */
  export type PrimeStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * Filter, which PrimeStatus to fetch.
     */
    where?: PrimeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrimeStatuses to fetch.
     */
    orderBy?: PrimeStatusOrderByWithRelationInput | PrimeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrimeStatuses.
     */
    cursor?: PrimeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrimeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrimeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrimeStatuses.
     */
    distinct?: PrimeStatusScalarFieldEnum | PrimeStatusScalarFieldEnum[]
  }

  /**
   * PrimeStatus findFirstOrThrow
   */
  export type PrimeStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * Filter, which PrimeStatus to fetch.
     */
    where?: PrimeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrimeStatuses to fetch.
     */
    orderBy?: PrimeStatusOrderByWithRelationInput | PrimeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrimeStatuses.
     */
    cursor?: PrimeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrimeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrimeStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrimeStatuses.
     */
    distinct?: PrimeStatusScalarFieldEnum | PrimeStatusScalarFieldEnum[]
  }

  /**
   * PrimeStatus findMany
   */
  export type PrimeStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * Filter, which PrimeStatuses to fetch.
     */
    where?: PrimeStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrimeStatuses to fetch.
     */
    orderBy?: PrimeStatusOrderByWithRelationInput | PrimeStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrimeStatuses.
     */
    cursor?: PrimeStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrimeStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrimeStatuses.
     */
    skip?: number
    distinct?: PrimeStatusScalarFieldEnum | PrimeStatusScalarFieldEnum[]
  }

  /**
   * PrimeStatus create
   */
  export type PrimeStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a PrimeStatus.
     */
    data: XOR<PrimeStatusCreateInput, PrimeStatusUncheckedCreateInput>
  }

  /**
   * PrimeStatus createMany
   */
  export type PrimeStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrimeStatuses.
     */
    data: PrimeStatusCreateManyInput | PrimeStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrimeStatus createManyAndReturn
   */
  export type PrimeStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrimeStatuses.
     */
    data: PrimeStatusCreateManyInput | PrimeStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrimeStatus update
   */
  export type PrimeStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a PrimeStatus.
     */
    data: XOR<PrimeStatusUpdateInput, PrimeStatusUncheckedUpdateInput>
    /**
     * Choose, which PrimeStatus to update.
     */
    where: PrimeStatusWhereUniqueInput
  }

  /**
   * PrimeStatus updateMany
   */
  export type PrimeStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrimeStatuses.
     */
    data: XOR<PrimeStatusUpdateManyMutationInput, PrimeStatusUncheckedUpdateManyInput>
    /**
     * Filter which PrimeStatuses to update
     */
    where?: PrimeStatusWhereInput
  }

  /**
   * PrimeStatus upsert
   */
  export type PrimeStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the PrimeStatus to update in case it exists.
     */
    where: PrimeStatusWhereUniqueInput
    /**
     * In case the PrimeStatus found by the `where` argument doesn't exist, create a new PrimeStatus with this data.
     */
    create: XOR<PrimeStatusCreateInput, PrimeStatusUncheckedCreateInput>
    /**
     * In case the PrimeStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrimeStatusUpdateInput, PrimeStatusUncheckedUpdateInput>
  }

  /**
   * PrimeStatus delete
   */
  export type PrimeStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
    /**
     * Filter which PrimeStatus to delete.
     */
    where: PrimeStatusWhereUniqueInput
  }

  /**
   * PrimeStatus deleteMany
   */
  export type PrimeStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrimeStatuses to delete
     */
    where?: PrimeStatusWhereInput
  }

  /**
   * PrimeStatus without action
   */
  export type PrimeStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrimeStatus
     */
    select?: PrimeStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrimeStatusInclude<ExtArgs> | null
  }


  /**
   * Model ReferralConfig
   */

  export type AggregateReferralConfig = {
    _count: ReferralConfigCountAggregateOutputType | null
    _avg: ReferralConfigAvgAggregateOutputType | null
    _sum: ReferralConfigSumAggregateOutputType | null
    _min: ReferralConfigMinAggregateOutputType | null
    _max: ReferralConfigMaxAggregateOutputType | null
  }

  export type ReferralConfigAvgAggregateOutputType = {
    commissionRate: Decimal | null
    primeUnlockThreshold: number | null
  }

  export type ReferralConfigSumAggregateOutputType = {
    commissionRate: Decimal | null
    primeUnlockThreshold: number | null
  }

  export type ReferralConfigMinAggregateOutputType = {
    id: string | null
    commissionRate: Decimal | null
    eligibleFeeTypes: string | null
    primeUnlockThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralConfigMaxAggregateOutputType = {
    id: string | null
    commissionRate: Decimal | null
    eligibleFeeTypes: string | null
    primeUnlockThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralConfigCountAggregateOutputType = {
    id: number
    commissionRate: number
    eligibleFeeTypes: number
    primeUnlockThreshold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralConfigAvgAggregateInputType = {
    commissionRate?: true
    primeUnlockThreshold?: true
  }

  export type ReferralConfigSumAggregateInputType = {
    commissionRate?: true
    primeUnlockThreshold?: true
  }

  export type ReferralConfigMinAggregateInputType = {
    id?: true
    commissionRate?: true
    eligibleFeeTypes?: true
    primeUnlockThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralConfigMaxAggregateInputType = {
    id?: true
    commissionRate?: true
    eligibleFeeTypes?: true
    primeUnlockThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralConfigCountAggregateInputType = {
    id?: true
    commissionRate?: true
    eligibleFeeTypes?: true
    primeUnlockThreshold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralConfig to aggregate.
     */
    where?: ReferralConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralConfigs to fetch.
     */
    orderBy?: ReferralConfigOrderByWithRelationInput | ReferralConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralConfigs
    **/
    _count?: true | ReferralConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralConfigMaxAggregateInputType
  }

  export type GetReferralConfigAggregateType<T extends ReferralConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralConfig[P]>
      : GetScalarType<T[P], AggregateReferralConfig[P]>
  }




  export type ReferralConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralConfigWhereInput
    orderBy?: ReferralConfigOrderByWithAggregationInput | ReferralConfigOrderByWithAggregationInput[]
    by: ReferralConfigScalarFieldEnum[] | ReferralConfigScalarFieldEnum
    having?: ReferralConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralConfigCountAggregateInputType | true
    _avg?: ReferralConfigAvgAggregateInputType
    _sum?: ReferralConfigSumAggregateInputType
    _min?: ReferralConfigMinAggregateInputType
    _max?: ReferralConfigMaxAggregateInputType
  }

  export type ReferralConfigGroupByOutputType = {
    id: string
    commissionRate: Decimal
    eligibleFeeTypes: string
    primeUnlockThreshold: number
    createdAt: Date
    updatedAt: Date
    _count: ReferralConfigCountAggregateOutputType | null
    _avg: ReferralConfigAvgAggregateOutputType | null
    _sum: ReferralConfigSumAggregateOutputType | null
    _min: ReferralConfigMinAggregateOutputType | null
    _max: ReferralConfigMaxAggregateOutputType | null
  }

  type GetReferralConfigGroupByPayload<T extends ReferralConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralConfigGroupByOutputType[P]>
        }
      >
    >


  export type ReferralConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commissionRate?: boolean
    eligibleFeeTypes?: boolean
    primeUnlockThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["referralConfig"]>

  export type ReferralConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commissionRate?: boolean
    eligibleFeeTypes?: boolean
    primeUnlockThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["referralConfig"]>

  export type ReferralConfigSelectScalar = {
    id?: boolean
    commissionRate?: boolean
    eligibleFeeTypes?: boolean
    primeUnlockThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ReferralConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * 20% default
       */
      commissionRate: Prisma.Decimal
      eligibleFeeTypes: string
      /**
       * qualified referrals needed
       */
      primeUnlockThreshold: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referralConfig"]>
    composites: {}
  }

  type ReferralConfigGetPayload<S extends boolean | null | undefined | ReferralConfigDefaultArgs> = $Result.GetResult<Prisma.$ReferralConfigPayload, S>

  type ReferralConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralConfigCountAggregateInputType | true
    }

  export interface ReferralConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralConfig'], meta: { name: 'ReferralConfig' } }
    /**
     * Find zero or one ReferralConfig that matches the filter.
     * @param {ReferralConfigFindUniqueArgs} args - Arguments to find a ReferralConfig
     * @example
     * // Get one ReferralConfig
     * const referralConfig = await prisma.referralConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralConfigFindUniqueArgs>(args: SelectSubset<T, ReferralConfigFindUniqueArgs<ExtArgs>>): Prisma__ReferralConfigClient<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralConfigFindUniqueOrThrowArgs} args - Arguments to find a ReferralConfig
     * @example
     * // Get one ReferralConfig
     * const referralConfig = await prisma.referralConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralConfigClient<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralConfigFindFirstArgs} args - Arguments to find a ReferralConfig
     * @example
     * // Get one ReferralConfig
     * const referralConfig = await prisma.referralConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralConfigFindFirstArgs>(args?: SelectSubset<T, ReferralConfigFindFirstArgs<ExtArgs>>): Prisma__ReferralConfigClient<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralConfigFindFirstOrThrowArgs} args - Arguments to find a ReferralConfig
     * @example
     * // Get one ReferralConfig
     * const referralConfig = await prisma.referralConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralConfigClient<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralConfigs
     * const referralConfigs = await prisma.referralConfig.findMany()
     * 
     * // Get first 10 ReferralConfigs
     * const referralConfigs = await prisma.referralConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralConfigWithIdOnly = await prisma.referralConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralConfigFindManyArgs>(args?: SelectSubset<T, ReferralConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralConfig.
     * @param {ReferralConfigCreateArgs} args - Arguments to create a ReferralConfig.
     * @example
     * // Create one ReferralConfig
     * const ReferralConfig = await prisma.referralConfig.create({
     *   data: {
     *     // ... data to create a ReferralConfig
     *   }
     * })
     * 
     */
    create<T extends ReferralConfigCreateArgs>(args: SelectSubset<T, ReferralConfigCreateArgs<ExtArgs>>): Prisma__ReferralConfigClient<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralConfigs.
     * @param {ReferralConfigCreateManyArgs} args - Arguments to create many ReferralConfigs.
     * @example
     * // Create many ReferralConfigs
     * const referralConfig = await prisma.referralConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralConfigCreateManyArgs>(args?: SelectSubset<T, ReferralConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralConfigs and returns the data saved in the database.
     * @param {ReferralConfigCreateManyAndReturnArgs} args - Arguments to create many ReferralConfigs.
     * @example
     * // Create many ReferralConfigs
     * const referralConfig = await prisma.referralConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralConfigs and only return the `id`
     * const referralConfigWithIdOnly = await prisma.referralConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralConfig.
     * @param {ReferralConfigDeleteArgs} args - Arguments to delete one ReferralConfig.
     * @example
     * // Delete one ReferralConfig
     * const ReferralConfig = await prisma.referralConfig.delete({
     *   where: {
     *     // ... filter to delete one ReferralConfig
     *   }
     * })
     * 
     */
    delete<T extends ReferralConfigDeleteArgs>(args: SelectSubset<T, ReferralConfigDeleteArgs<ExtArgs>>): Prisma__ReferralConfigClient<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralConfig.
     * @param {ReferralConfigUpdateArgs} args - Arguments to update one ReferralConfig.
     * @example
     * // Update one ReferralConfig
     * const referralConfig = await prisma.referralConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralConfigUpdateArgs>(args: SelectSubset<T, ReferralConfigUpdateArgs<ExtArgs>>): Prisma__ReferralConfigClient<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralConfigs.
     * @param {ReferralConfigDeleteManyArgs} args - Arguments to filter ReferralConfigs to delete.
     * @example
     * // Delete a few ReferralConfigs
     * const { count } = await prisma.referralConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralConfigDeleteManyArgs>(args?: SelectSubset<T, ReferralConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralConfigs
     * const referralConfig = await prisma.referralConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralConfigUpdateManyArgs>(args: SelectSubset<T, ReferralConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralConfig.
     * @param {ReferralConfigUpsertArgs} args - Arguments to update or create a ReferralConfig.
     * @example
     * // Update or create a ReferralConfig
     * const referralConfig = await prisma.referralConfig.upsert({
     *   create: {
     *     // ... data to create a ReferralConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralConfig we want to update
     *   }
     * })
     */
    upsert<T extends ReferralConfigUpsertArgs>(args: SelectSubset<T, ReferralConfigUpsertArgs<ExtArgs>>): Prisma__ReferralConfigClient<$Result.GetResult<Prisma.$ReferralConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralConfigCountArgs} args - Arguments to filter ReferralConfigs to count.
     * @example
     * // Count the number of ReferralConfigs
     * const count = await prisma.referralConfig.count({
     *   where: {
     *     // ... the filter for the ReferralConfigs we want to count
     *   }
     * })
    **/
    count<T extends ReferralConfigCountArgs>(
      args?: Subset<T, ReferralConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralConfigAggregateArgs>(args: Subset<T, ReferralConfigAggregateArgs>): Prisma.PrismaPromise<GetReferralConfigAggregateType<T>>

    /**
     * Group by ReferralConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralConfigGroupByArgs['orderBy'] }
        : { orderBy?: ReferralConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralConfig model
   */
  readonly fields: ReferralConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralConfig model
   */ 
  interface ReferralConfigFieldRefs {
    readonly id: FieldRef<"ReferralConfig", 'String'>
    readonly commissionRate: FieldRef<"ReferralConfig", 'Decimal'>
    readonly eligibleFeeTypes: FieldRef<"ReferralConfig", 'String'>
    readonly primeUnlockThreshold: FieldRef<"ReferralConfig", 'Int'>
    readonly createdAt: FieldRef<"ReferralConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"ReferralConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralConfig findUnique
   */
  export type ReferralConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * Filter, which ReferralConfig to fetch.
     */
    where: ReferralConfigWhereUniqueInput
  }

  /**
   * ReferralConfig findUniqueOrThrow
   */
  export type ReferralConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * Filter, which ReferralConfig to fetch.
     */
    where: ReferralConfigWhereUniqueInput
  }

  /**
   * ReferralConfig findFirst
   */
  export type ReferralConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * Filter, which ReferralConfig to fetch.
     */
    where?: ReferralConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralConfigs to fetch.
     */
    orderBy?: ReferralConfigOrderByWithRelationInput | ReferralConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralConfigs.
     */
    cursor?: ReferralConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralConfigs.
     */
    distinct?: ReferralConfigScalarFieldEnum | ReferralConfigScalarFieldEnum[]
  }

  /**
   * ReferralConfig findFirstOrThrow
   */
  export type ReferralConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * Filter, which ReferralConfig to fetch.
     */
    where?: ReferralConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralConfigs to fetch.
     */
    orderBy?: ReferralConfigOrderByWithRelationInput | ReferralConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralConfigs.
     */
    cursor?: ReferralConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralConfigs.
     */
    distinct?: ReferralConfigScalarFieldEnum | ReferralConfigScalarFieldEnum[]
  }

  /**
   * ReferralConfig findMany
   */
  export type ReferralConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * Filter, which ReferralConfigs to fetch.
     */
    where?: ReferralConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralConfigs to fetch.
     */
    orderBy?: ReferralConfigOrderByWithRelationInput | ReferralConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralConfigs.
     */
    cursor?: ReferralConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralConfigs.
     */
    skip?: number
    distinct?: ReferralConfigScalarFieldEnum | ReferralConfigScalarFieldEnum[]
  }

  /**
   * ReferralConfig create
   */
  export type ReferralConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a ReferralConfig.
     */
    data: XOR<ReferralConfigCreateInput, ReferralConfigUncheckedCreateInput>
  }

  /**
   * ReferralConfig createMany
   */
  export type ReferralConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralConfigs.
     */
    data: ReferralConfigCreateManyInput | ReferralConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralConfig createManyAndReturn
   */
  export type ReferralConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralConfigs.
     */
    data: ReferralConfigCreateManyInput | ReferralConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralConfig update
   */
  export type ReferralConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a ReferralConfig.
     */
    data: XOR<ReferralConfigUpdateInput, ReferralConfigUncheckedUpdateInput>
    /**
     * Choose, which ReferralConfig to update.
     */
    where: ReferralConfigWhereUniqueInput
  }

  /**
   * ReferralConfig updateMany
   */
  export type ReferralConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralConfigs.
     */
    data: XOR<ReferralConfigUpdateManyMutationInput, ReferralConfigUncheckedUpdateManyInput>
    /**
     * Filter which ReferralConfigs to update
     */
    where?: ReferralConfigWhereInput
  }

  /**
   * ReferralConfig upsert
   */
  export type ReferralConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the ReferralConfig to update in case it exists.
     */
    where: ReferralConfigWhereUniqueInput
    /**
     * In case the ReferralConfig found by the `where` argument doesn't exist, create a new ReferralConfig with this data.
     */
    create: XOR<ReferralConfigCreateInput, ReferralConfigUncheckedCreateInput>
    /**
     * In case the ReferralConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralConfigUpdateInput, ReferralConfigUncheckedUpdateInput>
  }

  /**
   * ReferralConfig delete
   */
  export type ReferralConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
    /**
     * Filter which ReferralConfig to delete.
     */
    where: ReferralConfigWhereUniqueInput
  }

  /**
   * ReferralConfig deleteMany
   */
  export type ReferralConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralConfigs to delete
     */
    where?: ReferralConfigWhereInput
  }

  /**
   * ReferralConfig without action
   */
  export type ReferralConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralConfig
     */
    select?: ReferralConfigSelect<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    price: Decimal | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
  }

  export type OfferSumAggregateOutputType = {
    price: Decimal | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
  }

  export type OfferMinAggregateOutputType = {
    id: string | null
    creator: string | null
    type: string | null
    token: string | null
    currency: string | null
    priceType: string | null
    price: Decimal | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    terms: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: string | null
    creator: string | null
    type: string | null
    token: string | null
    currency: string | null
    priceType: string | null
    price: Decimal | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    terms: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    creator: number
    type: number
    token: number
    currency: number
    priceType: number
    price: number
    minAmount: number
    maxAmount: number
    paymentMethods: number
    terms: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    price?: true
    minAmount?: true
    maxAmount?: true
  }

  export type OfferSumAggregateInputType = {
    price?: true
    minAmount?: true
    maxAmount?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    creator?: true
    type?: true
    token?: true
    currency?: true
    priceType?: true
    price?: true
    minAmount?: true
    maxAmount?: true
    terms?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    creator?: true
    type?: true
    token?: true
    currency?: true
    priceType?: true
    price?: true
    minAmount?: true
    maxAmount?: true
    terms?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    creator?: true
    type?: true
    token?: true
    currency?: true
    priceType?: true
    price?: true
    minAmount?: true
    maxAmount?: true
    paymentMethods?: true
    terms?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: string
    creator: string
    type: string
    token: string
    currency: string
    priceType: string
    price: Decimal
    minAmount: Decimal
    maxAmount: Decimal
    paymentMethods: string[]
    terms: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creator?: boolean
    type?: boolean
    token?: boolean
    currency?: boolean
    priceType?: boolean
    price?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    paymentMethods?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creator?: boolean
    type?: boolean
    token?: boolean
    currency?: boolean
    priceType?: boolean
    price?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    paymentMethods?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    creator?: boolean
    type?: boolean
    token?: boolean
    currency?: boolean
    priceType?: boolean
    price?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    paymentMethods?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creator: string
      /**
       * BUY | SELL
       */
      type: string
      /**
       * e.g. USDT, ETH
       */
      token: string
      /**
       * e.g. USD, EUR
       */
      currency: string
      /**
       * FIXED | MARKET
       */
      priceType: string
      price: Prisma.Decimal
      minAmount: Prisma.Decimal
      maxAmount: Prisma.Decimal
      paymentMethods: string[]
      terms: string | null
      /**
       * ACTIVE | PAUSED | CLOSED
       */
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */ 
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'String'>
    readonly creator: FieldRef<"Offer", 'String'>
    readonly type: FieldRef<"Offer", 'String'>
    readonly token: FieldRef<"Offer", 'String'>
    readonly currency: FieldRef<"Offer", 'String'>
    readonly priceType: FieldRef<"Offer", 'String'>
    readonly price: FieldRef<"Offer", 'Decimal'>
    readonly minAmount: FieldRef<"Offer", 'Decimal'>
    readonly maxAmount: FieldRef<"Offer", 'Decimal'>
    readonly paymentMethods: FieldRef<"Offer", 'String[]'>
    readonly terms: FieldRef<"Offer", 'String'>
    readonly status: FieldRef<"Offer", 'String'>
    readonly createdAt: FieldRef<"Offer", 'DateTime'>
    readonly updatedAt: FieldRef<"Offer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    address: 'address',
    displayName: 'displayName',
    bio: 'bio',
    paymentMethods: 'paymentMethods',
    createdAt: 'createdAt',
    lastLoginAt: 'lastLoginAt',
    reputationScore: 'reputationScore',
    successfulTrades: 'successfulTrades',
    totalVolume: 'totalVolume'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TradeReviewScalarFieldEnum: {
    id: 'id',
    tradeId: 'tradeId',
    reviewerAddress: 'reviewerAddress',
    reviewedAddress: 'reviewedAddress',
    rating: 'rating',
    reviewText: 'reviewText',
    reviewTags: 'reviewTags',
    tradeRole: 'tradeRole',
    createdAt: 'createdAt'
  };

  export type TradeReviewScalarFieldEnum = (typeof TradeReviewScalarFieldEnum)[keyof typeof TradeReviewScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    address: 'address',
    role: 'role',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const EscrowScalarFieldEnum: {
    escrowId: 'escrowId',
    chainId: 'chainId',
    contractAddress: 'contractAddress',
    tokenKey: 'tokenKey',
    amount: 'amount',
    feeAmount: 'feeAmount',
    sellerBond: 'sellerBond',
    buyerBond: 'buyerBond',
    state: 'state',
    seller: 'seller',
    buyer: 'buyer',
    createdAtBlock: 'createdAtBlock',
    updatedAtBlock: 'updatedAtBlock',
    txHashCreate: 'txHashCreate',
    txHashLast: 'txHashLast',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EscrowScalarFieldEnum = (typeof EscrowScalarFieldEnum)[keyof typeof EscrowScalarFieldEnum]


  export const EscrowTimelineScalarFieldEnum: {
    id: 'id',
    escrowId: 'escrowId',
    chainId: 'chainId',
    eventName: 'eventName',
    stateAfter: 'stateAfter',
    txHash: 'txHash',
    blockNumber: 'blockNumber',
    logIndex: 'logIndex',
    timestamp: 'timestamp',
    payload: 'payload'
  };

  export type EscrowTimelineScalarFieldEnum = (typeof EscrowTimelineScalarFieldEnum)[keyof typeof EscrowTimelineScalarFieldEnum]


  export const EscrowMessageScalarFieldEnum: {
    id: 'id',
    escrowId: 'escrowId',
    sender: 'sender',
    text: 'text',
    attachment: 'attachment',
    hash: 'hash',
    createdAt: 'createdAt',
    editedAt: 'editedAt'
  };

  export type EscrowMessageScalarFieldEnum = (typeof EscrowMessageScalarFieldEnum)[keyof typeof EscrowMessageScalarFieldEnum]


  export const EscrowPaymentInstructionScalarFieldEnum: {
    escrowId: 'escrowId',
    seller: 'seller',
    content: 'content',
    updatedAt: 'updatedAt'
  };

  export type EscrowPaymentInstructionScalarFieldEnum = (typeof EscrowPaymentInstructionScalarFieldEnum)[keyof typeof EscrowPaymentInstructionScalarFieldEnum]


  export const EscrowFiatStatusScalarFieldEnum: {
    id: 'id',
    escrowId: 'escrowId',
    actor: 'actor',
    status: 'status',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type EscrowFiatStatusScalarFieldEnum = (typeof EscrowFiatStatusScalarFieldEnum)[keyof typeof EscrowFiatStatusScalarFieldEnum]


  export const EvidenceItemScalarFieldEnum: {
    id: 'id',
    escrowId: 'escrowId',
    uploader: 'uploader',
    uri: 'uri',
    sha256: 'sha256',
    mime: 'mime',
    size: 'size',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type EvidenceItemScalarFieldEnum = (typeof EvidenceItemScalarFieldEnum)[keyof typeof EvidenceItemScalarFieldEnum]


  export const DisputeScalarFieldEnum: {
    escrowId: 'escrowId',
    openedBy: 'openedBy',
    reasonCode: 'reasonCode',
    summary: 'summary',
    status: 'status',
    arbitratorAssigned: 'arbitratorAssigned',
    outcome: 'outcome',
    ref: 'ref',
    escalationLevel: 'escalationLevel',
    aiAnalysis: 'aiAnalysis',
    tier2Analysis: 'tier2Analysis',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisputeScalarFieldEnum = (typeof DisputeScalarFieldEnum)[keyof typeof DisputeScalarFieldEnum]


  export const IndexerCheckpointScalarFieldEnum: {
    chainId: 'chainId',
    contractAddress: 'contractAddress',
    lastSyncedBlock: 'lastSyncedBlock',
    updatedAt: 'updatedAt'
  };

  export type IndexerCheckpointScalarFieldEnum = (typeof IndexerCheckpointScalarFieldEnum)[keyof typeof IndexerCheckpointScalarFieldEnum]


  export const TokenRegistryScalarFieldEnum: {
    chainId: 'chainId',
    tokenKey: 'tokenKey',
    symbol: 'symbol',
    decimals: 'decimals',
    name: 'name',
    enabled: 'enabled'
  };

  export type TokenRegistryScalarFieldEnum = (typeof TokenRegistryScalarFieldEnum)[keyof typeof TokenRegistryScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorAddress: 'actorAddress',
    action: 'action',
    target: 'target',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NonceScalarFieldEnum: {
    id: 'id',
    address: 'address',
    value: 'value',
    chainId: 'chainId',
    domain: 'domain',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type NonceScalarFieldEnum = (typeof NonceScalarFieldEnum)[keyof typeof NonceScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    address: 'address',
    webhookUrl: 'webhookUrl',
    telegramId: 'telegramId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    address: 'address',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    link: 'link',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ReferralCodeScalarFieldEnum: {
    id: 'id',
    address: 'address',
    code: 'code',
    referralLink: 'referralLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralCodeScalarFieldEnum = (typeof ReferralCodeScalarFieldEnum)[keyof typeof ReferralCodeScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerAddress: 'referrerAddress',
    refereeAddress: 'refereeAddress',
    referralCodeId: 'referralCodeId',
    qualified: 'qualified',
    qualifiedAt: 'qualifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const CommissionLedgerScalarFieldEnum: {
    id: 'id',
    referralId: 'referralId',
    feeAmount: 'feeAmount',
    commissionRate: 'commissionRate',
    commissionAmount: 'commissionAmount',
    feeType: 'feeType',
    createdAt: 'createdAt'
  };

  export type CommissionLedgerScalarFieldEnum = (typeof CommissionLedgerScalarFieldEnum)[keyof typeof CommissionLedgerScalarFieldEnum]


  export const ReferralWalletScalarFieldEnum: {
    id: 'id',
    address: 'address',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralWalletScalarFieldEnum = (typeof ReferralWalletScalarFieldEnum)[keyof typeof ReferralWalletScalarFieldEnum]


  export const ReferralWalletTransactionScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    amount: 'amount',
    type: 'type',
    status: 'status',
    targetAddress: 'targetAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralWalletTransactionScalarFieldEnum = (typeof ReferralWalletTransactionScalarFieldEnum)[keyof typeof ReferralWalletTransactionScalarFieldEnum]


  export const PrimeStatusScalarFieldEnum: {
    id: 'id',
    address: 'address',
    isPrime: 'isPrime',
    primeActivatedAt: 'primeActivatedAt',
    referralCount: 'referralCount',
    qualifiedReferralCount: 'qualifiedReferralCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrimeStatusScalarFieldEnum = (typeof PrimeStatusScalarFieldEnum)[keyof typeof PrimeStatusScalarFieldEnum]


  export const ReferralConfigScalarFieldEnum: {
    id: 'id',
    commissionRate: 'commissionRate',
    eligibleFeeTypes: 'eligibleFeeTypes',
    primeUnlockThreshold: 'primeUnlockThreshold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralConfigScalarFieldEnum = (typeof ReferralConfigScalarFieldEnum)[keyof typeof ReferralConfigScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    creator: 'creator',
    type: 'type',
    token: 'token',
    currency: 'currency',
    priceType: 'priceType',
    price: 'price',
    minAmount: 'minAmount',
    maxAmount: 'maxAmount',
    paymentMethods: 'paymentMethods',
    terms: 'terms',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    address?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    paymentMethods?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    reputationScore?: IntFilter<"User"> | number
    successfulTrades?: IntFilter<"User"> | number
    totalVolume?: DecimalFilter<"User"> | Decimal | DecimalJsLike | number | string
    roles?: RoleListRelationFilter
    notificationPreference?: XOR<NotificationPreferenceNullableRelationFilter, NotificationPreferenceWhereInput> | null
    referralCodes?: ReferralCodeListRelationFilter
    referralsMade?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
    referralWallet?: XOR<ReferralWalletNullableRelationFilter, ReferralWalletWhereInput> | null
    prime?: XOR<PrimeStatusNullableRelationFilter, PrimeStatusWhereInput> | null
    notifications?: NotificationListRelationFilter
    reviewsGiven?: TradeReviewListRelationFilter
    reviewsReceived?: TradeReviewListRelationFilter
    offers?: OfferListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    address?: SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    paymentMethods?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    reputationScore?: SortOrder
    successfulTrades?: SortOrder
    totalVolume?: SortOrder
    roles?: RoleOrderByRelationAggregateInput
    notificationPreference?: NotificationPreferenceOrderByWithRelationInput
    referralCodes?: ReferralCodeOrderByRelationAggregateInput
    referralsMade?: ReferralOrderByRelationAggregateInput
    referralsReceived?: ReferralOrderByRelationAggregateInput
    referralWallet?: ReferralWalletOrderByWithRelationInput
    prime?: PrimeStatusOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    reviewsGiven?: TradeReviewOrderByRelationAggregateInput
    reviewsReceived?: TradeReviewOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    address?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    displayName?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    paymentMethods?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    reputationScore?: IntFilter<"User"> | number
    successfulTrades?: IntFilter<"User"> | number
    totalVolume?: DecimalFilter<"User"> | Decimal | DecimalJsLike | number | string
    roles?: RoleListRelationFilter
    notificationPreference?: XOR<NotificationPreferenceNullableRelationFilter, NotificationPreferenceWhereInput> | null
    referralCodes?: ReferralCodeListRelationFilter
    referralsMade?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
    referralWallet?: XOR<ReferralWalletNullableRelationFilter, ReferralWalletWhereInput> | null
    prime?: XOR<PrimeStatusNullableRelationFilter, PrimeStatusWhereInput> | null
    notifications?: NotificationListRelationFilter
    reviewsGiven?: TradeReviewListRelationFilter
    reviewsReceived?: TradeReviewListRelationFilter
    offers?: OfferListRelationFilter
  }, "address">

  export type UserOrderByWithAggregationInput = {
    address?: SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    paymentMethods?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    reputationScore?: SortOrder
    successfulTrades?: SortOrder
    totalVolume?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    address?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    paymentMethods?: StringNullableListFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    reputationScore?: IntWithAggregatesFilter<"User"> | number
    successfulTrades?: IntWithAggregatesFilter<"User"> | number
    totalVolume?: DecimalWithAggregatesFilter<"User"> | Decimal | DecimalJsLike | number | string
  }

  export type TradeReviewWhereInput = {
    AND?: TradeReviewWhereInput | TradeReviewWhereInput[]
    OR?: TradeReviewWhereInput[]
    NOT?: TradeReviewWhereInput | TradeReviewWhereInput[]
    id?: StringFilter<"TradeReview"> | string
    tradeId?: BytesFilter<"TradeReview"> | Buffer
    reviewerAddress?: StringFilter<"TradeReview"> | string
    reviewedAddress?: StringFilter<"TradeReview"> | string
    rating?: IntFilter<"TradeReview"> | number
    reviewText?: StringNullableFilter<"TradeReview"> | string | null
    reviewTags?: StringNullableListFilter<"TradeReview">
    tradeRole?: StringFilter<"TradeReview"> | string
    createdAt?: DateTimeFilter<"TradeReview"> | Date | string
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
    reviewed?: XOR<UserRelationFilter, UserWhereInput>
    escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }

  export type TradeReviewOrderByWithRelationInput = {
    id?: SortOrder
    tradeId?: SortOrder
    reviewerAddress?: SortOrder
    reviewedAddress?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrderInput | SortOrder
    reviewTags?: SortOrder
    tradeRole?: SortOrder
    createdAt?: SortOrder
    reviewer?: UserOrderByWithRelationInput
    reviewed?: UserOrderByWithRelationInput
    escrow?: EscrowOrderByWithRelationInput
  }

  export type TradeReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tradeId_reviewerAddress?: TradeReviewTradeIdReviewerAddressCompoundUniqueInput
    AND?: TradeReviewWhereInput | TradeReviewWhereInput[]
    OR?: TradeReviewWhereInput[]
    NOT?: TradeReviewWhereInput | TradeReviewWhereInput[]
    tradeId?: BytesFilter<"TradeReview"> | Buffer
    reviewerAddress?: StringFilter<"TradeReview"> | string
    reviewedAddress?: StringFilter<"TradeReview"> | string
    rating?: IntFilter<"TradeReview"> | number
    reviewText?: StringNullableFilter<"TradeReview"> | string | null
    reviewTags?: StringNullableListFilter<"TradeReview">
    tradeRole?: StringFilter<"TradeReview"> | string
    createdAt?: DateTimeFilter<"TradeReview"> | Date | string
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
    reviewed?: XOR<UserRelationFilter, UserWhereInput>
    escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }, "id" | "tradeId_reviewerAddress">

  export type TradeReviewOrderByWithAggregationInput = {
    id?: SortOrder
    tradeId?: SortOrder
    reviewerAddress?: SortOrder
    reviewedAddress?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrderInput | SortOrder
    reviewTags?: SortOrder
    tradeRole?: SortOrder
    createdAt?: SortOrder
    _count?: TradeReviewCountOrderByAggregateInput
    _avg?: TradeReviewAvgOrderByAggregateInput
    _max?: TradeReviewMaxOrderByAggregateInput
    _min?: TradeReviewMinOrderByAggregateInput
    _sum?: TradeReviewSumOrderByAggregateInput
  }

  export type TradeReviewScalarWhereWithAggregatesInput = {
    AND?: TradeReviewScalarWhereWithAggregatesInput | TradeReviewScalarWhereWithAggregatesInput[]
    OR?: TradeReviewScalarWhereWithAggregatesInput[]
    NOT?: TradeReviewScalarWhereWithAggregatesInput | TradeReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradeReview"> | string
    tradeId?: BytesWithAggregatesFilter<"TradeReview"> | Buffer
    reviewerAddress?: StringWithAggregatesFilter<"TradeReview"> | string
    reviewedAddress?: StringWithAggregatesFilter<"TradeReview"> | string
    rating?: IntWithAggregatesFilter<"TradeReview"> | number
    reviewText?: StringNullableWithAggregatesFilter<"TradeReview"> | string | null
    reviewTags?: StringNullableListFilter<"TradeReview">
    tradeRole?: StringWithAggregatesFilter<"TradeReview"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TradeReview"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    address?: StringFilter<"Role"> | string
    role?: StringFilter<"Role"> | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address_role?: RoleAddressRoleCompoundUniqueInput
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    address?: StringFilter<"Role"> | string
    role?: StringFilter<"Role"> | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "address_role">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    address?: StringWithAggregatesFilter<"Role"> | string
    role?: StringWithAggregatesFilter<"Role"> | string
    createdBy?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type EscrowWhereInput = {
    AND?: EscrowWhereInput | EscrowWhereInput[]
    OR?: EscrowWhereInput[]
    NOT?: EscrowWhereInput | EscrowWhereInput[]
    escrowId?: BytesFilter<"Escrow"> | Buffer
    chainId?: IntFilter<"Escrow"> | number
    contractAddress?: StringFilter<"Escrow"> | string
    tokenKey?: StringFilter<"Escrow"> | string
    amount?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    state?: StringFilter<"Escrow"> | string
    seller?: StringFilter<"Escrow"> | string
    buyer?: StringNullableFilter<"Escrow"> | string | null
    createdAtBlock?: BigIntFilter<"Escrow"> | bigint | number
    updatedAtBlock?: BigIntFilter<"Escrow"> | bigint | number
    txHashCreate?: StringNullableFilter<"Escrow"> | string | null
    txHashLast?: StringNullableFilter<"Escrow"> | string | null
    createdAt?: DateTimeFilter<"Escrow"> | Date | string
    updatedAt?: DateTimeFilter<"Escrow"> | Date | string
    timeline?: EscrowTimelineListRelationFilter
    messages?: EscrowMessageListRelationFilter
    paymentInstruction?: XOR<EscrowPaymentInstructionNullableRelationFilter, EscrowPaymentInstructionWhereInput> | null
    fiatStatuses?: EscrowFiatStatusListRelationFilter
    evidence?: EvidenceItemListRelationFilter
    dispute?: XOR<DisputeNullableRelationFilter, DisputeWhereInput> | null
    reviews?: TradeReviewListRelationFilter
  }

  export type EscrowOrderByWithRelationInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrderInput | SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrderInput | SortOrder
    txHashLast?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeline?: EscrowTimelineOrderByRelationAggregateInput
    messages?: EscrowMessageOrderByRelationAggregateInput
    paymentInstruction?: EscrowPaymentInstructionOrderByWithRelationInput
    fiatStatuses?: EscrowFiatStatusOrderByRelationAggregateInput
    evidence?: EvidenceItemOrderByRelationAggregateInput
    dispute?: DisputeOrderByWithRelationInput
    reviews?: TradeReviewOrderByRelationAggregateInput
  }

  export type EscrowWhereUniqueInput = Prisma.AtLeast<{
    escrowId?: Buffer
    AND?: EscrowWhereInput | EscrowWhereInput[]
    OR?: EscrowWhereInput[]
    NOT?: EscrowWhereInput | EscrowWhereInput[]
    chainId?: IntFilter<"Escrow"> | number
    contractAddress?: StringFilter<"Escrow"> | string
    tokenKey?: StringFilter<"Escrow"> | string
    amount?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    state?: StringFilter<"Escrow"> | string
    seller?: StringFilter<"Escrow"> | string
    buyer?: StringNullableFilter<"Escrow"> | string | null
    createdAtBlock?: BigIntFilter<"Escrow"> | bigint | number
    updatedAtBlock?: BigIntFilter<"Escrow"> | bigint | number
    txHashCreate?: StringNullableFilter<"Escrow"> | string | null
    txHashLast?: StringNullableFilter<"Escrow"> | string | null
    createdAt?: DateTimeFilter<"Escrow"> | Date | string
    updatedAt?: DateTimeFilter<"Escrow"> | Date | string
    timeline?: EscrowTimelineListRelationFilter
    messages?: EscrowMessageListRelationFilter
    paymentInstruction?: XOR<EscrowPaymentInstructionNullableRelationFilter, EscrowPaymentInstructionWhereInput> | null
    fiatStatuses?: EscrowFiatStatusListRelationFilter
    evidence?: EvidenceItemListRelationFilter
    dispute?: XOR<DisputeNullableRelationFilter, DisputeWhereInput> | null
    reviews?: TradeReviewListRelationFilter
  }, "escrowId">

  export type EscrowOrderByWithAggregationInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrderInput | SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrderInput | SortOrder
    txHashLast?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EscrowCountOrderByAggregateInput
    _avg?: EscrowAvgOrderByAggregateInput
    _max?: EscrowMaxOrderByAggregateInput
    _min?: EscrowMinOrderByAggregateInput
    _sum?: EscrowSumOrderByAggregateInput
  }

  export type EscrowScalarWhereWithAggregatesInput = {
    AND?: EscrowScalarWhereWithAggregatesInput | EscrowScalarWhereWithAggregatesInput[]
    OR?: EscrowScalarWhereWithAggregatesInput[]
    NOT?: EscrowScalarWhereWithAggregatesInput | EscrowScalarWhereWithAggregatesInput[]
    escrowId?: BytesWithAggregatesFilter<"Escrow"> | Buffer
    chainId?: IntWithAggregatesFilter<"Escrow"> | number
    contractAddress?: StringWithAggregatesFilter<"Escrow"> | string
    tokenKey?: StringWithAggregatesFilter<"Escrow"> | string
    amount?: DecimalWithAggregatesFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalWithAggregatesFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalWithAggregatesFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalWithAggregatesFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    state?: StringWithAggregatesFilter<"Escrow"> | string
    seller?: StringWithAggregatesFilter<"Escrow"> | string
    buyer?: StringNullableWithAggregatesFilter<"Escrow"> | string | null
    createdAtBlock?: BigIntWithAggregatesFilter<"Escrow"> | bigint | number
    updatedAtBlock?: BigIntWithAggregatesFilter<"Escrow"> | bigint | number
    txHashCreate?: StringNullableWithAggregatesFilter<"Escrow"> | string | null
    txHashLast?: StringNullableWithAggregatesFilter<"Escrow"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Escrow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Escrow"> | Date | string
  }

  export type EscrowTimelineWhereInput = {
    AND?: EscrowTimelineWhereInput | EscrowTimelineWhereInput[]
    OR?: EscrowTimelineWhereInput[]
    NOT?: EscrowTimelineWhereInput | EscrowTimelineWhereInput[]
    id?: BigIntFilter<"EscrowTimeline"> | bigint | number
    escrowId?: BytesFilter<"EscrowTimeline"> | Buffer
    chainId?: IntFilter<"EscrowTimeline"> | number
    eventName?: StringFilter<"EscrowTimeline"> | string
    stateAfter?: StringFilter<"EscrowTimeline"> | string
    txHash?: StringFilter<"EscrowTimeline"> | string
    blockNumber?: BigIntFilter<"EscrowTimeline"> | bigint | number
    logIndex?: IntFilter<"EscrowTimeline"> | number
    timestamp?: DateTimeFilter<"EscrowTimeline"> | Date | string
    payload?: JsonFilter<"EscrowTimeline">
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }

  export type EscrowTimelineOrderByWithRelationInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
    payload?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EscrowTimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    escrowId_blockNumber_logIndex?: EscrowTimelineEscrowIdBlockNumberLogIndexCompoundUniqueInput
    AND?: EscrowTimelineWhereInput | EscrowTimelineWhereInput[]
    OR?: EscrowTimelineWhereInput[]
    NOT?: EscrowTimelineWhereInput | EscrowTimelineWhereInput[]
    escrowId?: BytesFilter<"EscrowTimeline"> | Buffer
    chainId?: IntFilter<"EscrowTimeline"> | number
    eventName?: StringFilter<"EscrowTimeline"> | string
    stateAfter?: StringFilter<"EscrowTimeline"> | string
    txHash?: StringFilter<"EscrowTimeline"> | string
    blockNumber?: BigIntFilter<"EscrowTimeline"> | bigint | number
    logIndex?: IntFilter<"EscrowTimeline"> | number
    timestamp?: DateTimeFilter<"EscrowTimeline"> | Date | string
    payload?: JsonFilter<"EscrowTimeline">
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }, "id" | "escrowId_blockNumber_logIndex">

  export type EscrowTimelineOrderByWithAggregationInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
    payload?: SortOrder
    _count?: EscrowTimelineCountOrderByAggregateInput
    _avg?: EscrowTimelineAvgOrderByAggregateInput
    _max?: EscrowTimelineMaxOrderByAggregateInput
    _min?: EscrowTimelineMinOrderByAggregateInput
    _sum?: EscrowTimelineSumOrderByAggregateInput
  }

  export type EscrowTimelineScalarWhereWithAggregatesInput = {
    AND?: EscrowTimelineScalarWhereWithAggregatesInput | EscrowTimelineScalarWhereWithAggregatesInput[]
    OR?: EscrowTimelineScalarWhereWithAggregatesInput[]
    NOT?: EscrowTimelineScalarWhereWithAggregatesInput | EscrowTimelineScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"EscrowTimeline"> | bigint | number
    escrowId?: BytesWithAggregatesFilter<"EscrowTimeline"> | Buffer
    chainId?: IntWithAggregatesFilter<"EscrowTimeline"> | number
    eventName?: StringWithAggregatesFilter<"EscrowTimeline"> | string
    stateAfter?: StringWithAggregatesFilter<"EscrowTimeline"> | string
    txHash?: StringWithAggregatesFilter<"EscrowTimeline"> | string
    blockNumber?: BigIntWithAggregatesFilter<"EscrowTimeline"> | bigint | number
    logIndex?: IntWithAggregatesFilter<"EscrowTimeline"> | number
    timestamp?: DateTimeWithAggregatesFilter<"EscrowTimeline"> | Date | string
    payload?: JsonWithAggregatesFilter<"EscrowTimeline">
  }

  export type EscrowMessageWhereInput = {
    AND?: EscrowMessageWhereInput | EscrowMessageWhereInput[]
    OR?: EscrowMessageWhereInput[]
    NOT?: EscrowMessageWhereInput | EscrowMessageWhereInput[]
    id?: StringFilter<"EscrowMessage"> | string
    escrowId?: BytesNullableFilter<"EscrowMessage"> | Buffer | null
    sender?: StringFilter<"EscrowMessage"> | string
    text?: StringFilter<"EscrowMessage"> | string
    attachment?: StringNullableFilter<"EscrowMessage"> | string | null
    hash?: StringNullableFilter<"EscrowMessage"> | string | null
    createdAt?: DateTimeFilter<"EscrowMessage"> | Date | string
    editedAt?: DateTimeNullableFilter<"EscrowMessage"> | Date | string | null
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }

  export type EscrowMessageOrderByWithRelationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EscrowMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EscrowMessageWhereInput | EscrowMessageWhereInput[]
    OR?: EscrowMessageWhereInput[]
    NOT?: EscrowMessageWhereInput | EscrowMessageWhereInput[]
    escrowId?: BytesNullableFilter<"EscrowMessage"> | Buffer | null
    sender?: StringFilter<"EscrowMessage"> | string
    text?: StringFilter<"EscrowMessage"> | string
    attachment?: StringNullableFilter<"EscrowMessage"> | string | null
    hash?: StringNullableFilter<"EscrowMessage"> | string | null
    createdAt?: DateTimeFilter<"EscrowMessage"> | Date | string
    editedAt?: DateTimeNullableFilter<"EscrowMessage"> | Date | string | null
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }, "id">

  export type EscrowMessageOrderByWithAggregationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    _count?: EscrowMessageCountOrderByAggregateInput
    _max?: EscrowMessageMaxOrderByAggregateInput
    _min?: EscrowMessageMinOrderByAggregateInput
  }

  export type EscrowMessageScalarWhereWithAggregatesInput = {
    AND?: EscrowMessageScalarWhereWithAggregatesInput | EscrowMessageScalarWhereWithAggregatesInput[]
    OR?: EscrowMessageScalarWhereWithAggregatesInput[]
    NOT?: EscrowMessageScalarWhereWithAggregatesInput | EscrowMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EscrowMessage"> | string
    escrowId?: BytesNullableWithAggregatesFilter<"EscrowMessage"> | Buffer | null
    sender?: StringWithAggregatesFilter<"EscrowMessage"> | string
    text?: StringWithAggregatesFilter<"EscrowMessage"> | string
    attachment?: StringNullableWithAggregatesFilter<"EscrowMessage"> | string | null
    hash?: StringNullableWithAggregatesFilter<"EscrowMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EscrowMessage"> | Date | string
    editedAt?: DateTimeNullableWithAggregatesFilter<"EscrowMessage"> | Date | string | null
  }

  export type EscrowPaymentInstructionWhereInput = {
    AND?: EscrowPaymentInstructionWhereInput | EscrowPaymentInstructionWhereInput[]
    OR?: EscrowPaymentInstructionWhereInput[]
    NOT?: EscrowPaymentInstructionWhereInput | EscrowPaymentInstructionWhereInput[]
    escrowId?: BytesFilter<"EscrowPaymentInstruction"> | Buffer
    seller?: StringFilter<"EscrowPaymentInstruction"> | string
    content?: JsonNullableFilter<"EscrowPaymentInstruction">
    updatedAt?: DateTimeFilter<"EscrowPaymentInstruction"> | Date | string
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }

  export type EscrowPaymentInstructionOrderByWithRelationInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    content?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EscrowPaymentInstructionWhereUniqueInput = Prisma.AtLeast<{
    escrowId?: Buffer
    AND?: EscrowPaymentInstructionWhereInput | EscrowPaymentInstructionWhereInput[]
    OR?: EscrowPaymentInstructionWhereInput[]
    NOT?: EscrowPaymentInstructionWhereInput | EscrowPaymentInstructionWhereInput[]
    seller?: StringFilter<"EscrowPaymentInstruction"> | string
    content?: JsonNullableFilter<"EscrowPaymentInstruction">
    updatedAt?: DateTimeFilter<"EscrowPaymentInstruction"> | Date | string
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }, "escrowId">

  export type EscrowPaymentInstructionOrderByWithAggregationInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    content?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: EscrowPaymentInstructionCountOrderByAggregateInput
    _max?: EscrowPaymentInstructionMaxOrderByAggregateInput
    _min?: EscrowPaymentInstructionMinOrderByAggregateInput
  }

  export type EscrowPaymentInstructionScalarWhereWithAggregatesInput = {
    AND?: EscrowPaymentInstructionScalarWhereWithAggregatesInput | EscrowPaymentInstructionScalarWhereWithAggregatesInput[]
    OR?: EscrowPaymentInstructionScalarWhereWithAggregatesInput[]
    NOT?: EscrowPaymentInstructionScalarWhereWithAggregatesInput | EscrowPaymentInstructionScalarWhereWithAggregatesInput[]
    escrowId?: BytesWithAggregatesFilter<"EscrowPaymentInstruction"> | Buffer
    seller?: StringWithAggregatesFilter<"EscrowPaymentInstruction"> | string
    content?: JsonNullableWithAggregatesFilter<"EscrowPaymentInstruction">
    updatedAt?: DateTimeWithAggregatesFilter<"EscrowPaymentInstruction"> | Date | string
  }

  export type EscrowFiatStatusWhereInput = {
    AND?: EscrowFiatStatusWhereInput | EscrowFiatStatusWhereInput[]
    OR?: EscrowFiatStatusWhereInput[]
    NOT?: EscrowFiatStatusWhereInput | EscrowFiatStatusWhereInput[]
    id?: BigIntFilter<"EscrowFiatStatus"> | bigint | number
    escrowId?: BytesNullableFilter<"EscrowFiatStatus"> | Buffer | null
    actor?: StringFilter<"EscrowFiatStatus"> | string
    status?: StringFilter<"EscrowFiatStatus"> | string
    note?: StringNullableFilter<"EscrowFiatStatus"> | string | null
    createdAt?: DateTimeFilter<"EscrowFiatStatus"> | Date | string
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }

  export type EscrowFiatStatusOrderByWithRelationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EscrowFiatStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: EscrowFiatStatusWhereInput | EscrowFiatStatusWhereInput[]
    OR?: EscrowFiatStatusWhereInput[]
    NOT?: EscrowFiatStatusWhereInput | EscrowFiatStatusWhereInput[]
    escrowId?: BytesNullableFilter<"EscrowFiatStatus"> | Buffer | null
    actor?: StringFilter<"EscrowFiatStatus"> | string
    status?: StringFilter<"EscrowFiatStatus"> | string
    note?: StringNullableFilter<"EscrowFiatStatus"> | string | null
    createdAt?: DateTimeFilter<"EscrowFiatStatus"> | Date | string
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }, "id">

  export type EscrowFiatStatusOrderByWithAggregationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EscrowFiatStatusCountOrderByAggregateInput
    _avg?: EscrowFiatStatusAvgOrderByAggregateInput
    _max?: EscrowFiatStatusMaxOrderByAggregateInput
    _min?: EscrowFiatStatusMinOrderByAggregateInput
    _sum?: EscrowFiatStatusSumOrderByAggregateInput
  }

  export type EscrowFiatStatusScalarWhereWithAggregatesInput = {
    AND?: EscrowFiatStatusScalarWhereWithAggregatesInput | EscrowFiatStatusScalarWhereWithAggregatesInput[]
    OR?: EscrowFiatStatusScalarWhereWithAggregatesInput[]
    NOT?: EscrowFiatStatusScalarWhereWithAggregatesInput | EscrowFiatStatusScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"EscrowFiatStatus"> | bigint | number
    escrowId?: BytesNullableWithAggregatesFilter<"EscrowFiatStatus"> | Buffer | null
    actor?: StringWithAggregatesFilter<"EscrowFiatStatus"> | string
    status?: StringWithAggregatesFilter<"EscrowFiatStatus"> | string
    note?: StringNullableWithAggregatesFilter<"EscrowFiatStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EscrowFiatStatus"> | Date | string
  }

  export type EvidenceItemWhereInput = {
    AND?: EvidenceItemWhereInput | EvidenceItemWhereInput[]
    OR?: EvidenceItemWhereInput[]
    NOT?: EvidenceItemWhereInput | EvidenceItemWhereInput[]
    id?: StringFilter<"EvidenceItem"> | string
    escrowId?: BytesNullableFilter<"EvidenceItem"> | Buffer | null
    uploader?: StringFilter<"EvidenceItem"> | string
    uri?: StringFilter<"EvidenceItem"> | string
    sha256?: StringFilter<"EvidenceItem"> | string
    mime?: StringFilter<"EvidenceItem"> | string
    size?: BigIntFilter<"EvidenceItem"> | bigint | number
    description?: StringNullableFilter<"EvidenceItem"> | string | null
    createdAt?: DateTimeFilter<"EvidenceItem"> | Date | string
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }

  export type EvidenceItemOrderByWithRelationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EvidenceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvidenceItemWhereInput | EvidenceItemWhereInput[]
    OR?: EvidenceItemWhereInput[]
    NOT?: EvidenceItemWhereInput | EvidenceItemWhereInput[]
    escrowId?: BytesNullableFilter<"EvidenceItem"> | Buffer | null
    uploader?: StringFilter<"EvidenceItem"> | string
    uri?: StringFilter<"EvidenceItem"> | string
    sha256?: StringFilter<"EvidenceItem"> | string
    mime?: StringFilter<"EvidenceItem"> | string
    size?: BigIntFilter<"EvidenceItem"> | bigint | number
    description?: StringNullableFilter<"EvidenceItem"> | string | null
    createdAt?: DateTimeFilter<"EvidenceItem"> | Date | string
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }, "id">

  export type EvidenceItemOrderByWithAggregationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EvidenceItemCountOrderByAggregateInput
    _avg?: EvidenceItemAvgOrderByAggregateInput
    _max?: EvidenceItemMaxOrderByAggregateInput
    _min?: EvidenceItemMinOrderByAggregateInput
    _sum?: EvidenceItemSumOrderByAggregateInput
  }

  export type EvidenceItemScalarWhereWithAggregatesInput = {
    AND?: EvidenceItemScalarWhereWithAggregatesInput | EvidenceItemScalarWhereWithAggregatesInput[]
    OR?: EvidenceItemScalarWhereWithAggregatesInput[]
    NOT?: EvidenceItemScalarWhereWithAggregatesInput | EvidenceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvidenceItem"> | string
    escrowId?: BytesNullableWithAggregatesFilter<"EvidenceItem"> | Buffer | null
    uploader?: StringWithAggregatesFilter<"EvidenceItem"> | string
    uri?: StringWithAggregatesFilter<"EvidenceItem"> | string
    sha256?: StringWithAggregatesFilter<"EvidenceItem"> | string
    mime?: StringWithAggregatesFilter<"EvidenceItem"> | string
    size?: BigIntWithAggregatesFilter<"EvidenceItem"> | bigint | number
    description?: StringNullableWithAggregatesFilter<"EvidenceItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EvidenceItem"> | Date | string
  }

  export type DisputeWhereInput = {
    AND?: DisputeWhereInput | DisputeWhereInput[]
    OR?: DisputeWhereInput[]
    NOT?: DisputeWhereInput | DisputeWhereInput[]
    escrowId?: BytesFilter<"Dispute"> | Buffer
    openedBy?: StringFilter<"Dispute"> | string
    reasonCode?: StringNullableFilter<"Dispute"> | string | null
    summary?: StringNullableFilter<"Dispute"> | string | null
    status?: StringFilter<"Dispute"> | string
    arbitratorAssigned?: StringNullableFilter<"Dispute"> | string | null
    outcome?: StringNullableFilter<"Dispute"> | string | null
    ref?: BytesNullableFilter<"Dispute"> | Buffer | null
    escalationLevel?: IntFilter<"Dispute"> | number
    aiAnalysis?: JsonNullableFilter<"Dispute">
    tier2Analysis?: JsonNullableFilter<"Dispute">
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }

  export type DisputeOrderByWithRelationInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    ref?: SortOrderInput | SortOrder
    escalationLevel?: SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    tier2Analysis?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type DisputeWhereUniqueInput = Prisma.AtLeast<{
    escrowId?: Buffer
    AND?: DisputeWhereInput | DisputeWhereInput[]
    OR?: DisputeWhereInput[]
    NOT?: DisputeWhereInput | DisputeWhereInput[]
    openedBy?: StringFilter<"Dispute"> | string
    reasonCode?: StringNullableFilter<"Dispute"> | string | null
    summary?: StringNullableFilter<"Dispute"> | string | null
    status?: StringFilter<"Dispute"> | string
    arbitratorAssigned?: StringNullableFilter<"Dispute"> | string | null
    outcome?: StringNullableFilter<"Dispute"> | string | null
    ref?: BytesNullableFilter<"Dispute"> | Buffer | null
    escalationLevel?: IntFilter<"Dispute"> | number
    aiAnalysis?: JsonNullableFilter<"Dispute">
    tier2Analysis?: JsonNullableFilter<"Dispute">
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }, "escrowId">

  export type DisputeOrderByWithAggregationInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    ref?: SortOrderInput | SortOrder
    escalationLevel?: SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    tier2Analysis?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DisputeCountOrderByAggregateInput
    _avg?: DisputeAvgOrderByAggregateInput
    _max?: DisputeMaxOrderByAggregateInput
    _min?: DisputeMinOrderByAggregateInput
    _sum?: DisputeSumOrderByAggregateInput
  }

  export type DisputeScalarWhereWithAggregatesInput = {
    AND?: DisputeScalarWhereWithAggregatesInput | DisputeScalarWhereWithAggregatesInput[]
    OR?: DisputeScalarWhereWithAggregatesInput[]
    NOT?: DisputeScalarWhereWithAggregatesInput | DisputeScalarWhereWithAggregatesInput[]
    escrowId?: BytesWithAggregatesFilter<"Dispute"> | Buffer
    openedBy?: StringWithAggregatesFilter<"Dispute"> | string
    reasonCode?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    status?: StringWithAggregatesFilter<"Dispute"> | string
    arbitratorAssigned?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    outcome?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    ref?: BytesNullableWithAggregatesFilter<"Dispute"> | Buffer | null
    escalationLevel?: IntWithAggregatesFilter<"Dispute"> | number
    aiAnalysis?: JsonNullableWithAggregatesFilter<"Dispute">
    tier2Analysis?: JsonNullableWithAggregatesFilter<"Dispute">
    createdAt?: DateTimeWithAggregatesFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dispute"> | Date | string
  }

  export type IndexerCheckpointWhereInput = {
    AND?: IndexerCheckpointWhereInput | IndexerCheckpointWhereInput[]
    OR?: IndexerCheckpointWhereInput[]
    NOT?: IndexerCheckpointWhereInput | IndexerCheckpointWhereInput[]
    chainId?: IntFilter<"IndexerCheckpoint"> | number
    contractAddress?: StringFilter<"IndexerCheckpoint"> | string
    lastSyncedBlock?: BigIntFilter<"IndexerCheckpoint"> | bigint | number
    updatedAt?: DateTimeFilter<"IndexerCheckpoint"> | Date | string
  }

  export type IndexerCheckpointOrderByWithRelationInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointWhereUniqueInput = Prisma.AtLeast<{
    chainId_contractAddress?: IndexerCheckpointChainIdContractAddressCompoundUniqueInput
    AND?: IndexerCheckpointWhereInput | IndexerCheckpointWhereInput[]
    OR?: IndexerCheckpointWhereInput[]
    NOT?: IndexerCheckpointWhereInput | IndexerCheckpointWhereInput[]
    chainId?: IntFilter<"IndexerCheckpoint"> | number
    contractAddress?: StringFilter<"IndexerCheckpoint"> | string
    lastSyncedBlock?: BigIntFilter<"IndexerCheckpoint"> | bigint | number
    updatedAt?: DateTimeFilter<"IndexerCheckpoint"> | Date | string
  }, "chainId_contractAddress">

  export type IndexerCheckpointOrderByWithAggregationInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
    _count?: IndexerCheckpointCountOrderByAggregateInput
    _avg?: IndexerCheckpointAvgOrderByAggregateInput
    _max?: IndexerCheckpointMaxOrderByAggregateInput
    _min?: IndexerCheckpointMinOrderByAggregateInput
    _sum?: IndexerCheckpointSumOrderByAggregateInput
  }

  export type IndexerCheckpointScalarWhereWithAggregatesInput = {
    AND?: IndexerCheckpointScalarWhereWithAggregatesInput | IndexerCheckpointScalarWhereWithAggregatesInput[]
    OR?: IndexerCheckpointScalarWhereWithAggregatesInput[]
    NOT?: IndexerCheckpointScalarWhereWithAggregatesInput | IndexerCheckpointScalarWhereWithAggregatesInput[]
    chainId?: IntWithAggregatesFilter<"IndexerCheckpoint"> | number
    contractAddress?: StringWithAggregatesFilter<"IndexerCheckpoint"> | string
    lastSyncedBlock?: BigIntWithAggregatesFilter<"IndexerCheckpoint"> | bigint | number
    updatedAt?: DateTimeWithAggregatesFilter<"IndexerCheckpoint"> | Date | string
  }

  export type TokenRegistryWhereInput = {
    AND?: TokenRegistryWhereInput | TokenRegistryWhereInput[]
    OR?: TokenRegistryWhereInput[]
    NOT?: TokenRegistryWhereInput | TokenRegistryWhereInput[]
    chainId?: IntFilter<"TokenRegistry"> | number
    tokenKey?: StringFilter<"TokenRegistry"> | string
    symbol?: StringFilter<"TokenRegistry"> | string
    decimals?: IntFilter<"TokenRegistry"> | number
    name?: StringFilter<"TokenRegistry"> | string
    enabled?: BoolFilter<"TokenRegistry"> | boolean
  }

  export type TokenRegistryOrderByWithRelationInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
  }

  export type TokenRegistryWhereUniqueInput = Prisma.AtLeast<{
    chainId_tokenKey?: TokenRegistryChainIdTokenKeyCompoundUniqueInput
    AND?: TokenRegistryWhereInput | TokenRegistryWhereInput[]
    OR?: TokenRegistryWhereInput[]
    NOT?: TokenRegistryWhereInput | TokenRegistryWhereInput[]
    chainId?: IntFilter<"TokenRegistry"> | number
    tokenKey?: StringFilter<"TokenRegistry"> | string
    symbol?: StringFilter<"TokenRegistry"> | string
    decimals?: IntFilter<"TokenRegistry"> | number
    name?: StringFilter<"TokenRegistry"> | string
    enabled?: BoolFilter<"TokenRegistry"> | boolean
  }, "chainId_tokenKey">

  export type TokenRegistryOrderByWithAggregationInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    _count?: TokenRegistryCountOrderByAggregateInput
    _avg?: TokenRegistryAvgOrderByAggregateInput
    _max?: TokenRegistryMaxOrderByAggregateInput
    _min?: TokenRegistryMinOrderByAggregateInput
    _sum?: TokenRegistrySumOrderByAggregateInput
  }

  export type TokenRegistryScalarWhereWithAggregatesInput = {
    AND?: TokenRegistryScalarWhereWithAggregatesInput | TokenRegistryScalarWhereWithAggregatesInput[]
    OR?: TokenRegistryScalarWhereWithAggregatesInput[]
    NOT?: TokenRegistryScalarWhereWithAggregatesInput | TokenRegistryScalarWhereWithAggregatesInput[]
    chainId?: IntWithAggregatesFilter<"TokenRegistry"> | number
    tokenKey?: StringWithAggregatesFilter<"TokenRegistry"> | string
    symbol?: StringWithAggregatesFilter<"TokenRegistry"> | string
    decimals?: IntWithAggregatesFilter<"TokenRegistry"> | number
    name?: StringWithAggregatesFilter<"TokenRegistry"> | string
    enabled?: BoolWithAggregatesFilter<"TokenRegistry"> | boolean
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorAddress?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorAddress?: SortOrderInput | SortOrder
    action?: SortOrder
    target?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorAddress?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorAddress?: SortOrderInput | SortOrder
    action?: SortOrder
    target?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    target?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NonceWhereInput = {
    AND?: NonceWhereInput | NonceWhereInput[]
    OR?: NonceWhereInput[]
    NOT?: NonceWhereInput | NonceWhereInput[]
    id?: StringFilter<"Nonce"> | string
    address?: StringFilter<"Nonce"> | string
    value?: StringFilter<"Nonce"> | string
    chainId?: IntFilter<"Nonce"> | number
    domain?: StringNullableFilter<"Nonce"> | string | null
    issuedAt?: DateTimeFilter<"Nonce"> | Date | string
    expiresAt?: DateTimeFilter<"Nonce"> | Date | string
    used?: BoolFilter<"Nonce"> | boolean
    createdAt?: DateTimeFilter<"Nonce"> | Date | string
  }

  export type NonceOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address_value?: NonceAddressValueCompoundUniqueInput
    AND?: NonceWhereInput | NonceWhereInput[]
    OR?: NonceWhereInput[]
    NOT?: NonceWhereInput | NonceWhereInput[]
    address?: StringFilter<"Nonce"> | string
    value?: StringFilter<"Nonce"> | string
    chainId?: IntFilter<"Nonce"> | number
    domain?: StringNullableFilter<"Nonce"> | string | null
    issuedAt?: DateTimeFilter<"Nonce"> | Date | string
    expiresAt?: DateTimeFilter<"Nonce"> | Date | string
    used?: BoolFilter<"Nonce"> | boolean
    createdAt?: DateTimeFilter<"Nonce"> | Date | string
  }, "id" | "address_value">

  export type NonceOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: NonceCountOrderByAggregateInput
    _avg?: NonceAvgOrderByAggregateInput
    _max?: NonceMaxOrderByAggregateInput
    _min?: NonceMinOrderByAggregateInput
    _sum?: NonceSumOrderByAggregateInput
  }

  export type NonceScalarWhereWithAggregatesInput = {
    AND?: NonceScalarWhereWithAggregatesInput | NonceScalarWhereWithAggregatesInput[]
    OR?: NonceScalarWhereWithAggregatesInput[]
    NOT?: NonceScalarWhereWithAggregatesInput | NonceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Nonce"> | string
    address?: StringWithAggregatesFilter<"Nonce"> | string
    value?: StringWithAggregatesFilter<"Nonce"> | string
    chainId?: IntWithAggregatesFilter<"Nonce"> | number
    domain?: StringNullableWithAggregatesFilter<"Nonce"> | string | null
    issuedAt?: DateTimeWithAggregatesFilter<"Nonce"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Nonce"> | Date | string
    used?: BoolWithAggregatesFilter<"Nonce"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Nonce"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    address?: StringFilter<"NotificationPreference"> | string
    webhookUrl?: StringNullableFilter<"NotificationPreference"> | string | null
    telegramId?: StringNullableFilter<"NotificationPreference"> | string | null
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    address?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    telegramId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    address?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    webhookUrl?: StringNullableFilter<"NotificationPreference"> | string | null
    telegramId?: StringNullableFilter<"NotificationPreference"> | string | null
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "address">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    address?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    telegramId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    address?: StringWithAggregatesFilter<"NotificationPreference"> | string
    webhookUrl?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    telegramId?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    address?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    address?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    address?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ReferralCodeWhereInput = {
    AND?: ReferralCodeWhereInput | ReferralCodeWhereInput[]
    OR?: ReferralCodeWhereInput[]
    NOT?: ReferralCodeWhereInput | ReferralCodeWhereInput[]
    id?: StringFilter<"ReferralCode"> | string
    address?: StringFilter<"ReferralCode"> | string
    code?: StringFilter<"ReferralCode"> | string
    referralLink?: StringFilter<"ReferralCode"> | string
    createdAt?: DateTimeFilter<"ReferralCode"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralCode"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    referrals?: ReferralListRelationFilter
  }

  export type ReferralCodeOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    code?: SortOrder
    referralLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    referrals?: ReferralOrderByRelationAggregateInput
  }

  export type ReferralCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address?: string
    code?: string
    AND?: ReferralCodeWhereInput | ReferralCodeWhereInput[]
    OR?: ReferralCodeWhereInput[]
    NOT?: ReferralCodeWhereInput | ReferralCodeWhereInput[]
    referralLink?: StringFilter<"ReferralCode"> | string
    createdAt?: DateTimeFilter<"ReferralCode"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralCode"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    referrals?: ReferralListRelationFilter
  }, "id" | "code" | "address">

  export type ReferralCodeOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    code?: SortOrder
    referralLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralCodeCountOrderByAggregateInput
    _max?: ReferralCodeMaxOrderByAggregateInput
    _min?: ReferralCodeMinOrderByAggregateInput
  }

  export type ReferralCodeScalarWhereWithAggregatesInput = {
    AND?: ReferralCodeScalarWhereWithAggregatesInput | ReferralCodeScalarWhereWithAggregatesInput[]
    OR?: ReferralCodeScalarWhereWithAggregatesInput[]
    NOT?: ReferralCodeScalarWhereWithAggregatesInput | ReferralCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReferralCode"> | string
    address?: StringWithAggregatesFilter<"ReferralCode"> | string
    code?: StringWithAggregatesFilter<"ReferralCode"> | string
    referralLink?: StringWithAggregatesFilter<"ReferralCode"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReferralCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReferralCode"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerAddress?: StringFilter<"Referral"> | string
    refereeAddress?: StringFilter<"Referral"> | string
    referralCodeId?: StringFilter<"Referral"> | string
    qualified?: BoolFilter<"Referral"> | boolean
    qualifiedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referee?: XOR<UserRelationFilter, UserWhereInput>
    referralCode?: XOR<ReferralCodeRelationFilter, ReferralCodeWhereInput>
    commissions?: CommissionLedgerListRelationFilter
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerAddress?: SortOrder
    refereeAddress?: SortOrder
    referralCodeId?: SortOrder
    qualified?: SortOrder
    qualifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referee?: UserOrderByWithRelationInput
    referralCode?: ReferralCodeOrderByWithRelationInput
    commissions?: CommissionLedgerOrderByRelationAggregateInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerAddress?: StringFilter<"Referral"> | string
    refereeAddress?: StringFilter<"Referral"> | string
    referralCodeId?: StringFilter<"Referral"> | string
    qualified?: BoolFilter<"Referral"> | boolean
    qualifiedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referee?: XOR<UserRelationFilter, UserWhereInput>
    referralCode?: XOR<ReferralCodeRelationFilter, ReferralCodeWhereInput>
    commissions?: CommissionLedgerListRelationFilter
  }, "id">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerAddress?: SortOrder
    refereeAddress?: SortOrder
    referralCodeId?: SortOrder
    qualified?: SortOrder
    qualifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrerAddress?: StringWithAggregatesFilter<"Referral"> | string
    refereeAddress?: StringWithAggregatesFilter<"Referral"> | string
    referralCodeId?: StringWithAggregatesFilter<"Referral"> | string
    qualified?: BoolWithAggregatesFilter<"Referral"> | boolean
    qualifiedAt?: DateTimeNullableWithAggregatesFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type CommissionLedgerWhereInput = {
    AND?: CommissionLedgerWhereInput | CommissionLedgerWhereInput[]
    OR?: CommissionLedgerWhereInput[]
    NOT?: CommissionLedgerWhereInput | CommissionLedgerWhereInput[]
    id?: StringFilter<"CommissionLedger"> | string
    referralId?: StringFilter<"CommissionLedger"> | string
    feeAmount?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    feeType?: StringFilter<"CommissionLedger"> | string
    createdAt?: DateTimeFilter<"CommissionLedger"> | Date | string
    referral?: XOR<ReferralRelationFilter, ReferralWhereInput>
  }

  export type CommissionLedgerOrderByWithRelationInput = {
    id?: SortOrder
    referralId?: SortOrder
    feeAmount?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    feeType?: SortOrder
    createdAt?: SortOrder
    referral?: ReferralOrderByWithRelationInput
  }

  export type CommissionLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommissionLedgerWhereInput | CommissionLedgerWhereInput[]
    OR?: CommissionLedgerWhereInput[]
    NOT?: CommissionLedgerWhereInput | CommissionLedgerWhereInput[]
    referralId?: StringFilter<"CommissionLedger"> | string
    feeAmount?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    feeType?: StringFilter<"CommissionLedger"> | string
    createdAt?: DateTimeFilter<"CommissionLedger"> | Date | string
    referral?: XOR<ReferralRelationFilter, ReferralWhereInput>
  }, "id">

  export type CommissionLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    referralId?: SortOrder
    feeAmount?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    feeType?: SortOrder
    createdAt?: SortOrder
    _count?: CommissionLedgerCountOrderByAggregateInput
    _avg?: CommissionLedgerAvgOrderByAggregateInput
    _max?: CommissionLedgerMaxOrderByAggregateInput
    _min?: CommissionLedgerMinOrderByAggregateInput
    _sum?: CommissionLedgerSumOrderByAggregateInput
  }

  export type CommissionLedgerScalarWhereWithAggregatesInput = {
    AND?: CommissionLedgerScalarWhereWithAggregatesInput | CommissionLedgerScalarWhereWithAggregatesInput[]
    OR?: CommissionLedgerScalarWhereWithAggregatesInput[]
    NOT?: CommissionLedgerScalarWhereWithAggregatesInput | CommissionLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommissionLedger"> | string
    referralId?: StringWithAggregatesFilter<"CommissionLedger"> | string
    feeAmount?: DecimalWithAggregatesFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalWithAggregatesFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalWithAggregatesFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    feeType?: StringWithAggregatesFilter<"CommissionLedger"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommissionLedger"> | Date | string
  }

  export type ReferralWalletWhereInput = {
    AND?: ReferralWalletWhereInput | ReferralWalletWhereInput[]
    OR?: ReferralWalletWhereInput[]
    NOT?: ReferralWalletWhereInput | ReferralWalletWhereInput[]
    id?: StringFilter<"ReferralWallet"> | string
    address?: StringFilter<"ReferralWallet"> | string
    balance?: DecimalFilter<"ReferralWallet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ReferralWallet"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralWallet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: ReferralWalletTransactionListRelationFilter
  }

  export type ReferralWalletOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactions?: ReferralWalletTransactionOrderByRelationAggregateInput
  }

  export type ReferralWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address?: string
    AND?: ReferralWalletWhereInput | ReferralWalletWhereInput[]
    OR?: ReferralWalletWhereInput[]
    NOT?: ReferralWalletWhereInput | ReferralWalletWhereInput[]
    balance?: DecimalFilter<"ReferralWallet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ReferralWallet"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralWallet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: ReferralWalletTransactionListRelationFilter
  }, "id" | "address">

  export type ReferralWalletOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralWalletCountOrderByAggregateInput
    _avg?: ReferralWalletAvgOrderByAggregateInput
    _max?: ReferralWalletMaxOrderByAggregateInput
    _min?: ReferralWalletMinOrderByAggregateInput
    _sum?: ReferralWalletSumOrderByAggregateInput
  }

  export type ReferralWalletScalarWhereWithAggregatesInput = {
    AND?: ReferralWalletScalarWhereWithAggregatesInput | ReferralWalletScalarWhereWithAggregatesInput[]
    OR?: ReferralWalletScalarWhereWithAggregatesInput[]
    NOT?: ReferralWalletScalarWhereWithAggregatesInput | ReferralWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReferralWallet"> | string
    address?: StringWithAggregatesFilter<"ReferralWallet"> | string
    balance?: DecimalWithAggregatesFilter<"ReferralWallet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"ReferralWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReferralWallet"> | Date | string
  }

  export type ReferralWalletTransactionWhereInput = {
    AND?: ReferralWalletTransactionWhereInput | ReferralWalletTransactionWhereInput[]
    OR?: ReferralWalletTransactionWhereInput[]
    NOT?: ReferralWalletTransactionWhereInput | ReferralWalletTransactionWhereInput[]
    id?: StringFilter<"ReferralWalletTransaction"> | string
    walletId?: StringFilter<"ReferralWalletTransaction"> | string
    amount?: DecimalFilter<"ReferralWalletTransaction"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"ReferralWalletTransaction"> | string
    status?: StringFilter<"ReferralWalletTransaction"> | string
    targetAddress?: StringNullableFilter<"ReferralWalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"ReferralWalletTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralWalletTransaction"> | Date | string
    wallet?: XOR<ReferralWalletRelationFilter, ReferralWalletWhereInput>
  }

  export type ReferralWalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wallet?: ReferralWalletOrderByWithRelationInput
  }

  export type ReferralWalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferralWalletTransactionWhereInput | ReferralWalletTransactionWhereInput[]
    OR?: ReferralWalletTransactionWhereInput[]
    NOT?: ReferralWalletTransactionWhereInput | ReferralWalletTransactionWhereInput[]
    walletId?: StringFilter<"ReferralWalletTransaction"> | string
    amount?: DecimalFilter<"ReferralWalletTransaction"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"ReferralWalletTransaction"> | string
    status?: StringFilter<"ReferralWalletTransaction"> | string
    targetAddress?: StringNullableFilter<"ReferralWalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"ReferralWalletTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralWalletTransaction"> | Date | string
    wallet?: XOR<ReferralWalletRelationFilter, ReferralWalletWhereInput>
  }, "id">

  export type ReferralWalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralWalletTransactionCountOrderByAggregateInput
    _avg?: ReferralWalletTransactionAvgOrderByAggregateInput
    _max?: ReferralWalletTransactionMaxOrderByAggregateInput
    _min?: ReferralWalletTransactionMinOrderByAggregateInput
    _sum?: ReferralWalletTransactionSumOrderByAggregateInput
  }

  export type ReferralWalletTransactionScalarWhereWithAggregatesInput = {
    AND?: ReferralWalletTransactionScalarWhereWithAggregatesInput | ReferralWalletTransactionScalarWhereWithAggregatesInput[]
    OR?: ReferralWalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: ReferralWalletTransactionScalarWhereWithAggregatesInput | ReferralWalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReferralWalletTransaction"> | string
    walletId?: StringWithAggregatesFilter<"ReferralWalletTransaction"> | string
    amount?: DecimalWithAggregatesFilter<"ReferralWalletTransaction"> | Decimal | DecimalJsLike | number | string
    type?: StringWithAggregatesFilter<"ReferralWalletTransaction"> | string
    status?: StringWithAggregatesFilter<"ReferralWalletTransaction"> | string
    targetAddress?: StringNullableWithAggregatesFilter<"ReferralWalletTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReferralWalletTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReferralWalletTransaction"> | Date | string
  }

  export type PrimeStatusWhereInput = {
    AND?: PrimeStatusWhereInput | PrimeStatusWhereInput[]
    OR?: PrimeStatusWhereInput[]
    NOT?: PrimeStatusWhereInput | PrimeStatusWhereInput[]
    id?: StringFilter<"PrimeStatus"> | string
    address?: StringFilter<"PrimeStatus"> | string
    isPrime?: BoolFilter<"PrimeStatus"> | boolean
    primeActivatedAt?: DateTimeNullableFilter<"PrimeStatus"> | Date | string | null
    referralCount?: IntFilter<"PrimeStatus"> | number
    qualifiedReferralCount?: IntFilter<"PrimeStatus"> | number
    createdAt?: DateTimeFilter<"PrimeStatus"> | Date | string
    updatedAt?: DateTimeFilter<"PrimeStatus"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PrimeStatusOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    isPrime?: SortOrder
    primeActivatedAt?: SortOrderInput | SortOrder
    referralCount?: SortOrder
    qualifiedReferralCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PrimeStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address?: string
    AND?: PrimeStatusWhereInput | PrimeStatusWhereInput[]
    OR?: PrimeStatusWhereInput[]
    NOT?: PrimeStatusWhereInput | PrimeStatusWhereInput[]
    isPrime?: BoolFilter<"PrimeStatus"> | boolean
    primeActivatedAt?: DateTimeNullableFilter<"PrimeStatus"> | Date | string | null
    referralCount?: IntFilter<"PrimeStatus"> | number
    qualifiedReferralCount?: IntFilter<"PrimeStatus"> | number
    createdAt?: DateTimeFilter<"PrimeStatus"> | Date | string
    updatedAt?: DateTimeFilter<"PrimeStatus"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "address">

  export type PrimeStatusOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    isPrime?: SortOrder
    primeActivatedAt?: SortOrderInput | SortOrder
    referralCount?: SortOrder
    qualifiedReferralCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrimeStatusCountOrderByAggregateInput
    _avg?: PrimeStatusAvgOrderByAggregateInput
    _max?: PrimeStatusMaxOrderByAggregateInput
    _min?: PrimeStatusMinOrderByAggregateInput
    _sum?: PrimeStatusSumOrderByAggregateInput
  }

  export type PrimeStatusScalarWhereWithAggregatesInput = {
    AND?: PrimeStatusScalarWhereWithAggregatesInput | PrimeStatusScalarWhereWithAggregatesInput[]
    OR?: PrimeStatusScalarWhereWithAggregatesInput[]
    NOT?: PrimeStatusScalarWhereWithAggregatesInput | PrimeStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrimeStatus"> | string
    address?: StringWithAggregatesFilter<"PrimeStatus"> | string
    isPrime?: BoolWithAggregatesFilter<"PrimeStatus"> | boolean
    primeActivatedAt?: DateTimeNullableWithAggregatesFilter<"PrimeStatus"> | Date | string | null
    referralCount?: IntWithAggregatesFilter<"PrimeStatus"> | number
    qualifiedReferralCount?: IntWithAggregatesFilter<"PrimeStatus"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PrimeStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrimeStatus"> | Date | string
  }

  export type ReferralConfigWhereInput = {
    AND?: ReferralConfigWhereInput | ReferralConfigWhereInput[]
    OR?: ReferralConfigWhereInput[]
    NOT?: ReferralConfigWhereInput | ReferralConfigWhereInput[]
    id?: StringFilter<"ReferralConfig"> | string
    commissionRate?: DecimalFilter<"ReferralConfig"> | Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: StringFilter<"ReferralConfig"> | string
    primeUnlockThreshold?: IntFilter<"ReferralConfig"> | number
    createdAt?: DateTimeFilter<"ReferralConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralConfig"> | Date | string
  }

  export type ReferralConfigOrderByWithRelationInput = {
    id?: SortOrder
    commissionRate?: SortOrder
    eligibleFeeTypes?: SortOrder
    primeUnlockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferralConfigWhereInput | ReferralConfigWhereInput[]
    OR?: ReferralConfigWhereInput[]
    NOT?: ReferralConfigWhereInput | ReferralConfigWhereInput[]
    commissionRate?: DecimalFilter<"ReferralConfig"> | Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: StringFilter<"ReferralConfig"> | string
    primeUnlockThreshold?: IntFilter<"ReferralConfig"> | number
    createdAt?: DateTimeFilter<"ReferralConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralConfig"> | Date | string
  }, "id">

  export type ReferralConfigOrderByWithAggregationInput = {
    id?: SortOrder
    commissionRate?: SortOrder
    eligibleFeeTypes?: SortOrder
    primeUnlockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralConfigCountOrderByAggregateInput
    _avg?: ReferralConfigAvgOrderByAggregateInput
    _max?: ReferralConfigMaxOrderByAggregateInput
    _min?: ReferralConfigMinOrderByAggregateInput
    _sum?: ReferralConfigSumOrderByAggregateInput
  }

  export type ReferralConfigScalarWhereWithAggregatesInput = {
    AND?: ReferralConfigScalarWhereWithAggregatesInput | ReferralConfigScalarWhereWithAggregatesInput[]
    OR?: ReferralConfigScalarWhereWithAggregatesInput[]
    NOT?: ReferralConfigScalarWhereWithAggregatesInput | ReferralConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReferralConfig"> | string
    commissionRate?: DecimalWithAggregatesFilter<"ReferralConfig"> | Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: StringWithAggregatesFilter<"ReferralConfig"> | string
    primeUnlockThreshold?: IntWithAggregatesFilter<"ReferralConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReferralConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReferralConfig"> | Date | string
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: StringFilter<"Offer"> | string
    creator?: StringFilter<"Offer"> | string
    type?: StringFilter<"Offer"> | string
    token?: StringFilter<"Offer"> | string
    currency?: StringFilter<"Offer"> | string
    priceType?: StringFilter<"Offer"> | string
    price?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    paymentMethods?: StringNullableListFilter<"Offer">
    terms?: StringNullableFilter<"Offer"> | string | null
    status?: StringFilter<"Offer"> | string
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    creator?: SortOrder
    type?: SortOrder
    token?: SortOrder
    currency?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    paymentMethods?: SortOrder
    terms?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    creator?: StringFilter<"Offer"> | string
    type?: StringFilter<"Offer"> | string
    token?: StringFilter<"Offer"> | string
    currency?: StringFilter<"Offer"> | string
    priceType?: StringFilter<"Offer"> | string
    price?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    paymentMethods?: StringNullableListFilter<"Offer">
    terms?: StringNullableFilter<"Offer"> | string | null
    status?: StringFilter<"Offer"> | string
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    creator?: SortOrder
    type?: SortOrder
    token?: SortOrder
    currency?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    paymentMethods?: SortOrder
    terms?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Offer"> | string
    creator?: StringWithAggregatesFilter<"Offer"> | string
    type?: StringWithAggregatesFilter<"Offer"> | string
    token?: StringWithAggregatesFilter<"Offer"> | string
    currency?: StringWithAggregatesFilter<"Offer"> | string
    priceType?: StringWithAggregatesFilter<"Offer"> | string
    price?: DecimalWithAggregatesFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalWithAggregatesFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalWithAggregatesFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    paymentMethods?: StringNullableListFilter<"Offer">
    terms?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    status?: StringWithAggregatesFilter<"Offer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
  }

  export type UserCreateInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserUncheckedUpdateManyInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TradeReviewCreateInput = {
    id?: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    reviewed: UserCreateNestedOneWithoutReviewsReceivedInput
    escrow: EscrowCreateNestedOneWithoutReviewsInput
  }

  export type TradeReviewUncheckedCreateInput = {
    id?: string
    tradeId: Buffer
    reviewerAddress: string
    reviewedAddress: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
  }

  export type TradeReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    reviewed?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
    escrow?: EscrowUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type TradeReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeId?: BytesFieldUpdateOperationsInput | Buffer
    reviewerAddress?: StringFieldUpdateOperationsInput | string
    reviewedAddress?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewCreateManyInput = {
    id?: string
    tradeId: Buffer
    reviewerAddress: string
    reviewedAddress: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
  }

  export type TradeReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeId?: BytesFieldUpdateOperationsInput | Buffer
    reviewerAddress?: StringFieldUpdateOperationsInput | string
    reviewedAddress?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    address: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateManyInput = {
    id?: string
    address: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowCreateInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUncheckedCreateInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewUncheckedCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUpdateInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUncheckedUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowCreateManyInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscrowUpdateManyMutationInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowUncheckedUpdateManyInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowTimelineCreateInput = {
    id?: bigint | number
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
    Escrow: EscrowCreateNestedOneWithoutTimelineInput
  }

  export type EscrowTimelineUncheckedCreateInput = {
    id?: bigint | number
    escrowId: Buffer
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
    Escrow?: EscrowUpdateOneRequiredWithoutTimelineNestedInput
  }

  export type EscrowTimelineUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineCreateManyInput = {
    id?: bigint | number
    escrowId: Buffer
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowMessageCreateInput = {
    id?: string
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    Escrow?: EscrowCreateNestedOneWithoutMessagesInput
  }

  export type EscrowMessageUncheckedCreateInput = {
    id?: string
    escrowId?: Buffer | null
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Escrow?: EscrowUpdateOneWithoutMessagesNestedInput
  }

  export type EscrowMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowMessageCreateManyInput = {
    id?: string
    escrowId?: Buffer | null
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowPaymentInstructionCreateInput = {
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    Escrow: EscrowCreateNestedOneWithoutPaymentInstructionInput
  }

  export type EscrowPaymentInstructionUncheckedCreateInput = {
    escrowId: Buffer
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type EscrowPaymentInstructionUpdateInput = {
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escrow?: EscrowUpdateOneRequiredWithoutPaymentInstructionNestedInput
  }

  export type EscrowPaymentInstructionUncheckedUpdateInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowPaymentInstructionCreateManyInput = {
    escrowId: Buffer
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type EscrowPaymentInstructionUpdateManyMutationInput = {
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowPaymentInstructionUncheckedUpdateManyInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusCreateInput = {
    id?: bigint | number
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
    Escrow?: EscrowCreateNestedOneWithoutFiatStatusesInput
  }

  export type EscrowFiatStatusUncheckedCreateInput = {
    id?: bigint | number
    escrowId?: Buffer | null
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EscrowFiatStatusUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escrow?: EscrowUpdateOneWithoutFiatStatusesNestedInput
  }

  export type EscrowFiatStatusUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusCreateManyInput = {
    id?: bigint | number
    escrowId?: Buffer | null
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EscrowFiatStatusUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemCreateInput = {
    id?: string
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
    Escrow?: EscrowCreateNestedOneWithoutEvidenceInput
  }

  export type EvidenceItemUncheckedCreateInput = {
    id?: string
    escrowId?: Buffer | null
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escrow?: EscrowUpdateOneWithoutEvidenceNestedInput
  }

  export type EvidenceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemCreateManyInput = {
    id?: string
    escrowId?: Buffer | null
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeCreateInput = {
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    escalationLevel?: number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Escrow: EscrowCreateNestedOneWithoutDisputeInput
  }

  export type DisputeUncheckedCreateInput = {
    escrowId: Buffer
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    escalationLevel?: number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUpdateInput = {
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escrow?: EscrowUpdateOneRequiredWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeCreateManyInput = {
    escrowId: Buffer
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    escalationLevel?: number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUpdateManyMutationInput = {
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUncheckedUpdateManyInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndexerCheckpointCreateInput = {
    chainId: number
    contractAddress: string
    lastSyncedBlock: bigint | number
    updatedAt?: Date | string
  }

  export type IndexerCheckpointUncheckedCreateInput = {
    chainId: number
    contractAddress: string
    lastSyncedBlock: bigint | number
    updatedAt?: Date | string
  }

  export type IndexerCheckpointUpdateInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    lastSyncedBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndexerCheckpointUncheckedUpdateInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    lastSyncedBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndexerCheckpointCreateManyInput = {
    chainId: number
    contractAddress: string
    lastSyncedBlock: bigint | number
    updatedAt?: Date | string
  }

  export type IndexerCheckpointUpdateManyMutationInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    lastSyncedBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndexerCheckpointUncheckedUpdateManyInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    lastSyncedBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenRegistryCreateInput = {
    chainId: number
    tokenKey: string
    symbol: string
    decimals: number
    name: string
    enabled?: boolean
  }

  export type TokenRegistryUncheckedCreateInput = {
    chainId: number
    tokenKey: string
    symbol: string
    decimals: number
    name: string
    enabled?: boolean
  }

  export type TokenRegistryUpdateInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    tokenKey?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenRegistryUncheckedUpdateInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    tokenKey?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenRegistryCreateManyInput = {
    chainId: number
    tokenKey: string
    symbol: string
    decimals: number
    name: string
    enabled?: boolean
  }

  export type TokenRegistryUpdateManyMutationInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    tokenKey?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenRegistryUncheckedUpdateManyInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    tokenKey?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateInput = {
    id?: string
    actorAddress?: string | null
    action: string
    target?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorAddress?: string | null
    action: string
    target?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorAddress?: string | null
    action: string
    target?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonceCreateInput = {
    id?: string
    address: string
    value: string
    chainId: number
    domain?: string | null
    issuedAt: Date | string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type NonceUncheckedCreateInput = {
    id?: string
    address: string
    value: string
    chainId: number
    domain?: string | null
    issuedAt: Date | string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type NonceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonceCreateManyInput = {
    id?: string
    address: string
    value: string
    chainId: number
    domain?: string | null
    issuedAt: Date | string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type NonceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    webhookUrl?: string | null
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferenceInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    address: string
    webhookUrl?: string | null
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferenceNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    address: string
    webhookUrl?: string | null
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    address?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    address: string
    type: string
    title: string
    message: string
    read?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    address: string
    type: string
    title: string
    message: string
    read?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCodeCreateInput = {
    id?: string
    code: string
    referralLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReferralCodesInput
    referrals?: ReferralCreateNestedManyWithoutReferralCodeInput
  }

  export type ReferralCodeUncheckedCreateInput = {
    id?: string
    address: string
    code: string
    referralLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferralCodeInput
  }

  export type ReferralCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReferralCodesNestedInput
    referrals?: ReferralUpdateManyWithoutReferralCodeNestedInput
  }

  export type ReferralCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: ReferralUncheckedUpdateManyWithoutReferralCodeNestedInput
  }

  export type ReferralCodeCreateManyInput = {
    id?: string
    address: string
    code: string
    referralLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsMadeInput
    referee: UserCreateNestedOneWithoutReferralsReceivedInput
    referralCode: ReferralCodeCreateNestedOneWithoutReferralsInput
    commissions?: CommissionLedgerCreateNestedManyWithoutReferralInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrerAddress: string
    refereeAddress: string
    referralCodeId: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissions?: CommissionLedgerUncheckedCreateNestedManyWithoutReferralInput
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsMadeNestedInput
    referee?: UserUpdateOneRequiredWithoutReferralsReceivedNestedInput
    referralCode?: ReferralCodeUpdateOneRequiredWithoutReferralsNestedInput
    commissions?: CommissionLedgerUpdateManyWithoutReferralNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerAddress?: StringFieldUpdateOperationsInput | string
    refereeAddress?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: CommissionLedgerUncheckedUpdateManyWithoutReferralNestedInput
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrerAddress: string
    refereeAddress: string
    referralCodeId: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerAddress?: StringFieldUpdateOperationsInput | string
    refereeAddress?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionLedgerCreateInput = {
    id?: string
    feeAmount: Decimal | DecimalJsLike | number | string
    commissionRate: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    feeType: string
    createdAt?: Date | string
    referral: ReferralCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionLedgerUncheckedCreateInput = {
    id?: string
    referralId: string
    feeAmount: Decimal | DecimalJsLike | number | string
    commissionRate: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    feeType: string
    createdAt?: Date | string
  }

  export type CommissionLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referral?: ReferralUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type CommissionLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralId?: StringFieldUpdateOperationsInput | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionLedgerCreateManyInput = {
    id?: string
    referralId: string
    feeAmount: Decimal | DecimalJsLike | number | string
    commissionRate: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    feeType: string
    createdAt?: Date | string
  }

  export type CommissionLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralId?: StringFieldUpdateOperationsInput | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralWalletCreateInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReferralWalletInput
    transactions?: ReferralWalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type ReferralWalletUncheckedCreateInput = {
    id?: string
    address: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: ReferralWalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type ReferralWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReferralWalletNestedInput
    transactions?: ReferralWalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type ReferralWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: ReferralWalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type ReferralWalletCreateManyInput = {
    id?: string
    address: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralWalletTransactionCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    status: string
    targetAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wallet: ReferralWalletCreateNestedOneWithoutTransactionsInput
  }

  export type ReferralWalletTransactionUncheckedCreateInput = {
    id?: string
    walletId: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    status: string
    targetAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralWalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: ReferralWalletUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type ReferralWalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralWalletTransactionCreateManyInput = {
    id?: string
    walletId: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    status: string
    targetAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralWalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralWalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrimeStatusCreateInput = {
    id?: string
    isPrime?: boolean
    primeActivatedAt?: Date | string | null
    referralCount?: number
    qualifiedReferralCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPrimeInput
  }

  export type PrimeStatusUncheckedCreateInput = {
    id?: string
    address: string
    isPrime?: boolean
    primeActivatedAt?: Date | string | null
    referralCount?: number
    qualifiedReferralCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrimeStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    primeActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    qualifiedReferralCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPrimeNestedInput
  }

  export type PrimeStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    primeActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    qualifiedReferralCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrimeStatusCreateManyInput = {
    id?: string
    address: string
    isPrime?: boolean
    primeActivatedAt?: Date | string | null
    referralCount?: number
    qualifiedReferralCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrimeStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    primeActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    qualifiedReferralCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrimeStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    primeActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    qualifiedReferralCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralConfigCreateInput = {
    id?: string
    commissionRate?: Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: string
    primeUnlockThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralConfigUncheckedCreateInput = {
    id?: string
    commissionRate?: Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: string
    primeUnlockThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: StringFieldUpdateOperationsInput | string
    primeUnlockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: StringFieldUpdateOperationsInput | string
    primeUnlockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralConfigCreateManyInput = {
    id?: string
    commissionRate?: Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: string
    primeUnlockThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: StringFieldUpdateOperationsInput | string
    primeUnlockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibleFeeTypes?: StringFieldUpdateOperationsInput | string
    primeUnlockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferCreateInput = {
    id?: string
    type: string
    token: string
    currency: string
    priceType: string
    price: Decimal | DecimalJsLike | number | string
    minAmount: Decimal | DecimalJsLike | number | string
    maxAmount: Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferCreatepaymentMethodsInput | string[]
    terms?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateInput = {
    id?: string
    creator: string
    type: string
    token: string
    currency: string
    priceType: string
    price: Decimal | DecimalJsLike | number | string
    minAmount: Decimal | DecimalJsLike | number | string
    maxAmount: Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferCreatepaymentMethodsInput | string[]
    terms?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferUpdatepaymentMethodsInput | string[]
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferUpdatepaymentMethodsInput | string[]
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferCreateManyInput = {
    id?: string
    creator: string
    type: string
    token: string
    currency: string
    priceType: string
    price: Decimal | DecimalJsLike | number | string
    minAmount: Decimal | DecimalJsLike | number | string
    maxAmount: Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferCreatepaymentMethodsInput | string[]
    terms?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferUpdatepaymentMethodsInput | string[]
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferUpdatepaymentMethodsInput | string[]
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type NotificationPreferenceNullableRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type ReferralCodeListRelationFilter = {
    every?: ReferralCodeWhereInput
    some?: ReferralCodeWhereInput
    none?: ReferralCodeWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ReferralWalletNullableRelationFilter = {
    is?: ReferralWalletWhereInput | null
    isNot?: ReferralWalletWhereInput | null
  }

  export type PrimeStatusNullableRelationFilter = {
    is?: PrimeStatusWhereInput | null
    isNot?: PrimeStatusWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type TradeReviewListRelationFilter = {
    every?: TradeReviewWhereInput
    some?: TradeReviewWhereInput
    none?: TradeReviewWhereInput
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    address?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    paymentMethods?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
    reputationScore?: SortOrder
    successfulTrades?: SortOrder
    totalVolume?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    reputationScore?: SortOrder
    successfulTrades?: SortOrder
    totalVolume?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    address?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
    reputationScore?: SortOrder
    successfulTrades?: SortOrder
    totalVolume?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    address?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
    reputationScore?: SortOrder
    successfulTrades?: SortOrder
    totalVolume?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    reputationScore?: SortOrder
    successfulTrades?: SortOrder
    totalVolume?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EscrowRelationFilter = {
    is?: EscrowWhereInput
    isNot?: EscrowWhereInput
  }

  export type TradeReviewTradeIdReviewerAddressCompoundUniqueInput = {
    tradeId: Buffer
    reviewerAddress: string
  }

  export type TradeReviewCountOrderByAggregateInput = {
    id?: SortOrder
    tradeId?: SortOrder
    reviewerAddress?: SortOrder
    reviewedAddress?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrder
    reviewTags?: SortOrder
    tradeRole?: SortOrder
    createdAt?: SortOrder
  }

  export type TradeReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TradeReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    tradeId?: SortOrder
    reviewerAddress?: SortOrder
    reviewedAddress?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrder
    tradeRole?: SortOrder
    createdAt?: SortOrder
  }

  export type TradeReviewMinOrderByAggregateInput = {
    id?: SortOrder
    tradeId?: SortOrder
    reviewerAddress?: SortOrder
    reviewedAddress?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrder
    tradeRole?: SortOrder
    createdAt?: SortOrder
  }

  export type TradeReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type RoleAddressRoleCompoundUniqueInput = {
    address: string
    role: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EscrowTimelineListRelationFilter = {
    every?: EscrowTimelineWhereInput
    some?: EscrowTimelineWhereInput
    none?: EscrowTimelineWhereInput
  }

  export type EscrowMessageListRelationFilter = {
    every?: EscrowMessageWhereInput
    some?: EscrowMessageWhereInput
    none?: EscrowMessageWhereInput
  }

  export type EscrowPaymentInstructionNullableRelationFilter = {
    is?: EscrowPaymentInstructionWhereInput | null
    isNot?: EscrowPaymentInstructionWhereInput | null
  }

  export type EscrowFiatStatusListRelationFilter = {
    every?: EscrowFiatStatusWhereInput
    some?: EscrowFiatStatusWhereInput
    none?: EscrowFiatStatusWhereInput
  }

  export type EvidenceItemListRelationFilter = {
    every?: EvidenceItemWhereInput
    some?: EvidenceItemWhereInput
    none?: EvidenceItemWhereInput
  }

  export type DisputeNullableRelationFilter = {
    is?: DisputeWhereInput | null
    isNot?: DisputeWhereInput | null
  }

  export type EscrowTimelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscrowMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscrowFiatStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvidenceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscrowCountOrderByAggregateInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrder
    txHashLast?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowAvgOrderByAggregateInput = {
    chainId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
  }

  export type EscrowMaxOrderByAggregateInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrder
    txHashLast?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowMinOrderByAggregateInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrder
    txHashLast?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowSumOrderByAggregateInput = {
    chainId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EscrowTimelineEscrowIdBlockNumberLogIndexCompoundUniqueInput = {
    escrowId: Buffer
    blockNumber: bigint | number
    logIndex: number
  }

  export type EscrowTimelineCountOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
    payload?: SortOrder
  }

  export type EscrowTimelineAvgOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
  }

  export type EscrowTimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
  }

  export type EscrowTimelineMinOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
  }

  export type EscrowTimelineSumOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type EscrowNullableRelationFilter = {
    is?: EscrowWhereInput | null
    isNot?: EscrowWhereInput | null
  }

  export type EscrowMessageCountOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
  }

  export type EscrowMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
  }

  export type EscrowMessageMinOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EscrowPaymentInstructionCountOrderByAggregateInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    content?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowPaymentInstructionMaxOrderByAggregateInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowPaymentInstructionMinOrderByAggregateInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EscrowFiatStatusCountOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EscrowFiatStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EscrowFiatStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EscrowFiatStatusMinOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EscrowFiatStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EvidenceItemCountOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceItemAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EvidenceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceItemMinOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceItemSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DisputeCountOrderByAggregateInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrder
    outcome?: SortOrder
    ref?: SortOrder
    escalationLevel?: SortOrder
    aiAnalysis?: SortOrder
    tier2Analysis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeAvgOrderByAggregateInput = {
    escalationLevel?: SortOrder
  }

  export type DisputeMaxOrderByAggregateInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrder
    outcome?: SortOrder
    ref?: SortOrder
    escalationLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeMinOrderByAggregateInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrder
    outcome?: SortOrder
    ref?: SortOrder
    escalationLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeSumOrderByAggregateInput = {
    escalationLevel?: SortOrder
  }

  export type IndexerCheckpointChainIdContractAddressCompoundUniqueInput = {
    chainId: number
    contractAddress: string
  }

  export type IndexerCheckpointCountOrderByAggregateInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointAvgOrderByAggregateInput = {
    chainId?: SortOrder
    lastSyncedBlock?: SortOrder
  }

  export type IndexerCheckpointMaxOrderByAggregateInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointMinOrderByAggregateInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointSumOrderByAggregateInput = {
    chainId?: SortOrder
    lastSyncedBlock?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TokenRegistryChainIdTokenKeyCompoundUniqueInput = {
    chainId: number
    tokenKey: string
  }

  export type TokenRegistryCountOrderByAggregateInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
  }

  export type TokenRegistryAvgOrderByAggregateInput = {
    chainId?: SortOrder
    decimals?: SortOrder
  }

  export type TokenRegistryMaxOrderByAggregateInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
  }

  export type TokenRegistryMinOrderByAggregateInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
  }

  export type TokenRegistrySumOrderByAggregateInput = {
    chainId?: SortOrder
    decimals?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorAddress?: SortOrder
    action?: SortOrder
    target?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorAddress?: SortOrder
    action?: SortOrder
    target?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorAddress?: SortOrder
    action?: SortOrder
    target?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceAddressValueCompoundUniqueInput = {
    address: string
    value: string
  }

  export type NonceCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceAvgOrderByAggregateInput = {
    chainId?: SortOrder
  }

  export type NonceMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceSumOrderByAggregateInput = {
    chainId?: SortOrder
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    address?: SortOrder
    webhookUrl?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    address?: SortOrder
    webhookUrl?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    address?: SortOrder
    webhookUrl?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralCodeCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    code?: SortOrder
    referralLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    code?: SortOrder
    referralLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralCodeMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    code?: SortOrder
    referralLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralCodeRelationFilter = {
    is?: ReferralCodeWhereInput
    isNot?: ReferralCodeWhereInput
  }

  export type CommissionLedgerListRelationFilter = {
    every?: CommissionLedgerWhereInput
    some?: CommissionLedgerWhereInput
    none?: CommissionLedgerWhereInput
  }

  export type CommissionLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerAddress?: SortOrder
    refereeAddress?: SortOrder
    referralCodeId?: SortOrder
    qualified?: SortOrder
    qualifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerAddress?: SortOrder
    refereeAddress?: SortOrder
    referralCodeId?: SortOrder
    qualified?: SortOrder
    qualifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerAddress?: SortOrder
    refereeAddress?: SortOrder
    referralCodeId?: SortOrder
    qualified?: SortOrder
    qualifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralRelationFilter = {
    is?: ReferralWhereInput
    isNot?: ReferralWhereInput
  }

  export type CommissionLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    referralId?: SortOrder
    feeAmount?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    feeType?: SortOrder
    createdAt?: SortOrder
  }

  export type CommissionLedgerAvgOrderByAggregateInput = {
    feeAmount?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
  }

  export type CommissionLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    referralId?: SortOrder
    feeAmount?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    feeType?: SortOrder
    createdAt?: SortOrder
  }

  export type CommissionLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    referralId?: SortOrder
    feeAmount?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    feeType?: SortOrder
    createdAt?: SortOrder
  }

  export type CommissionLedgerSumOrderByAggregateInput = {
    feeAmount?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
  }

  export type ReferralWalletTransactionListRelationFilter = {
    every?: ReferralWalletTransactionWhereInput
    some?: ReferralWalletTransactionWhereInput
    none?: ReferralWalletTransactionWhereInput
  }

  export type ReferralWalletTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralWalletCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralWalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type ReferralWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralWalletMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralWalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type ReferralWalletRelationFilter = {
    is?: ReferralWalletWhereInput
    isNot?: ReferralWalletWhereInput
  }

  export type ReferralWalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralWalletTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ReferralWalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralWalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralWalletTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PrimeStatusCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    isPrime?: SortOrder
    primeActivatedAt?: SortOrder
    referralCount?: SortOrder
    qualifiedReferralCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrimeStatusAvgOrderByAggregateInput = {
    referralCount?: SortOrder
    qualifiedReferralCount?: SortOrder
  }

  export type PrimeStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    isPrime?: SortOrder
    primeActivatedAt?: SortOrder
    referralCount?: SortOrder
    qualifiedReferralCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrimeStatusMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    isPrime?: SortOrder
    primeActivatedAt?: SortOrder
    referralCount?: SortOrder
    qualifiedReferralCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrimeStatusSumOrderByAggregateInput = {
    referralCount?: SortOrder
    qualifiedReferralCount?: SortOrder
  }

  export type ReferralConfigCountOrderByAggregateInput = {
    id?: SortOrder
    commissionRate?: SortOrder
    eligibleFeeTypes?: SortOrder
    primeUnlockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralConfigAvgOrderByAggregateInput = {
    commissionRate?: SortOrder
    primeUnlockThreshold?: SortOrder
  }

  export type ReferralConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    commissionRate?: SortOrder
    eligibleFeeTypes?: SortOrder
    primeUnlockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralConfigMinOrderByAggregateInput = {
    id?: SortOrder
    commissionRate?: SortOrder
    eligibleFeeTypes?: SortOrder
    primeUnlockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralConfigSumOrderByAggregateInput = {
    commissionRate?: SortOrder
    primeUnlockThreshold?: SortOrder
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    creator?: SortOrder
    type?: SortOrder
    token?: SortOrder
    currency?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    paymentMethods?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    price?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    creator?: SortOrder
    type?: SortOrder
    token?: SortOrder
    currency?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    creator?: SortOrder
    type?: SortOrder
    token?: SortOrder
    currency?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    price?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
  }

  export type UserCreatepaymentMethodsInput = {
    set: string[]
  }

  export type RoleCreateNestedManyWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput> | RoleCreateWithoutUserInput[] | RoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput | RoleCreateOrConnectWithoutUserInput[]
    createMany?: RoleCreateManyUserInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type ReferralCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput> | ReferralCodeCreateWithoutUserInput[] | ReferralCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUserInput | ReferralCodeCreateOrConnectWithoutUserInput[]
    createMany?: ReferralCodeCreateManyUserInputEnvelope
    connect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput> | ReferralCreateWithoutRefereeInput[] | ReferralUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput | ReferralCreateOrConnectWithoutRefereeInput[]
    createMany?: ReferralCreateManyRefereeInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralWalletCreateNestedOneWithoutUserInput = {
    create?: XOR<ReferralWalletCreateWithoutUserInput, ReferralWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReferralWalletCreateOrConnectWithoutUserInput
    connect?: ReferralWalletWhereUniqueInput
  }

  export type PrimeStatusCreateNestedOneWithoutUserInput = {
    create?: XOR<PrimeStatusCreateWithoutUserInput, PrimeStatusUncheckedCreateWithoutUserInput>
    connectOrCreate?: PrimeStatusCreateOrConnectWithoutUserInput
    connect?: PrimeStatusWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TradeReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<TradeReviewCreateWithoutReviewerInput, TradeReviewUncheckedCreateWithoutReviewerInput> | TradeReviewCreateWithoutReviewerInput[] | TradeReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutReviewerInput | TradeReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: TradeReviewCreateManyReviewerInputEnvelope
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
  }

  export type TradeReviewCreateNestedManyWithoutReviewedInput = {
    create?: XOR<TradeReviewCreateWithoutReviewedInput, TradeReviewUncheckedCreateWithoutReviewedInput> | TradeReviewCreateWithoutReviewedInput[] | TradeReviewUncheckedCreateWithoutReviewedInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutReviewedInput | TradeReviewCreateOrConnectWithoutReviewedInput[]
    createMany?: TradeReviewCreateManyReviewedInputEnvelope
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutUserInput = {
    create?: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput> | OfferCreateWithoutUserInput[] | OfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutUserInput | OfferCreateOrConnectWithoutUserInput[]
    createMany?: OfferCreateManyUserInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput> | RoleCreateWithoutUserInput[] | RoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput | RoleCreateOrConnectWithoutUserInput[]
    createMany?: RoleCreateManyUserInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type ReferralCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput> | ReferralCodeCreateWithoutUserInput[] | ReferralCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUserInput | ReferralCodeCreateOrConnectWithoutUserInput[]
    createMany?: ReferralCodeCreateManyUserInputEnvelope
    connect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput> | ReferralCreateWithoutRefereeInput[] | ReferralUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput | ReferralCreateOrConnectWithoutRefereeInput[]
    createMany?: ReferralCreateManyRefereeInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralWalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ReferralWalletCreateWithoutUserInput, ReferralWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReferralWalletCreateOrConnectWithoutUserInput
    connect?: ReferralWalletWhereUniqueInput
  }

  export type PrimeStatusUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PrimeStatusCreateWithoutUserInput, PrimeStatusUncheckedCreateWithoutUserInput>
    connectOrCreate?: PrimeStatusCreateOrConnectWithoutUserInput
    connect?: PrimeStatusWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TradeReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<TradeReviewCreateWithoutReviewerInput, TradeReviewUncheckedCreateWithoutReviewerInput> | TradeReviewCreateWithoutReviewerInput[] | TradeReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutReviewerInput | TradeReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: TradeReviewCreateManyReviewerInputEnvelope
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
  }

  export type TradeReviewUncheckedCreateNestedManyWithoutReviewedInput = {
    create?: XOR<TradeReviewCreateWithoutReviewedInput, TradeReviewUncheckedCreateWithoutReviewedInput> | TradeReviewCreateWithoutReviewedInput[] | TradeReviewUncheckedCreateWithoutReviewedInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutReviewedInput | TradeReviewCreateOrConnectWithoutReviewedInput[]
    createMany?: TradeReviewCreateManyReviewedInputEnvelope
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput> | OfferCreateWithoutUserInput[] | OfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutUserInput | OfferCreateOrConnectWithoutUserInput[]
    createMany?: OfferCreateManyUserInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdatepaymentMethodsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type RoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput> | RoleCreateWithoutUserInput[] | RoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput | RoleCreateOrConnectWithoutUserInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutUserInput | RoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoleCreateManyUserInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutUserInput | RoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutUserInput | RoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type ReferralCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput> | ReferralCodeCreateWithoutUserInput[] | ReferralCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUserInput | ReferralCodeCreateOrConnectWithoutUserInput[]
    upsert?: ReferralCodeUpsertWithWhereUniqueWithoutUserInput | ReferralCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralCodeCreateManyUserInputEnvelope
    set?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    disconnect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    delete?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    connect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    update?: ReferralCodeUpdateWithWhereUniqueWithoutUserInput | ReferralCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralCodeUpdateManyWithWhereWithoutUserInput | ReferralCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralCodeScalarWhereInput | ReferralCodeScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput> | ReferralCreateWithoutRefereeInput[] | ReferralUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput | ReferralCreateOrConnectWithoutRefereeInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutRefereeInput | ReferralUpsertWithWhereUniqueWithoutRefereeInput[]
    createMany?: ReferralCreateManyRefereeInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutRefereeInput | ReferralUpdateWithWhereUniqueWithoutRefereeInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutRefereeInput | ReferralUpdateManyWithWhereWithoutRefereeInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralWalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<ReferralWalletCreateWithoutUserInput, ReferralWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReferralWalletCreateOrConnectWithoutUserInput
    upsert?: ReferralWalletUpsertWithoutUserInput
    disconnect?: ReferralWalletWhereInput | boolean
    delete?: ReferralWalletWhereInput | boolean
    connect?: ReferralWalletWhereUniqueInput
    update?: XOR<XOR<ReferralWalletUpdateToOneWithWhereWithoutUserInput, ReferralWalletUpdateWithoutUserInput>, ReferralWalletUncheckedUpdateWithoutUserInput>
  }

  export type PrimeStatusUpdateOneWithoutUserNestedInput = {
    create?: XOR<PrimeStatusCreateWithoutUserInput, PrimeStatusUncheckedCreateWithoutUserInput>
    connectOrCreate?: PrimeStatusCreateOrConnectWithoutUserInput
    upsert?: PrimeStatusUpsertWithoutUserInput
    disconnect?: PrimeStatusWhereInput | boolean
    delete?: PrimeStatusWhereInput | boolean
    connect?: PrimeStatusWhereUniqueInput
    update?: XOR<XOR<PrimeStatusUpdateToOneWithWhereWithoutUserInput, PrimeStatusUpdateWithoutUserInput>, PrimeStatusUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TradeReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<TradeReviewCreateWithoutReviewerInput, TradeReviewUncheckedCreateWithoutReviewerInput> | TradeReviewCreateWithoutReviewerInput[] | TradeReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutReviewerInput | TradeReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: TradeReviewUpsertWithWhereUniqueWithoutReviewerInput | TradeReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: TradeReviewCreateManyReviewerInputEnvelope
    set?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    disconnect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    delete?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    update?: TradeReviewUpdateWithWhereUniqueWithoutReviewerInput | TradeReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: TradeReviewUpdateManyWithWhereWithoutReviewerInput | TradeReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: TradeReviewScalarWhereInput | TradeReviewScalarWhereInput[]
  }

  export type TradeReviewUpdateManyWithoutReviewedNestedInput = {
    create?: XOR<TradeReviewCreateWithoutReviewedInput, TradeReviewUncheckedCreateWithoutReviewedInput> | TradeReviewCreateWithoutReviewedInput[] | TradeReviewUncheckedCreateWithoutReviewedInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutReviewedInput | TradeReviewCreateOrConnectWithoutReviewedInput[]
    upsert?: TradeReviewUpsertWithWhereUniqueWithoutReviewedInput | TradeReviewUpsertWithWhereUniqueWithoutReviewedInput[]
    createMany?: TradeReviewCreateManyReviewedInputEnvelope
    set?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    disconnect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    delete?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    update?: TradeReviewUpdateWithWhereUniqueWithoutReviewedInput | TradeReviewUpdateWithWhereUniqueWithoutReviewedInput[]
    updateMany?: TradeReviewUpdateManyWithWhereWithoutReviewedInput | TradeReviewUpdateManyWithWhereWithoutReviewedInput[]
    deleteMany?: TradeReviewScalarWhereInput | TradeReviewScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutUserNestedInput = {
    create?: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput> | OfferCreateWithoutUserInput[] | OfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutUserInput | OfferCreateOrConnectWithoutUserInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutUserInput | OfferUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OfferCreateManyUserInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutUserInput | OfferUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutUserInput | OfferUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput> | RoleCreateWithoutUserInput[] | RoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput | RoleCreateOrConnectWithoutUserInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutUserInput | RoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoleCreateManyUserInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutUserInput | RoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutUserInput | RoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type ReferralCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput> | ReferralCodeCreateWithoutUserInput[] | ReferralCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutUserInput | ReferralCodeCreateOrConnectWithoutUserInput[]
    upsert?: ReferralCodeUpsertWithWhereUniqueWithoutUserInput | ReferralCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralCodeCreateManyUserInputEnvelope
    set?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    disconnect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    delete?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    connect?: ReferralCodeWhereUniqueInput | ReferralCodeWhereUniqueInput[]
    update?: ReferralCodeUpdateWithWhereUniqueWithoutUserInput | ReferralCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralCodeUpdateManyWithWhereWithoutUserInput | ReferralCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralCodeScalarWhereInput | ReferralCodeScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput> | ReferralCreateWithoutRefereeInput[] | ReferralUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput | ReferralCreateOrConnectWithoutRefereeInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutRefereeInput | ReferralUpsertWithWhereUniqueWithoutRefereeInput[]
    createMany?: ReferralCreateManyRefereeInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutRefereeInput | ReferralUpdateWithWhereUniqueWithoutRefereeInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutRefereeInput | ReferralUpdateManyWithWhereWithoutRefereeInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralWalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ReferralWalletCreateWithoutUserInput, ReferralWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReferralWalletCreateOrConnectWithoutUserInput
    upsert?: ReferralWalletUpsertWithoutUserInput
    disconnect?: ReferralWalletWhereInput | boolean
    delete?: ReferralWalletWhereInput | boolean
    connect?: ReferralWalletWhereUniqueInput
    update?: XOR<XOR<ReferralWalletUpdateToOneWithWhereWithoutUserInput, ReferralWalletUpdateWithoutUserInput>, ReferralWalletUncheckedUpdateWithoutUserInput>
  }

  export type PrimeStatusUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PrimeStatusCreateWithoutUserInput, PrimeStatusUncheckedCreateWithoutUserInput>
    connectOrCreate?: PrimeStatusCreateOrConnectWithoutUserInput
    upsert?: PrimeStatusUpsertWithoutUserInput
    disconnect?: PrimeStatusWhereInput | boolean
    delete?: PrimeStatusWhereInput | boolean
    connect?: PrimeStatusWhereUniqueInput
    update?: XOR<XOR<PrimeStatusUpdateToOneWithWhereWithoutUserInput, PrimeStatusUpdateWithoutUserInput>, PrimeStatusUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<TradeReviewCreateWithoutReviewerInput, TradeReviewUncheckedCreateWithoutReviewerInput> | TradeReviewCreateWithoutReviewerInput[] | TradeReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutReviewerInput | TradeReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: TradeReviewUpsertWithWhereUniqueWithoutReviewerInput | TradeReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: TradeReviewCreateManyReviewerInputEnvelope
    set?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    disconnect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    delete?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    update?: TradeReviewUpdateWithWhereUniqueWithoutReviewerInput | TradeReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: TradeReviewUpdateManyWithWhereWithoutReviewerInput | TradeReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: TradeReviewScalarWhereInput | TradeReviewScalarWhereInput[]
  }

  export type TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput = {
    create?: XOR<TradeReviewCreateWithoutReviewedInput, TradeReviewUncheckedCreateWithoutReviewedInput> | TradeReviewCreateWithoutReviewedInput[] | TradeReviewUncheckedCreateWithoutReviewedInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutReviewedInput | TradeReviewCreateOrConnectWithoutReviewedInput[]
    upsert?: TradeReviewUpsertWithWhereUniqueWithoutReviewedInput | TradeReviewUpsertWithWhereUniqueWithoutReviewedInput[]
    createMany?: TradeReviewCreateManyReviewedInputEnvelope
    set?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    disconnect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    delete?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    update?: TradeReviewUpdateWithWhereUniqueWithoutReviewedInput | TradeReviewUpdateWithWhereUniqueWithoutReviewedInput[]
    updateMany?: TradeReviewUpdateManyWithWhereWithoutReviewedInput | TradeReviewUpdateManyWithWhereWithoutReviewedInput[]
    deleteMany?: TradeReviewScalarWhereInput | TradeReviewScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput> | OfferCreateWithoutUserInput[] | OfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutUserInput | OfferCreateOrConnectWithoutUserInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutUserInput | OfferUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OfferCreateManyUserInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutUserInput | OfferUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutUserInput | OfferUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type TradeReviewCreatereviewTagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutReviewsGivenInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsReceivedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EscrowCreateNestedOneWithoutReviewsInput = {
    create?: XOR<EscrowCreateWithoutReviewsInput, EscrowUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutReviewsInput
    connect?: EscrowWhereUniqueInput
  }

  export type TradeReviewUpdatereviewTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    upsert?: UserUpsertWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsGivenInput, UserUpdateWithoutReviewsGivenInput>, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    upsert?: UserUpsertWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsReceivedInput, UserUpdateWithoutReviewsReceivedInput>, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type EscrowUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<EscrowCreateWithoutReviewsInput, EscrowUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutReviewsInput
    upsert?: EscrowUpsertWithoutReviewsInput
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutReviewsInput, EscrowUpdateWithoutReviewsInput>, EscrowUncheckedUpdateWithoutReviewsInput>
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type EscrowTimelineCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput> | EscrowTimelineCreateWithoutEscrowInput[] | EscrowTimelineUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowTimelineCreateOrConnectWithoutEscrowInput | EscrowTimelineCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowTimelineCreateManyEscrowInputEnvelope
    connect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
  }

  export type EscrowMessageCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput> | EscrowMessageCreateWithoutEscrowInput[] | EscrowMessageUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowMessageCreateOrConnectWithoutEscrowInput | EscrowMessageCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowMessageCreateManyEscrowInputEnvelope
    connect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
  }

  export type EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput = {
    create?: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput
    connect?: EscrowPaymentInstructionWhereUniqueInput
  }

  export type EscrowFiatStatusCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput> | EscrowFiatStatusCreateWithoutEscrowInput[] | EscrowFiatStatusUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowFiatStatusCreateOrConnectWithoutEscrowInput | EscrowFiatStatusCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowFiatStatusCreateManyEscrowInputEnvelope
    connect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
  }

  export type EvidenceItemCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput> | EvidenceItemCreateWithoutEscrowInput[] | EvidenceItemUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EvidenceItemCreateOrConnectWithoutEscrowInput | EvidenceItemCreateOrConnectWithoutEscrowInput[]
    createMany?: EvidenceItemCreateManyEscrowInputEnvelope
    connect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
  }

  export type DisputeCreateNestedOneWithoutEscrowInput = {
    create?: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEscrowInput
    connect?: DisputeWhereUniqueInput
  }

  export type TradeReviewCreateNestedManyWithoutEscrowInput = {
    create?: XOR<TradeReviewCreateWithoutEscrowInput, TradeReviewUncheckedCreateWithoutEscrowInput> | TradeReviewCreateWithoutEscrowInput[] | TradeReviewUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutEscrowInput | TradeReviewCreateOrConnectWithoutEscrowInput[]
    createMany?: TradeReviewCreateManyEscrowInputEnvelope
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
  }

  export type EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput> | EscrowTimelineCreateWithoutEscrowInput[] | EscrowTimelineUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowTimelineCreateOrConnectWithoutEscrowInput | EscrowTimelineCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowTimelineCreateManyEscrowInputEnvelope
    connect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
  }

  export type EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput> | EscrowMessageCreateWithoutEscrowInput[] | EscrowMessageUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowMessageCreateOrConnectWithoutEscrowInput | EscrowMessageCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowMessageCreateManyEscrowInputEnvelope
    connect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
  }

  export type EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput = {
    create?: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput
    connect?: EscrowPaymentInstructionWhereUniqueInput
  }

  export type EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput> | EscrowFiatStatusCreateWithoutEscrowInput[] | EscrowFiatStatusUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowFiatStatusCreateOrConnectWithoutEscrowInput | EscrowFiatStatusCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowFiatStatusCreateManyEscrowInputEnvelope
    connect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
  }

  export type EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput> | EvidenceItemCreateWithoutEscrowInput[] | EvidenceItemUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EvidenceItemCreateOrConnectWithoutEscrowInput | EvidenceItemCreateOrConnectWithoutEscrowInput[]
    createMany?: EvidenceItemCreateManyEscrowInputEnvelope
    connect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
  }

  export type DisputeUncheckedCreateNestedOneWithoutEscrowInput = {
    create?: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEscrowInput
    connect?: DisputeWhereUniqueInput
  }

  export type TradeReviewUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<TradeReviewCreateWithoutEscrowInput, TradeReviewUncheckedCreateWithoutEscrowInput> | TradeReviewCreateWithoutEscrowInput[] | TradeReviewUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutEscrowInput | TradeReviewCreateOrConnectWithoutEscrowInput[]
    createMany?: TradeReviewCreateManyEscrowInputEnvelope
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EscrowTimelineUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput> | EscrowTimelineCreateWithoutEscrowInput[] | EscrowTimelineUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowTimelineCreateOrConnectWithoutEscrowInput | EscrowTimelineCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput | EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowTimelineCreateManyEscrowInputEnvelope
    set?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    disconnect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    delete?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    connect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    update?: EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput | EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowTimelineUpdateManyWithWhereWithoutEscrowInput | EscrowTimelineUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowTimelineScalarWhereInput | EscrowTimelineScalarWhereInput[]
  }

  export type EscrowMessageUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput> | EscrowMessageCreateWithoutEscrowInput[] | EscrowMessageUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowMessageCreateOrConnectWithoutEscrowInput | EscrowMessageCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput | EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowMessageCreateManyEscrowInputEnvelope
    set?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    disconnect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    delete?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    connect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    update?: EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput | EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowMessageUpdateManyWithWhereWithoutEscrowInput | EscrowMessageUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowMessageScalarWhereInput | EscrowMessageScalarWhereInput[]
  }

  export type EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput = {
    create?: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput
    upsert?: EscrowPaymentInstructionUpsertWithoutEscrowInput
    disconnect?: EscrowPaymentInstructionWhereInput | boolean
    delete?: EscrowPaymentInstructionWhereInput | boolean
    connect?: EscrowPaymentInstructionWhereUniqueInput
    update?: XOR<XOR<EscrowPaymentInstructionUpdateToOneWithWhereWithoutEscrowInput, EscrowPaymentInstructionUpdateWithoutEscrowInput>, EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowFiatStatusUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput> | EscrowFiatStatusCreateWithoutEscrowInput[] | EscrowFiatStatusUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowFiatStatusCreateOrConnectWithoutEscrowInput | EscrowFiatStatusCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput | EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowFiatStatusCreateManyEscrowInputEnvelope
    set?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    disconnect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    delete?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    connect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    update?: EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput | EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput | EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowFiatStatusScalarWhereInput | EscrowFiatStatusScalarWhereInput[]
  }

  export type EvidenceItemUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput> | EvidenceItemCreateWithoutEscrowInput[] | EvidenceItemUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EvidenceItemCreateOrConnectWithoutEscrowInput | EvidenceItemCreateOrConnectWithoutEscrowInput[]
    upsert?: EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput | EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EvidenceItemCreateManyEscrowInputEnvelope
    set?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    disconnect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    delete?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    connect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    update?: EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput | EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EvidenceItemUpdateManyWithWhereWithoutEscrowInput | EvidenceItemUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EvidenceItemScalarWhereInput | EvidenceItemScalarWhereInput[]
  }

  export type DisputeUpdateOneWithoutEscrowNestedInput = {
    create?: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEscrowInput
    upsert?: DisputeUpsertWithoutEscrowInput
    disconnect?: DisputeWhereInput | boolean
    delete?: DisputeWhereInput | boolean
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutEscrowInput, DisputeUpdateWithoutEscrowInput>, DisputeUncheckedUpdateWithoutEscrowInput>
  }

  export type TradeReviewUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<TradeReviewCreateWithoutEscrowInput, TradeReviewUncheckedCreateWithoutEscrowInput> | TradeReviewCreateWithoutEscrowInput[] | TradeReviewUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutEscrowInput | TradeReviewCreateOrConnectWithoutEscrowInput[]
    upsert?: TradeReviewUpsertWithWhereUniqueWithoutEscrowInput | TradeReviewUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: TradeReviewCreateManyEscrowInputEnvelope
    set?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    disconnect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    delete?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    update?: TradeReviewUpdateWithWhereUniqueWithoutEscrowInput | TradeReviewUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: TradeReviewUpdateManyWithWhereWithoutEscrowInput | TradeReviewUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: TradeReviewScalarWhereInput | TradeReviewScalarWhereInput[]
  }

  export type EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput> | EscrowTimelineCreateWithoutEscrowInput[] | EscrowTimelineUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowTimelineCreateOrConnectWithoutEscrowInput | EscrowTimelineCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput | EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowTimelineCreateManyEscrowInputEnvelope
    set?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    disconnect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    delete?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    connect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    update?: EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput | EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowTimelineUpdateManyWithWhereWithoutEscrowInput | EscrowTimelineUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowTimelineScalarWhereInput | EscrowTimelineScalarWhereInput[]
  }

  export type EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput> | EscrowMessageCreateWithoutEscrowInput[] | EscrowMessageUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowMessageCreateOrConnectWithoutEscrowInput | EscrowMessageCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput | EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowMessageCreateManyEscrowInputEnvelope
    set?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    disconnect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    delete?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    connect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    update?: EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput | EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowMessageUpdateManyWithWhereWithoutEscrowInput | EscrowMessageUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowMessageScalarWhereInput | EscrowMessageScalarWhereInput[]
  }

  export type EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput = {
    create?: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput
    upsert?: EscrowPaymentInstructionUpsertWithoutEscrowInput
    disconnect?: EscrowPaymentInstructionWhereInput | boolean
    delete?: EscrowPaymentInstructionWhereInput | boolean
    connect?: EscrowPaymentInstructionWhereUniqueInput
    update?: XOR<XOR<EscrowPaymentInstructionUpdateToOneWithWhereWithoutEscrowInput, EscrowPaymentInstructionUpdateWithoutEscrowInput>, EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput> | EscrowFiatStatusCreateWithoutEscrowInput[] | EscrowFiatStatusUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowFiatStatusCreateOrConnectWithoutEscrowInput | EscrowFiatStatusCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput | EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowFiatStatusCreateManyEscrowInputEnvelope
    set?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    disconnect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    delete?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    connect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    update?: EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput | EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput | EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowFiatStatusScalarWhereInput | EscrowFiatStatusScalarWhereInput[]
  }

  export type EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput> | EvidenceItemCreateWithoutEscrowInput[] | EvidenceItemUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EvidenceItemCreateOrConnectWithoutEscrowInput | EvidenceItemCreateOrConnectWithoutEscrowInput[]
    upsert?: EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput | EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EvidenceItemCreateManyEscrowInputEnvelope
    set?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    disconnect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    delete?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    connect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    update?: EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput | EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EvidenceItemUpdateManyWithWhereWithoutEscrowInput | EvidenceItemUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EvidenceItemScalarWhereInput | EvidenceItemScalarWhereInput[]
  }

  export type DisputeUncheckedUpdateOneWithoutEscrowNestedInput = {
    create?: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEscrowInput
    upsert?: DisputeUpsertWithoutEscrowInput
    disconnect?: DisputeWhereInput | boolean
    delete?: DisputeWhereInput | boolean
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutEscrowInput, DisputeUpdateWithoutEscrowInput>, DisputeUncheckedUpdateWithoutEscrowInput>
  }

  export type TradeReviewUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<TradeReviewCreateWithoutEscrowInput, TradeReviewUncheckedCreateWithoutEscrowInput> | TradeReviewCreateWithoutEscrowInput[] | TradeReviewUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: TradeReviewCreateOrConnectWithoutEscrowInput | TradeReviewCreateOrConnectWithoutEscrowInput[]
    upsert?: TradeReviewUpsertWithWhereUniqueWithoutEscrowInput | TradeReviewUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: TradeReviewCreateManyEscrowInputEnvelope
    set?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    disconnect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    delete?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    connect?: TradeReviewWhereUniqueInput | TradeReviewWhereUniqueInput[]
    update?: TradeReviewUpdateWithWhereUniqueWithoutEscrowInput | TradeReviewUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: TradeReviewUpdateManyWithWhereWithoutEscrowInput | TradeReviewUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: TradeReviewScalarWhereInput | TradeReviewScalarWhereInput[]
  }

  export type EscrowCreateNestedOneWithoutTimelineInput = {
    create?: XOR<EscrowCreateWithoutTimelineInput, EscrowUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutTimelineInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneRequiredWithoutTimelineNestedInput = {
    create?: XOR<EscrowCreateWithoutTimelineInput, EscrowUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutTimelineInput
    upsert?: EscrowUpsertWithoutTimelineInput
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutTimelineInput, EscrowUpdateWithoutTimelineInput>, EscrowUncheckedUpdateWithoutTimelineInput>
  }

  export type EscrowCreateNestedOneWithoutMessagesInput = {
    create?: XOR<EscrowCreateWithoutMessagesInput, EscrowUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutMessagesInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<EscrowCreateWithoutMessagesInput, EscrowUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutMessagesInput
    upsert?: EscrowUpsertWithoutMessagesInput
    disconnect?: EscrowWhereInput | boolean
    delete?: EscrowWhereInput | boolean
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutMessagesInput, EscrowUpdateWithoutMessagesInput>, EscrowUncheckedUpdateWithoutMessagesInput>
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type EscrowCreateNestedOneWithoutPaymentInstructionInput = {
    create?: XOR<EscrowCreateWithoutPaymentInstructionInput, EscrowUncheckedCreateWithoutPaymentInstructionInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutPaymentInstructionInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneRequiredWithoutPaymentInstructionNestedInput = {
    create?: XOR<EscrowCreateWithoutPaymentInstructionInput, EscrowUncheckedCreateWithoutPaymentInstructionInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutPaymentInstructionInput
    upsert?: EscrowUpsertWithoutPaymentInstructionInput
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutPaymentInstructionInput, EscrowUpdateWithoutPaymentInstructionInput>, EscrowUncheckedUpdateWithoutPaymentInstructionInput>
  }

  export type EscrowCreateNestedOneWithoutFiatStatusesInput = {
    create?: XOR<EscrowCreateWithoutFiatStatusesInput, EscrowUncheckedCreateWithoutFiatStatusesInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutFiatStatusesInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneWithoutFiatStatusesNestedInput = {
    create?: XOR<EscrowCreateWithoutFiatStatusesInput, EscrowUncheckedCreateWithoutFiatStatusesInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutFiatStatusesInput
    upsert?: EscrowUpsertWithoutFiatStatusesInput
    disconnect?: EscrowWhereInput | boolean
    delete?: EscrowWhereInput | boolean
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutFiatStatusesInput, EscrowUpdateWithoutFiatStatusesInput>, EscrowUncheckedUpdateWithoutFiatStatusesInput>
  }

  export type EscrowCreateNestedOneWithoutEvidenceInput = {
    create?: XOR<EscrowCreateWithoutEvidenceInput, EscrowUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutEvidenceInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneWithoutEvidenceNestedInput = {
    create?: XOR<EscrowCreateWithoutEvidenceInput, EscrowUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutEvidenceInput
    upsert?: EscrowUpsertWithoutEvidenceInput
    disconnect?: EscrowWhereInput | boolean
    delete?: EscrowWhereInput | boolean
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutEvidenceInput, EscrowUpdateWithoutEvidenceInput>, EscrowUncheckedUpdateWithoutEvidenceInput>
  }

  export type EscrowCreateNestedOneWithoutDisputeInput = {
    create?: XOR<EscrowCreateWithoutDisputeInput, EscrowUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutDisputeInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneRequiredWithoutDisputeNestedInput = {
    create?: XOR<EscrowCreateWithoutDisputeInput, EscrowUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutDisputeInput
    upsert?: EscrowUpsertWithoutDisputeInput
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutDisputeInput, EscrowUpdateWithoutDisputeInput>, EscrowUncheckedUpdateWithoutDisputeInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCreateNestedOneWithoutNotificationPreferenceInput = {
    create?: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferenceInput
    upsert?: UserUpsertWithoutNotificationPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferenceInput, UserUpdateWithoutNotificationPreferenceInput>, UserUncheckedUpdateWithoutNotificationPreferenceInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutReferralCodesInput = {
    create?: XOR<UserCreateWithoutReferralCodesInput, UserUncheckedCreateWithoutReferralCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralCodesInput
    connect?: UserWhereUniqueInput
  }

  export type ReferralCreateNestedManyWithoutReferralCodeInput = {
    create?: XOR<ReferralCreateWithoutReferralCodeInput, ReferralUncheckedCreateWithoutReferralCodeInput> | ReferralCreateWithoutReferralCodeInput[] | ReferralUncheckedCreateWithoutReferralCodeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferralCodeInput | ReferralCreateOrConnectWithoutReferralCodeInput[]
    createMany?: ReferralCreateManyReferralCodeInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferralCodeInput = {
    create?: XOR<ReferralCreateWithoutReferralCodeInput, ReferralUncheckedCreateWithoutReferralCodeInput> | ReferralCreateWithoutReferralCodeInput[] | ReferralUncheckedCreateWithoutReferralCodeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferralCodeInput | ReferralCreateOrConnectWithoutReferralCodeInput[]
    createMany?: ReferralCreateManyReferralCodeInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReferralCodesNestedInput = {
    create?: XOR<UserCreateWithoutReferralCodesInput, UserUncheckedCreateWithoutReferralCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralCodesInput
    upsert?: UserUpsertWithoutReferralCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralCodesInput, UserUpdateWithoutReferralCodesInput>, UserUncheckedUpdateWithoutReferralCodesInput>
  }

  export type ReferralUpdateManyWithoutReferralCodeNestedInput = {
    create?: XOR<ReferralCreateWithoutReferralCodeInput, ReferralUncheckedCreateWithoutReferralCodeInput> | ReferralCreateWithoutReferralCodeInput[] | ReferralUncheckedCreateWithoutReferralCodeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferralCodeInput | ReferralCreateOrConnectWithoutReferralCodeInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferralCodeInput | ReferralUpsertWithWhereUniqueWithoutReferralCodeInput[]
    createMany?: ReferralCreateManyReferralCodeInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferralCodeInput | ReferralUpdateWithWhereUniqueWithoutReferralCodeInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferralCodeInput | ReferralUpdateManyWithWhereWithoutReferralCodeInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferralCodeNestedInput = {
    create?: XOR<ReferralCreateWithoutReferralCodeInput, ReferralUncheckedCreateWithoutReferralCodeInput> | ReferralCreateWithoutReferralCodeInput[] | ReferralUncheckedCreateWithoutReferralCodeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferralCodeInput | ReferralCreateOrConnectWithoutReferralCodeInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferralCodeInput | ReferralUpsertWithWhereUniqueWithoutReferralCodeInput[]
    createMany?: ReferralCreateManyReferralCodeInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferralCodeInput | ReferralUpdateWithWhereUniqueWithoutReferralCodeInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferralCodeInput | ReferralUpdateManyWithWhereWithoutReferralCodeInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReferralsMadeInput = {
    create?: XOR<UserCreateWithoutReferralsMadeInput, UserUncheckedCreateWithoutReferralsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralsReceivedInput = {
    create?: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type ReferralCodeCreateNestedOneWithoutReferralsInput = {
    create?: XOR<ReferralCodeCreateWithoutReferralsInput, ReferralCodeUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutReferralsInput
    connect?: ReferralCodeWhereUniqueInput
  }

  export type CommissionLedgerCreateNestedManyWithoutReferralInput = {
    create?: XOR<CommissionLedgerCreateWithoutReferralInput, CommissionLedgerUncheckedCreateWithoutReferralInput> | CommissionLedgerCreateWithoutReferralInput[] | CommissionLedgerUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: CommissionLedgerCreateOrConnectWithoutReferralInput | CommissionLedgerCreateOrConnectWithoutReferralInput[]
    createMany?: CommissionLedgerCreateManyReferralInputEnvelope
    connect?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
  }

  export type CommissionLedgerUncheckedCreateNestedManyWithoutReferralInput = {
    create?: XOR<CommissionLedgerCreateWithoutReferralInput, CommissionLedgerUncheckedCreateWithoutReferralInput> | CommissionLedgerCreateWithoutReferralInput[] | CommissionLedgerUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: CommissionLedgerCreateOrConnectWithoutReferralInput | CommissionLedgerCreateOrConnectWithoutReferralInput[]
    createMany?: CommissionLedgerCreateManyReferralInputEnvelope
    connect?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReferralsMadeNestedInput = {
    create?: XOR<UserCreateWithoutReferralsMadeInput, UserUncheckedCreateWithoutReferralsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsMadeInput
    upsert?: UserUpsertWithoutReferralsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsMadeInput, UserUpdateWithoutReferralsMadeInput>, UserUncheckedUpdateWithoutReferralsMadeInput>
  }

  export type UserUpdateOneRequiredWithoutReferralsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsReceivedInput
    upsert?: UserUpsertWithoutReferralsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsReceivedInput, UserUpdateWithoutReferralsReceivedInput>, UserUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type ReferralCodeUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<ReferralCodeCreateWithoutReferralsInput, ReferralCodeUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: ReferralCodeCreateOrConnectWithoutReferralsInput
    upsert?: ReferralCodeUpsertWithoutReferralsInput
    connect?: ReferralCodeWhereUniqueInput
    update?: XOR<XOR<ReferralCodeUpdateToOneWithWhereWithoutReferralsInput, ReferralCodeUpdateWithoutReferralsInput>, ReferralCodeUncheckedUpdateWithoutReferralsInput>
  }

  export type CommissionLedgerUpdateManyWithoutReferralNestedInput = {
    create?: XOR<CommissionLedgerCreateWithoutReferralInput, CommissionLedgerUncheckedCreateWithoutReferralInput> | CommissionLedgerCreateWithoutReferralInput[] | CommissionLedgerUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: CommissionLedgerCreateOrConnectWithoutReferralInput | CommissionLedgerCreateOrConnectWithoutReferralInput[]
    upsert?: CommissionLedgerUpsertWithWhereUniqueWithoutReferralInput | CommissionLedgerUpsertWithWhereUniqueWithoutReferralInput[]
    createMany?: CommissionLedgerCreateManyReferralInputEnvelope
    set?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
    disconnect?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
    delete?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
    connect?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
    update?: CommissionLedgerUpdateWithWhereUniqueWithoutReferralInput | CommissionLedgerUpdateWithWhereUniqueWithoutReferralInput[]
    updateMany?: CommissionLedgerUpdateManyWithWhereWithoutReferralInput | CommissionLedgerUpdateManyWithWhereWithoutReferralInput[]
    deleteMany?: CommissionLedgerScalarWhereInput | CommissionLedgerScalarWhereInput[]
  }

  export type CommissionLedgerUncheckedUpdateManyWithoutReferralNestedInput = {
    create?: XOR<CommissionLedgerCreateWithoutReferralInput, CommissionLedgerUncheckedCreateWithoutReferralInput> | CommissionLedgerCreateWithoutReferralInput[] | CommissionLedgerUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: CommissionLedgerCreateOrConnectWithoutReferralInput | CommissionLedgerCreateOrConnectWithoutReferralInput[]
    upsert?: CommissionLedgerUpsertWithWhereUniqueWithoutReferralInput | CommissionLedgerUpsertWithWhereUniqueWithoutReferralInput[]
    createMany?: CommissionLedgerCreateManyReferralInputEnvelope
    set?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
    disconnect?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
    delete?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
    connect?: CommissionLedgerWhereUniqueInput | CommissionLedgerWhereUniqueInput[]
    update?: CommissionLedgerUpdateWithWhereUniqueWithoutReferralInput | CommissionLedgerUpdateWithWhereUniqueWithoutReferralInput[]
    updateMany?: CommissionLedgerUpdateManyWithWhereWithoutReferralInput | CommissionLedgerUpdateManyWithWhereWithoutReferralInput[]
    deleteMany?: CommissionLedgerScalarWhereInput | CommissionLedgerScalarWhereInput[]
  }

  export type ReferralCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<ReferralCreateWithoutCommissionsInput, ReferralUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutCommissionsInput
    connect?: ReferralWhereUniqueInput
  }

  export type ReferralUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<ReferralCreateWithoutCommissionsInput, ReferralUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutCommissionsInput
    upsert?: ReferralUpsertWithoutCommissionsInput
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutCommissionsInput, ReferralUpdateWithoutCommissionsInput>, ReferralUncheckedUpdateWithoutCommissionsInput>
  }

  export type UserCreateNestedOneWithoutReferralWalletInput = {
    create?: XOR<UserCreateWithoutReferralWalletInput, UserUncheckedCreateWithoutReferralWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralWalletInput
    connect?: UserWhereUniqueInput
  }

  export type ReferralWalletTransactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<ReferralWalletTransactionCreateWithoutWalletInput, ReferralWalletTransactionUncheckedCreateWithoutWalletInput> | ReferralWalletTransactionCreateWithoutWalletInput[] | ReferralWalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: ReferralWalletTransactionCreateOrConnectWithoutWalletInput | ReferralWalletTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: ReferralWalletTransactionCreateManyWalletInputEnvelope
    connect?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
  }

  export type ReferralWalletTransactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<ReferralWalletTransactionCreateWithoutWalletInput, ReferralWalletTransactionUncheckedCreateWithoutWalletInput> | ReferralWalletTransactionCreateWithoutWalletInput[] | ReferralWalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: ReferralWalletTransactionCreateOrConnectWithoutWalletInput | ReferralWalletTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: ReferralWalletTransactionCreateManyWalletInputEnvelope
    connect?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReferralWalletNestedInput = {
    create?: XOR<UserCreateWithoutReferralWalletInput, UserUncheckedCreateWithoutReferralWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralWalletInput
    upsert?: UserUpsertWithoutReferralWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralWalletInput, UserUpdateWithoutReferralWalletInput>, UserUncheckedUpdateWithoutReferralWalletInput>
  }

  export type ReferralWalletTransactionUpdateManyWithoutWalletNestedInput = {
    create?: XOR<ReferralWalletTransactionCreateWithoutWalletInput, ReferralWalletTransactionUncheckedCreateWithoutWalletInput> | ReferralWalletTransactionCreateWithoutWalletInput[] | ReferralWalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: ReferralWalletTransactionCreateOrConnectWithoutWalletInput | ReferralWalletTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: ReferralWalletTransactionUpsertWithWhereUniqueWithoutWalletInput | ReferralWalletTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: ReferralWalletTransactionCreateManyWalletInputEnvelope
    set?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
    disconnect?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
    delete?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
    connect?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
    update?: ReferralWalletTransactionUpdateWithWhereUniqueWithoutWalletInput | ReferralWalletTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: ReferralWalletTransactionUpdateManyWithWhereWithoutWalletInput | ReferralWalletTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: ReferralWalletTransactionScalarWhereInput | ReferralWalletTransactionScalarWhereInput[]
  }

  export type ReferralWalletTransactionUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<ReferralWalletTransactionCreateWithoutWalletInput, ReferralWalletTransactionUncheckedCreateWithoutWalletInput> | ReferralWalletTransactionCreateWithoutWalletInput[] | ReferralWalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: ReferralWalletTransactionCreateOrConnectWithoutWalletInput | ReferralWalletTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: ReferralWalletTransactionUpsertWithWhereUniqueWithoutWalletInput | ReferralWalletTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: ReferralWalletTransactionCreateManyWalletInputEnvelope
    set?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
    disconnect?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
    delete?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
    connect?: ReferralWalletTransactionWhereUniqueInput | ReferralWalletTransactionWhereUniqueInput[]
    update?: ReferralWalletTransactionUpdateWithWhereUniqueWithoutWalletInput | ReferralWalletTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: ReferralWalletTransactionUpdateManyWithWhereWithoutWalletInput | ReferralWalletTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: ReferralWalletTransactionScalarWhereInput | ReferralWalletTransactionScalarWhereInput[]
  }

  export type ReferralWalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ReferralWalletCreateWithoutTransactionsInput, ReferralWalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ReferralWalletCreateOrConnectWithoutTransactionsInput
    connect?: ReferralWalletWhereUniqueInput
  }

  export type ReferralWalletUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<ReferralWalletCreateWithoutTransactionsInput, ReferralWalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ReferralWalletCreateOrConnectWithoutTransactionsInput
    upsert?: ReferralWalletUpsertWithoutTransactionsInput
    connect?: ReferralWalletWhereUniqueInput
    update?: XOR<XOR<ReferralWalletUpdateToOneWithWhereWithoutTransactionsInput, ReferralWalletUpdateWithoutTransactionsInput>, ReferralWalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutPrimeInput = {
    create?: XOR<UserCreateWithoutPrimeInput, UserUncheckedCreateWithoutPrimeInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrimeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPrimeNestedInput = {
    create?: XOR<UserCreateWithoutPrimeInput, UserUncheckedCreateWithoutPrimeInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrimeInput
    upsert?: UserUpsertWithoutPrimeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrimeInput, UserUpdateWithoutPrimeInput>, UserUncheckedUpdateWithoutPrimeInput>
  }

  export type OfferCreatepaymentMethodsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutOffersInput = {
    create?: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersInput
    connect?: UserWhereUniqueInput
  }

  export type OfferUpdatepaymentMethodsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersInput
    upsert?: UserUpsertWithoutOffersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOffersInput, UserUpdateWithoutOffersInput>, UserUncheckedUpdateWithoutOffersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RoleCreateWithoutUserInput = {
    id?: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUserInput = {
    id?: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUserInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type RoleCreateManyUserInputEnvelope = {
    data: RoleCreateManyUserInput | RoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    webhookUrl?: string | null
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    webhookUrl?: string | null
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type ReferralCodeCreateWithoutUserInput = {
    id?: string
    code: string
    referralLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referrals?: ReferralCreateNestedManyWithoutReferralCodeInput
  }

  export type ReferralCodeUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    referralLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferralCodeInput
  }

  export type ReferralCodeCreateOrConnectWithoutUserInput = {
    where: ReferralCodeWhereUniqueInput
    create: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput>
  }

  export type ReferralCodeCreateManyUserInputEnvelope = {
    data: ReferralCodeCreateManyUserInput | ReferralCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referee: UserCreateNestedOneWithoutReferralsReceivedInput
    referralCode: ReferralCodeCreateNestedOneWithoutReferralsInput
    commissions?: CommissionLedgerCreateNestedManyWithoutReferralInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    refereeAddress: string
    referralCodeId: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissions?: CommissionLedgerUncheckedCreateNestedManyWithoutReferralInput
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutRefereeInput = {
    id?: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsMadeInput
    referralCode: ReferralCodeCreateNestedOneWithoutReferralsInput
    commissions?: CommissionLedgerCreateNestedManyWithoutReferralInput
  }

  export type ReferralUncheckedCreateWithoutRefereeInput = {
    id?: string
    referrerAddress: string
    referralCodeId: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissions?: CommissionLedgerUncheckedCreateNestedManyWithoutReferralInput
  }

  export type ReferralCreateOrConnectWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralCreateManyRefereeInputEnvelope = {
    data: ReferralCreateManyRefereeInput | ReferralCreateManyRefereeInput[]
    skipDuplicates?: boolean
  }

  export type ReferralWalletCreateWithoutUserInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: ReferralWalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type ReferralWalletUncheckedCreateWithoutUserInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: ReferralWalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type ReferralWalletCreateOrConnectWithoutUserInput = {
    where: ReferralWalletWhereUniqueInput
    create: XOR<ReferralWalletCreateWithoutUserInput, ReferralWalletUncheckedCreateWithoutUserInput>
  }

  export type PrimeStatusCreateWithoutUserInput = {
    id?: string
    isPrime?: boolean
    primeActivatedAt?: Date | string | null
    referralCount?: number
    qualifiedReferralCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrimeStatusUncheckedCreateWithoutUserInput = {
    id?: string
    isPrime?: boolean
    primeActivatedAt?: Date | string | null
    referralCount?: number
    qualifiedReferralCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrimeStatusCreateOrConnectWithoutUserInput = {
    where: PrimeStatusWhereUniqueInput
    create: XOR<PrimeStatusCreateWithoutUserInput, PrimeStatusUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TradeReviewCreateWithoutReviewerInput = {
    id?: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
    reviewed: UserCreateNestedOneWithoutReviewsReceivedInput
    escrow: EscrowCreateNestedOneWithoutReviewsInput
  }

  export type TradeReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    tradeId: Buffer
    reviewedAddress: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
  }

  export type TradeReviewCreateOrConnectWithoutReviewerInput = {
    where: TradeReviewWhereUniqueInput
    create: XOR<TradeReviewCreateWithoutReviewerInput, TradeReviewUncheckedCreateWithoutReviewerInput>
  }

  export type TradeReviewCreateManyReviewerInputEnvelope = {
    data: TradeReviewCreateManyReviewerInput | TradeReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type TradeReviewCreateWithoutReviewedInput = {
    id?: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    escrow: EscrowCreateNestedOneWithoutReviewsInput
  }

  export type TradeReviewUncheckedCreateWithoutReviewedInput = {
    id?: string
    tradeId: Buffer
    reviewerAddress: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
  }

  export type TradeReviewCreateOrConnectWithoutReviewedInput = {
    where: TradeReviewWhereUniqueInput
    create: XOR<TradeReviewCreateWithoutReviewedInput, TradeReviewUncheckedCreateWithoutReviewedInput>
  }

  export type TradeReviewCreateManyReviewedInputEnvelope = {
    data: TradeReviewCreateManyReviewedInput | TradeReviewCreateManyReviewedInput[]
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutUserInput = {
    id?: string
    type: string
    token: string
    currency: string
    priceType: string
    price: Decimal | DecimalJsLike | number | string
    minAmount: Decimal | DecimalJsLike | number | string
    maxAmount: Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferCreatepaymentMethodsInput | string[]
    terms?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    token: string
    currency: string
    priceType: string
    price: Decimal | DecimalJsLike | number | string
    minAmount: Decimal | DecimalJsLike | number | string
    maxAmount: Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferCreatepaymentMethodsInput | string[]
    terms?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferCreateOrConnectWithoutUserInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput>
  }

  export type OfferCreateManyUserInputEnvelope = {
    data: OfferCreateManyUserInput | OfferCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithWhereUniqueWithoutUserInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutUserInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
  }

  export type RoleUpdateManyWithWhereWithoutUserInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutUserInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    address?: StringFilter<"Role"> | string
    role?: StringFilter<"Role"> | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: ReferralCodeWhereUniqueInput
    update: XOR<ReferralCodeUpdateWithoutUserInput, ReferralCodeUncheckedUpdateWithoutUserInput>
    create: XOR<ReferralCodeCreateWithoutUserInput, ReferralCodeUncheckedCreateWithoutUserInput>
  }

  export type ReferralCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: ReferralCodeWhereUniqueInput
    data: XOR<ReferralCodeUpdateWithoutUserInput, ReferralCodeUncheckedUpdateWithoutUserInput>
  }

  export type ReferralCodeUpdateManyWithWhereWithoutUserInput = {
    where: ReferralCodeScalarWhereInput
    data: XOR<ReferralCodeUpdateManyMutationInput, ReferralCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralCodeScalarWhereInput = {
    AND?: ReferralCodeScalarWhereInput | ReferralCodeScalarWhereInput[]
    OR?: ReferralCodeScalarWhereInput[]
    NOT?: ReferralCodeScalarWhereInput | ReferralCodeScalarWhereInput[]
    id?: StringFilter<"ReferralCode"> | string
    address?: StringFilter<"ReferralCode"> | string
    code?: StringFilter<"ReferralCode"> | string
    referralLink?: StringFilter<"ReferralCode"> | string
    createdAt?: DateTimeFilter<"ReferralCode"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralCode"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerAddress?: StringFilter<"Referral"> | string
    refereeAddress?: StringFilter<"Referral"> | string
    referralCodeId?: StringFilter<"Referral"> | string
    qualified?: BoolFilter<"Referral"> | boolean
    qualifiedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralUpdateManyWithWhereWithoutRefereeInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutRefereeInput>
  }

  export type ReferralWalletUpsertWithoutUserInput = {
    update: XOR<ReferralWalletUpdateWithoutUserInput, ReferralWalletUncheckedUpdateWithoutUserInput>
    create: XOR<ReferralWalletCreateWithoutUserInput, ReferralWalletUncheckedCreateWithoutUserInput>
    where?: ReferralWalletWhereInput
  }

  export type ReferralWalletUpdateToOneWithWhereWithoutUserInput = {
    where?: ReferralWalletWhereInput
    data: XOR<ReferralWalletUpdateWithoutUserInput, ReferralWalletUncheckedUpdateWithoutUserInput>
  }

  export type ReferralWalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: ReferralWalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type ReferralWalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: ReferralWalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type PrimeStatusUpsertWithoutUserInput = {
    update: XOR<PrimeStatusUpdateWithoutUserInput, PrimeStatusUncheckedUpdateWithoutUserInput>
    create: XOR<PrimeStatusCreateWithoutUserInput, PrimeStatusUncheckedCreateWithoutUserInput>
    where?: PrimeStatusWhereInput
  }

  export type PrimeStatusUpdateToOneWithWhereWithoutUserInput = {
    where?: PrimeStatusWhereInput
    data: XOR<PrimeStatusUpdateWithoutUserInput, PrimeStatusUncheckedUpdateWithoutUserInput>
  }

  export type PrimeStatusUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    primeActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    qualifiedReferralCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrimeStatusUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    primeActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    qualifiedReferralCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    address?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type TradeReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: TradeReviewWhereUniqueInput
    update: XOR<TradeReviewUpdateWithoutReviewerInput, TradeReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<TradeReviewCreateWithoutReviewerInput, TradeReviewUncheckedCreateWithoutReviewerInput>
  }

  export type TradeReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: TradeReviewWhereUniqueInput
    data: XOR<TradeReviewUpdateWithoutReviewerInput, TradeReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type TradeReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: TradeReviewScalarWhereInput
    data: XOR<TradeReviewUpdateManyMutationInput, TradeReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type TradeReviewScalarWhereInput = {
    AND?: TradeReviewScalarWhereInput | TradeReviewScalarWhereInput[]
    OR?: TradeReviewScalarWhereInput[]
    NOT?: TradeReviewScalarWhereInput | TradeReviewScalarWhereInput[]
    id?: StringFilter<"TradeReview"> | string
    tradeId?: BytesFilter<"TradeReview"> | Buffer
    reviewerAddress?: StringFilter<"TradeReview"> | string
    reviewedAddress?: StringFilter<"TradeReview"> | string
    rating?: IntFilter<"TradeReview"> | number
    reviewText?: StringNullableFilter<"TradeReview"> | string | null
    reviewTags?: StringNullableListFilter<"TradeReview">
    tradeRole?: StringFilter<"TradeReview"> | string
    createdAt?: DateTimeFilter<"TradeReview"> | Date | string
  }

  export type TradeReviewUpsertWithWhereUniqueWithoutReviewedInput = {
    where: TradeReviewWhereUniqueInput
    update: XOR<TradeReviewUpdateWithoutReviewedInput, TradeReviewUncheckedUpdateWithoutReviewedInput>
    create: XOR<TradeReviewCreateWithoutReviewedInput, TradeReviewUncheckedCreateWithoutReviewedInput>
  }

  export type TradeReviewUpdateWithWhereUniqueWithoutReviewedInput = {
    where: TradeReviewWhereUniqueInput
    data: XOR<TradeReviewUpdateWithoutReviewedInput, TradeReviewUncheckedUpdateWithoutReviewedInput>
  }

  export type TradeReviewUpdateManyWithWhereWithoutReviewedInput = {
    where: TradeReviewScalarWhereInput
    data: XOR<TradeReviewUpdateManyMutationInput, TradeReviewUncheckedUpdateManyWithoutReviewedInput>
  }

  export type OfferUpsertWithWhereUniqueWithoutUserInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutUserInput, OfferUncheckedUpdateWithoutUserInput>
    create: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutUserInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutUserInput, OfferUncheckedUpdateWithoutUserInput>
  }

  export type OfferUpdateManyWithWhereWithoutUserInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutUserInput>
  }

  export type OfferScalarWhereInput = {
    AND?: OfferScalarWhereInput | OfferScalarWhereInput[]
    OR?: OfferScalarWhereInput[]
    NOT?: OfferScalarWhereInput | OfferScalarWhereInput[]
    id?: StringFilter<"Offer"> | string
    creator?: StringFilter<"Offer"> | string
    type?: StringFilter<"Offer"> | string
    token?: StringFilter<"Offer"> | string
    currency?: StringFilter<"Offer"> | string
    priceType?: StringFilter<"Offer"> | string
    price?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    paymentMethods?: StringNullableListFilter<"Offer">
    terms?: StringNullableFilter<"Offer"> | string | null
    status?: StringFilter<"Offer"> | string
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
  }

  export type UserCreateWithoutReviewsGivenInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsGivenInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
  }

  export type UserCreateWithoutReviewsReceivedInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsReceivedInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
  }

  export type EscrowCreateWithoutReviewsInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutReviewsInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutReviewsInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutReviewsInput, EscrowUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsGivenInput = {
    update: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateWithoutReviewsGivenInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsGivenInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReviewsReceivedInput = {
    update: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type UserUpdateWithoutReviewsReceivedInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsReceivedInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EscrowUpsertWithoutReviewsInput = {
    update: XOR<EscrowUpdateWithoutReviewsInput, EscrowUncheckedUpdateWithoutReviewsInput>
    create: XOR<EscrowCreateWithoutReviewsInput, EscrowUncheckedCreateWithoutReviewsInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutReviewsInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutReviewsInput, EscrowUncheckedUpdateWithoutReviewsInput>
  }

  export type EscrowUpdateWithoutReviewsInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutReviewsInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
  }

  export type UserCreateWithoutRolesInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EscrowTimelineCreateWithoutEscrowInput = {
    id?: bigint | number
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUncheckedCreateWithoutEscrowInput = {
    id?: bigint | number
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineCreateOrConnectWithoutEscrowInput = {
    where: EscrowTimelineWhereUniqueInput
    create: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowTimelineCreateManyEscrowInputEnvelope = {
    data: EscrowTimelineCreateManyEscrowInput | EscrowTimelineCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type EscrowMessageCreateWithoutEscrowInput = {
    id?: string
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowMessageUncheckedCreateWithoutEscrowInput = {
    id?: string
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowMessageCreateOrConnectWithoutEscrowInput = {
    where: EscrowMessageWhereUniqueInput
    create: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowMessageCreateManyEscrowInputEnvelope = {
    data: EscrowMessageCreateManyEscrowInput | EscrowMessageCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type EscrowPaymentInstructionCreateWithoutEscrowInput = {
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput = {
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput = {
    where: EscrowPaymentInstructionWhereUniqueInput
    create: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowFiatStatusCreateWithoutEscrowInput = {
    id?: bigint | number
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EscrowFiatStatusUncheckedCreateWithoutEscrowInput = {
    id?: bigint | number
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EscrowFiatStatusCreateOrConnectWithoutEscrowInput = {
    where: EscrowFiatStatusWhereUniqueInput
    create: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowFiatStatusCreateManyEscrowInputEnvelope = {
    data: EscrowFiatStatusCreateManyEscrowInput | EscrowFiatStatusCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type EvidenceItemCreateWithoutEscrowInput = {
    id?: string
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemUncheckedCreateWithoutEscrowInput = {
    id?: string
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemCreateOrConnectWithoutEscrowInput = {
    where: EvidenceItemWhereUniqueInput
    create: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput>
  }

  export type EvidenceItemCreateManyEscrowInputEnvelope = {
    data: EvidenceItemCreateManyEscrowInput | EvidenceItemCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type DisputeCreateWithoutEscrowInput = {
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    escalationLevel?: number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUncheckedCreateWithoutEscrowInput = {
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    escalationLevel?: number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeCreateOrConnectWithoutEscrowInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
  }

  export type TradeReviewCreateWithoutEscrowInput = {
    id?: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    reviewed: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type TradeReviewUncheckedCreateWithoutEscrowInput = {
    id?: string
    reviewerAddress: string
    reviewedAddress: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
  }

  export type TradeReviewCreateOrConnectWithoutEscrowInput = {
    where: TradeReviewWhereUniqueInput
    create: XOR<TradeReviewCreateWithoutEscrowInput, TradeReviewUncheckedCreateWithoutEscrowInput>
  }

  export type TradeReviewCreateManyEscrowInputEnvelope = {
    data: TradeReviewCreateManyEscrowInput | TradeReviewCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput = {
    where: EscrowTimelineWhereUniqueInput
    update: XOR<EscrowTimelineUpdateWithoutEscrowInput, EscrowTimelineUncheckedUpdateWithoutEscrowInput>
    create: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput = {
    where: EscrowTimelineWhereUniqueInput
    data: XOR<EscrowTimelineUpdateWithoutEscrowInput, EscrowTimelineUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowTimelineUpdateManyWithWhereWithoutEscrowInput = {
    where: EscrowTimelineScalarWhereInput
    data: XOR<EscrowTimelineUpdateManyMutationInput, EscrowTimelineUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EscrowTimelineScalarWhereInput = {
    AND?: EscrowTimelineScalarWhereInput | EscrowTimelineScalarWhereInput[]
    OR?: EscrowTimelineScalarWhereInput[]
    NOT?: EscrowTimelineScalarWhereInput | EscrowTimelineScalarWhereInput[]
    id?: BigIntFilter<"EscrowTimeline"> | bigint | number
    escrowId?: BytesFilter<"EscrowTimeline"> | Buffer
    chainId?: IntFilter<"EscrowTimeline"> | number
    eventName?: StringFilter<"EscrowTimeline"> | string
    stateAfter?: StringFilter<"EscrowTimeline"> | string
    txHash?: StringFilter<"EscrowTimeline"> | string
    blockNumber?: BigIntFilter<"EscrowTimeline"> | bigint | number
    logIndex?: IntFilter<"EscrowTimeline"> | number
    timestamp?: DateTimeFilter<"EscrowTimeline"> | Date | string
    payload?: JsonFilter<"EscrowTimeline">
  }

  export type EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput = {
    where: EscrowMessageWhereUniqueInput
    update: XOR<EscrowMessageUpdateWithoutEscrowInput, EscrowMessageUncheckedUpdateWithoutEscrowInput>
    create: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput = {
    where: EscrowMessageWhereUniqueInput
    data: XOR<EscrowMessageUpdateWithoutEscrowInput, EscrowMessageUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowMessageUpdateManyWithWhereWithoutEscrowInput = {
    where: EscrowMessageScalarWhereInput
    data: XOR<EscrowMessageUpdateManyMutationInput, EscrowMessageUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EscrowMessageScalarWhereInput = {
    AND?: EscrowMessageScalarWhereInput | EscrowMessageScalarWhereInput[]
    OR?: EscrowMessageScalarWhereInput[]
    NOT?: EscrowMessageScalarWhereInput | EscrowMessageScalarWhereInput[]
    id?: StringFilter<"EscrowMessage"> | string
    escrowId?: BytesNullableFilter<"EscrowMessage"> | Buffer | null
    sender?: StringFilter<"EscrowMessage"> | string
    text?: StringFilter<"EscrowMessage"> | string
    attachment?: StringNullableFilter<"EscrowMessage"> | string | null
    hash?: StringNullableFilter<"EscrowMessage"> | string | null
    createdAt?: DateTimeFilter<"EscrowMessage"> | Date | string
    editedAt?: DateTimeNullableFilter<"EscrowMessage"> | Date | string | null
  }

  export type EscrowPaymentInstructionUpsertWithoutEscrowInput = {
    update: XOR<EscrowPaymentInstructionUpdateWithoutEscrowInput, EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput>
    create: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    where?: EscrowPaymentInstructionWhereInput
  }

  export type EscrowPaymentInstructionUpdateToOneWithWhereWithoutEscrowInput = {
    where?: EscrowPaymentInstructionWhereInput
    data: XOR<EscrowPaymentInstructionUpdateWithoutEscrowInput, EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowPaymentInstructionUpdateWithoutEscrowInput = {
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput = {
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput = {
    where: EscrowFiatStatusWhereUniqueInput
    update: XOR<EscrowFiatStatusUpdateWithoutEscrowInput, EscrowFiatStatusUncheckedUpdateWithoutEscrowInput>
    create: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput = {
    where: EscrowFiatStatusWhereUniqueInput
    data: XOR<EscrowFiatStatusUpdateWithoutEscrowInput, EscrowFiatStatusUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput = {
    where: EscrowFiatStatusScalarWhereInput
    data: XOR<EscrowFiatStatusUpdateManyMutationInput, EscrowFiatStatusUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EscrowFiatStatusScalarWhereInput = {
    AND?: EscrowFiatStatusScalarWhereInput | EscrowFiatStatusScalarWhereInput[]
    OR?: EscrowFiatStatusScalarWhereInput[]
    NOT?: EscrowFiatStatusScalarWhereInput | EscrowFiatStatusScalarWhereInput[]
    id?: BigIntFilter<"EscrowFiatStatus"> | bigint | number
    escrowId?: BytesNullableFilter<"EscrowFiatStatus"> | Buffer | null
    actor?: StringFilter<"EscrowFiatStatus"> | string
    status?: StringFilter<"EscrowFiatStatus"> | string
    note?: StringNullableFilter<"EscrowFiatStatus"> | string | null
    createdAt?: DateTimeFilter<"EscrowFiatStatus"> | Date | string
  }

  export type EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput = {
    where: EvidenceItemWhereUniqueInput
    update: XOR<EvidenceItemUpdateWithoutEscrowInput, EvidenceItemUncheckedUpdateWithoutEscrowInput>
    create: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput>
  }

  export type EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput = {
    where: EvidenceItemWhereUniqueInput
    data: XOR<EvidenceItemUpdateWithoutEscrowInput, EvidenceItemUncheckedUpdateWithoutEscrowInput>
  }

  export type EvidenceItemUpdateManyWithWhereWithoutEscrowInput = {
    where: EvidenceItemScalarWhereInput
    data: XOR<EvidenceItemUpdateManyMutationInput, EvidenceItemUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EvidenceItemScalarWhereInput = {
    AND?: EvidenceItemScalarWhereInput | EvidenceItemScalarWhereInput[]
    OR?: EvidenceItemScalarWhereInput[]
    NOT?: EvidenceItemScalarWhereInput | EvidenceItemScalarWhereInput[]
    id?: StringFilter<"EvidenceItem"> | string
    escrowId?: BytesNullableFilter<"EvidenceItem"> | Buffer | null
    uploader?: StringFilter<"EvidenceItem"> | string
    uri?: StringFilter<"EvidenceItem"> | string
    sha256?: StringFilter<"EvidenceItem"> | string
    mime?: StringFilter<"EvidenceItem"> | string
    size?: BigIntFilter<"EvidenceItem"> | bigint | number
    description?: StringNullableFilter<"EvidenceItem"> | string | null
    createdAt?: DateTimeFilter<"EvidenceItem"> | Date | string
  }

  export type DisputeUpsertWithoutEscrowInput = {
    update: XOR<DisputeUpdateWithoutEscrowInput, DisputeUncheckedUpdateWithoutEscrowInput>
    create: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    where?: DisputeWhereInput
  }

  export type DisputeUpdateToOneWithWhereWithoutEscrowInput = {
    where?: DisputeWhereInput
    data: XOR<DisputeUpdateWithoutEscrowInput, DisputeUncheckedUpdateWithoutEscrowInput>
  }

  export type DisputeUpdateWithoutEscrowInput = {
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUncheckedUpdateWithoutEscrowInput = {
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    tier2Analysis?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewUpsertWithWhereUniqueWithoutEscrowInput = {
    where: TradeReviewWhereUniqueInput
    update: XOR<TradeReviewUpdateWithoutEscrowInput, TradeReviewUncheckedUpdateWithoutEscrowInput>
    create: XOR<TradeReviewCreateWithoutEscrowInput, TradeReviewUncheckedCreateWithoutEscrowInput>
  }

  export type TradeReviewUpdateWithWhereUniqueWithoutEscrowInput = {
    where: TradeReviewWhereUniqueInput
    data: XOR<TradeReviewUpdateWithoutEscrowInput, TradeReviewUncheckedUpdateWithoutEscrowInput>
  }

  export type TradeReviewUpdateManyWithWhereWithoutEscrowInput = {
    where: TradeReviewScalarWhereInput
    data: XOR<TradeReviewUpdateManyMutationInput, TradeReviewUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EscrowCreateWithoutTimelineInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutTimelineInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewUncheckedCreateNestedManyWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutTimelineInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutTimelineInput, EscrowUncheckedCreateWithoutTimelineInput>
  }

  export type EscrowUpsertWithoutTimelineInput = {
    update: XOR<EscrowUpdateWithoutTimelineInput, EscrowUncheckedUpdateWithoutTimelineInput>
    create: XOR<EscrowCreateWithoutTimelineInput, EscrowUncheckedCreateWithoutTimelineInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutTimelineInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutTimelineInput, EscrowUncheckedUpdateWithoutTimelineInput>
  }

  export type EscrowUpdateWithoutTimelineInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutTimelineInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUncheckedUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutMessagesInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutMessagesInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewUncheckedCreateNestedManyWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutMessagesInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutMessagesInput, EscrowUncheckedCreateWithoutMessagesInput>
  }

  export type EscrowUpsertWithoutMessagesInput = {
    update: XOR<EscrowUpdateWithoutMessagesInput, EscrowUncheckedUpdateWithoutMessagesInput>
    create: XOR<EscrowCreateWithoutMessagesInput, EscrowUncheckedCreateWithoutMessagesInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutMessagesInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutMessagesInput, EscrowUncheckedUpdateWithoutMessagesInput>
  }

  export type EscrowUpdateWithoutMessagesInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutMessagesInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUncheckedUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutPaymentInstructionInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutPaymentInstructionInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewUncheckedCreateNestedManyWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutPaymentInstructionInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutPaymentInstructionInput, EscrowUncheckedCreateWithoutPaymentInstructionInput>
  }

  export type EscrowUpsertWithoutPaymentInstructionInput = {
    update: XOR<EscrowUpdateWithoutPaymentInstructionInput, EscrowUncheckedUpdateWithoutPaymentInstructionInput>
    create: XOR<EscrowCreateWithoutPaymentInstructionInput, EscrowUncheckedCreateWithoutPaymentInstructionInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutPaymentInstructionInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutPaymentInstructionInput, EscrowUncheckedUpdateWithoutPaymentInstructionInput>
  }

  export type EscrowUpdateWithoutPaymentInstructionInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutPaymentInstructionInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUncheckedUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutFiatStatusesInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutFiatStatusesInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewUncheckedCreateNestedManyWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutFiatStatusesInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutFiatStatusesInput, EscrowUncheckedCreateWithoutFiatStatusesInput>
  }

  export type EscrowUpsertWithoutFiatStatusesInput = {
    update: XOR<EscrowUpdateWithoutFiatStatusesInput, EscrowUncheckedUpdateWithoutFiatStatusesInput>
    create: XOR<EscrowCreateWithoutFiatStatusesInput, EscrowUncheckedCreateWithoutFiatStatusesInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutFiatStatusesInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutFiatStatusesInput, EscrowUncheckedUpdateWithoutFiatStatusesInput>
  }

  export type EscrowUpdateWithoutFiatStatusesInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutFiatStatusesInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUncheckedUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutEvidenceInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutEvidenceInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
    reviews?: TradeReviewUncheckedCreateNestedManyWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutEvidenceInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutEvidenceInput, EscrowUncheckedCreateWithoutEvidenceInput>
  }

  export type EscrowUpsertWithoutEvidenceInput = {
    update: XOR<EscrowUpdateWithoutEvidenceInput, EscrowUncheckedUpdateWithoutEvidenceInput>
    create: XOR<EscrowCreateWithoutEvidenceInput, EscrowUncheckedCreateWithoutEvidenceInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutEvidenceInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutEvidenceInput, EscrowUncheckedUpdateWithoutEvidenceInput>
  }

  export type EscrowUpdateWithoutEvidenceInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutEvidenceInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
    reviews?: TradeReviewUncheckedUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutDisputeInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    reviews?: TradeReviewCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutDisputeInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    reviews?: TradeReviewUncheckedCreateNestedManyWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutDisputeInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutDisputeInput, EscrowUncheckedCreateWithoutDisputeInput>
  }

  export type EscrowUpsertWithoutDisputeInput = {
    update: XOR<EscrowUpdateWithoutDisputeInput, EscrowUncheckedUpdateWithoutDisputeInput>
    create: XOR<EscrowCreateWithoutDisputeInput, EscrowUncheckedCreateWithoutDisputeInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutDisputeInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutDisputeInput, EscrowUncheckedUpdateWithoutDisputeInput>
  }

  export type EscrowUpdateWithoutDisputeInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    reviews?: TradeReviewUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutDisputeInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    reviews?: TradeReviewUncheckedUpdateManyWithoutEscrowNestedInput
  }

  export type UserCreateWithoutNotificationPreferenceInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferenceInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
  }

  export type UserUpsertWithoutNotificationPreferenceInput = {
    update: XOR<UserUpdateWithoutNotificationPreferenceInput, UserUncheckedUpdateWithoutNotificationPreferenceInput>
    create: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferenceInput, UserUncheckedUpdateWithoutNotificationPreferenceInput>
  }

  export type UserUpdateWithoutNotificationPreferenceInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferenceInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReferralCodesInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralCodesInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralCodesInput, UserUncheckedCreateWithoutReferralCodesInput>
  }

  export type ReferralCreateWithoutReferralCodeInput = {
    id?: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsMadeInput
    referee: UserCreateNestedOneWithoutReferralsReceivedInput
    commissions?: CommissionLedgerCreateNestedManyWithoutReferralInput
  }

  export type ReferralUncheckedCreateWithoutReferralCodeInput = {
    id?: string
    referrerAddress: string
    refereeAddress: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissions?: CommissionLedgerUncheckedCreateNestedManyWithoutReferralInput
  }

  export type ReferralCreateOrConnectWithoutReferralCodeInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferralCodeInput, ReferralUncheckedCreateWithoutReferralCodeInput>
  }

  export type ReferralCreateManyReferralCodeInputEnvelope = {
    data: ReferralCreateManyReferralCodeInput | ReferralCreateManyReferralCodeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralCodesInput = {
    update: XOR<UserUpdateWithoutReferralCodesInput, UserUncheckedUpdateWithoutReferralCodesInput>
    create: XOR<UserCreateWithoutReferralCodesInput, UserUncheckedCreateWithoutReferralCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralCodesInput, UserUncheckedUpdateWithoutReferralCodesInput>
  }

  export type UserUpdateWithoutReferralCodesInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralCodesInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferralCodeInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferralCodeInput, ReferralUncheckedUpdateWithoutReferralCodeInput>
    create: XOR<ReferralCreateWithoutReferralCodeInput, ReferralUncheckedCreateWithoutReferralCodeInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferralCodeInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferralCodeInput, ReferralUncheckedUpdateWithoutReferralCodeInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferralCodeInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferralCodeInput>
  }

  export type UserCreateWithoutReferralsMadeInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsMadeInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsMadeInput, UserUncheckedCreateWithoutReferralsMadeInput>
  }

  export type UserCreateWithoutReferralsReceivedInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsReceivedInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
  }

  export type ReferralCodeCreateWithoutReferralsInput = {
    id?: string
    code: string
    referralLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReferralCodesInput
  }

  export type ReferralCodeUncheckedCreateWithoutReferralsInput = {
    id?: string
    address: string
    code: string
    referralLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCodeCreateOrConnectWithoutReferralsInput = {
    where: ReferralCodeWhereUniqueInput
    create: XOR<ReferralCodeCreateWithoutReferralsInput, ReferralCodeUncheckedCreateWithoutReferralsInput>
  }

  export type CommissionLedgerCreateWithoutReferralInput = {
    id?: string
    feeAmount: Decimal | DecimalJsLike | number | string
    commissionRate: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    feeType: string
    createdAt?: Date | string
  }

  export type CommissionLedgerUncheckedCreateWithoutReferralInput = {
    id?: string
    feeAmount: Decimal | DecimalJsLike | number | string
    commissionRate: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    feeType: string
    createdAt?: Date | string
  }

  export type CommissionLedgerCreateOrConnectWithoutReferralInput = {
    where: CommissionLedgerWhereUniqueInput
    create: XOR<CommissionLedgerCreateWithoutReferralInput, CommissionLedgerUncheckedCreateWithoutReferralInput>
  }

  export type CommissionLedgerCreateManyReferralInputEnvelope = {
    data: CommissionLedgerCreateManyReferralInput | CommissionLedgerCreateManyReferralInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralsMadeInput = {
    update: XOR<UserUpdateWithoutReferralsMadeInput, UserUncheckedUpdateWithoutReferralsMadeInput>
    create: XOR<UserCreateWithoutReferralsMadeInput, UserUncheckedCreateWithoutReferralsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsMadeInput, UserUncheckedUpdateWithoutReferralsMadeInput>
  }

  export type UserUpdateWithoutReferralsMadeInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsMadeInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferralsReceivedInput = {
    update: XOR<UserUpdateWithoutReferralsReceivedInput, UserUncheckedUpdateWithoutReferralsReceivedInput>
    create: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsReceivedInput, UserUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type UserUpdateWithoutReferralsReceivedInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsReceivedInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferralCodeUpsertWithoutReferralsInput = {
    update: XOR<ReferralCodeUpdateWithoutReferralsInput, ReferralCodeUncheckedUpdateWithoutReferralsInput>
    create: XOR<ReferralCodeCreateWithoutReferralsInput, ReferralCodeUncheckedCreateWithoutReferralsInput>
    where?: ReferralCodeWhereInput
  }

  export type ReferralCodeUpdateToOneWithWhereWithoutReferralsInput = {
    where?: ReferralCodeWhereInput
    data: XOR<ReferralCodeUpdateWithoutReferralsInput, ReferralCodeUncheckedUpdateWithoutReferralsInput>
  }

  export type ReferralCodeUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReferralCodesNestedInput
  }

  export type ReferralCodeUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionLedgerUpsertWithWhereUniqueWithoutReferralInput = {
    where: CommissionLedgerWhereUniqueInput
    update: XOR<CommissionLedgerUpdateWithoutReferralInput, CommissionLedgerUncheckedUpdateWithoutReferralInput>
    create: XOR<CommissionLedgerCreateWithoutReferralInput, CommissionLedgerUncheckedCreateWithoutReferralInput>
  }

  export type CommissionLedgerUpdateWithWhereUniqueWithoutReferralInput = {
    where: CommissionLedgerWhereUniqueInput
    data: XOR<CommissionLedgerUpdateWithoutReferralInput, CommissionLedgerUncheckedUpdateWithoutReferralInput>
  }

  export type CommissionLedgerUpdateManyWithWhereWithoutReferralInput = {
    where: CommissionLedgerScalarWhereInput
    data: XOR<CommissionLedgerUpdateManyMutationInput, CommissionLedgerUncheckedUpdateManyWithoutReferralInput>
  }

  export type CommissionLedgerScalarWhereInput = {
    AND?: CommissionLedgerScalarWhereInput | CommissionLedgerScalarWhereInput[]
    OR?: CommissionLedgerScalarWhereInput[]
    NOT?: CommissionLedgerScalarWhereInput | CommissionLedgerScalarWhereInput[]
    id?: StringFilter<"CommissionLedger"> | string
    referralId?: StringFilter<"CommissionLedger"> | string
    feeAmount?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFilter<"CommissionLedger"> | Decimal | DecimalJsLike | number | string
    feeType?: StringFilter<"CommissionLedger"> | string
    createdAt?: DateTimeFilter<"CommissionLedger"> | Date | string
  }

  export type ReferralCreateWithoutCommissionsInput = {
    id?: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsMadeInput
    referee: UserCreateNestedOneWithoutReferralsReceivedInput
    referralCode: ReferralCodeCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutCommissionsInput = {
    id?: string
    referrerAddress: string
    refereeAddress: string
    referralCodeId: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutCommissionsInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutCommissionsInput, ReferralUncheckedCreateWithoutCommissionsInput>
  }

  export type ReferralUpsertWithoutCommissionsInput = {
    update: XOR<ReferralUpdateWithoutCommissionsInput, ReferralUncheckedUpdateWithoutCommissionsInput>
    create: XOR<ReferralCreateWithoutCommissionsInput, ReferralUncheckedCreateWithoutCommissionsInput>
    where?: ReferralWhereInput
  }

  export type ReferralUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: ReferralWhereInput
    data: XOR<ReferralUpdateWithoutCommissionsInput, ReferralUncheckedUpdateWithoutCommissionsInput>
  }

  export type ReferralUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsMadeNestedInput
    referee?: UserUpdateOneRequiredWithoutReferralsReceivedNestedInput
    referralCode?: ReferralCodeUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerAddress?: StringFieldUpdateOperationsInput | string
    refereeAddress?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutReferralWalletInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralWalletInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralWalletInput, UserUncheckedCreateWithoutReferralWalletInput>
  }

  export type ReferralWalletTransactionCreateWithoutWalletInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    status: string
    targetAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralWalletTransactionUncheckedCreateWithoutWalletInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    status: string
    targetAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralWalletTransactionCreateOrConnectWithoutWalletInput = {
    where: ReferralWalletTransactionWhereUniqueInput
    create: XOR<ReferralWalletTransactionCreateWithoutWalletInput, ReferralWalletTransactionUncheckedCreateWithoutWalletInput>
  }

  export type ReferralWalletTransactionCreateManyWalletInputEnvelope = {
    data: ReferralWalletTransactionCreateManyWalletInput | ReferralWalletTransactionCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralWalletInput = {
    update: XOR<UserUpdateWithoutReferralWalletInput, UserUncheckedUpdateWithoutReferralWalletInput>
    create: XOR<UserCreateWithoutReferralWalletInput, UserUncheckedCreateWithoutReferralWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralWalletInput, UserUncheckedUpdateWithoutReferralWalletInput>
  }

  export type UserUpdateWithoutReferralWalletInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralWalletInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferralWalletTransactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: ReferralWalletTransactionWhereUniqueInput
    update: XOR<ReferralWalletTransactionUpdateWithoutWalletInput, ReferralWalletTransactionUncheckedUpdateWithoutWalletInput>
    create: XOR<ReferralWalletTransactionCreateWithoutWalletInput, ReferralWalletTransactionUncheckedCreateWithoutWalletInput>
  }

  export type ReferralWalletTransactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: ReferralWalletTransactionWhereUniqueInput
    data: XOR<ReferralWalletTransactionUpdateWithoutWalletInput, ReferralWalletTransactionUncheckedUpdateWithoutWalletInput>
  }

  export type ReferralWalletTransactionUpdateManyWithWhereWithoutWalletInput = {
    where: ReferralWalletTransactionScalarWhereInput
    data: XOR<ReferralWalletTransactionUpdateManyMutationInput, ReferralWalletTransactionUncheckedUpdateManyWithoutWalletInput>
  }

  export type ReferralWalletTransactionScalarWhereInput = {
    AND?: ReferralWalletTransactionScalarWhereInput | ReferralWalletTransactionScalarWhereInput[]
    OR?: ReferralWalletTransactionScalarWhereInput[]
    NOT?: ReferralWalletTransactionScalarWhereInput | ReferralWalletTransactionScalarWhereInput[]
    id?: StringFilter<"ReferralWalletTransaction"> | string
    walletId?: StringFilter<"ReferralWalletTransaction"> | string
    amount?: DecimalFilter<"ReferralWalletTransaction"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"ReferralWalletTransaction"> | string
    status?: StringFilter<"ReferralWalletTransaction"> | string
    targetAddress?: StringNullableFilter<"ReferralWalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"ReferralWalletTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"ReferralWalletTransaction"> | Date | string
  }

  export type ReferralWalletCreateWithoutTransactionsInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReferralWalletInput
  }

  export type ReferralWalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    address: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralWalletCreateOrConnectWithoutTransactionsInput = {
    where: ReferralWalletWhereUniqueInput
    create: XOR<ReferralWalletCreateWithoutTransactionsInput, ReferralWalletUncheckedCreateWithoutTransactionsInput>
  }

  export type ReferralWalletUpsertWithoutTransactionsInput = {
    update: XOR<ReferralWalletUpdateWithoutTransactionsInput, ReferralWalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ReferralWalletCreateWithoutTransactionsInput, ReferralWalletUncheckedCreateWithoutTransactionsInput>
    where?: ReferralWalletWhereInput
  }

  export type ReferralWalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ReferralWalletWhereInput
    data: XOR<ReferralWalletUpdateWithoutTransactionsInput, ReferralWalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type ReferralWalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReferralWalletNestedInput
  }

  export type ReferralWalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPrimeInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
    offers?: OfferCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPrimeInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPrimeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrimeInput, UserUncheckedCreateWithoutPrimeInput>
  }

  export type UserUpsertWithoutPrimeInput = {
    update: XOR<UserUpdateWithoutPrimeInput, UserUncheckedUpdateWithoutPrimeInput>
    create: XOR<UserCreateWithoutPrimeInput, UserUncheckedCreateWithoutPrimeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrimeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrimeInput, UserUncheckedUpdateWithoutPrimeInput>
  }

  export type UserUpdateWithoutPrimeInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPrimeInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOffersInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletCreateNestedOneWithoutUserInput
    prime?: PrimeStatusCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewCreateNestedManyWithoutReviewedInput
  }

  export type UserUncheckedCreateWithoutOffersInput = {
    address: string
    displayName?: string | null
    bio?: string | null
    paymentMethods?: UserCreatepaymentMethodsInput | string[]
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    reputationScore?: number
    successfulTrades?: number
    totalVolume?: Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    referralCodes?: ReferralCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    referralWallet?: ReferralWalletUncheckedCreateNestedOneWithoutUserInput
    prime?: PrimeStatusUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: TradeReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: TradeReviewUncheckedCreateNestedManyWithoutReviewedInput
  }

  export type UserCreateOrConnectWithoutOffersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
  }

  export type UserUpsertWithoutOffersInput = {
    update: XOR<UserUpdateWithoutOffersInput, UserUncheckedUpdateWithoutOffersInput>
    create: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOffersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOffersInput, UserUncheckedUpdateWithoutOffersInput>
  }

  export type UserUpdateWithoutOffersInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUpdateManyWithoutReviewedNestedInput
  }

  export type UserUncheckedUpdateWithoutOffersInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: UserUpdatepaymentMethodsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reputationScore?: IntFieldUpdateOperationsInput | number
    successfulTrades?: IntFieldUpdateOperationsInput | number
    totalVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    referralCodes?: ReferralCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    referralWallet?: ReferralWalletUncheckedUpdateOneWithoutUserNestedInput
    prime?: PrimeStatusUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: TradeReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: TradeReviewUncheckedUpdateManyWithoutReviewedNestedInput
  }

  export type RoleCreateManyUserInput = {
    id?: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type ReferralCodeCreateManyUserInput = {
    id?: string
    code: string
    referralLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    refereeAddress: string
    referralCodeId: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyRefereeInput = {
    id?: string
    referrerAddress: string
    referralCodeId: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TradeReviewCreateManyReviewerInput = {
    id?: string
    tradeId: Buffer
    reviewedAddress: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
  }

  export type TradeReviewCreateManyReviewedInput = {
    id?: string
    tradeId: Buffer
    reviewerAddress: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
  }

  export type OfferCreateManyUserInput = {
    id?: string
    type: string
    token: string
    currency: string
    priceType: string
    price: Decimal | DecimalJsLike | number | string
    minAmount: Decimal | DecimalJsLike | number | string
    maxAmount: Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferCreatepaymentMethodsInput | string[]
    terms?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: ReferralUpdateManyWithoutReferralCodeNestedInput
  }

  export type ReferralCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: ReferralUncheckedUpdateManyWithoutReferralCodeNestedInput
  }

  export type ReferralCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referralLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referee?: UserUpdateOneRequiredWithoutReferralsReceivedNestedInput
    referralCode?: ReferralCodeUpdateOneRequiredWithoutReferralsNestedInput
    commissions?: CommissionLedgerUpdateManyWithoutReferralNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeAddress?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: CommissionLedgerUncheckedUpdateManyWithoutReferralNestedInput
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeAddress?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsMadeNestedInput
    referralCode?: ReferralCodeUpdateOneRequiredWithoutReferralsNestedInput
    commissions?: CommissionLedgerUpdateManyWithoutReferralNestedInput
  }

  export type ReferralUncheckedUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerAddress?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: CommissionLedgerUncheckedUpdateManyWithoutReferralNestedInput
  }

  export type ReferralUncheckedUpdateManyWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerAddress?: StringFieldUpdateOperationsInput | string
    referralCodeId?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
    escrow?: EscrowUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type TradeReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeId?: BytesFieldUpdateOperationsInput | Buffer
    reviewedAddress?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeId?: BytesFieldUpdateOperationsInput | Buffer
    reviewedAddress?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewUpdateWithoutReviewedInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    escrow?: EscrowUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type TradeReviewUncheckedUpdateWithoutReviewedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeId?: BytesFieldUpdateOperationsInput | Buffer
    reviewerAddress?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewUncheckedUpdateManyWithoutReviewedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeId?: BytesFieldUpdateOperationsInput | Buffer
    reviewerAddress?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferUpdatepaymentMethodsInput | string[]
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferUpdatepaymentMethodsInput | string[]
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethods?: OfferUpdatepaymentMethodsInput | string[]
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowTimelineCreateManyEscrowInput = {
    id?: bigint | number
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowMessageCreateManyEscrowInput = {
    id?: string
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowFiatStatusCreateManyEscrowInput = {
    id?: bigint | number
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemCreateManyEscrowInput = {
    id?: string
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type TradeReviewCreateManyEscrowInput = {
    id?: string
    reviewerAddress: string
    reviewedAddress: string
    rating: number
    reviewText?: string | null
    reviewTags?: TradeReviewCreatereviewTagsInput | string[]
    tradeRole: string
    createdAt?: Date | string
  }

  export type EscrowTimelineUpdateWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUncheckedUpdateWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUncheckedUpdateManyWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowMessageUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowMessageUncheckedUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowMessageUncheckedUpdateManyWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowFiatStatusUpdateWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusUncheckedUpdateWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusUncheckedUpdateManyWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemUncheckedUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemUncheckedUpdateManyWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    reviewed?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
  }

  export type TradeReviewUncheckedUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerAddress?: StringFieldUpdateOperationsInput | string
    reviewedAddress?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeReviewUncheckedUpdateManyWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerAddress?: StringFieldUpdateOperationsInput | string
    reviewedAddress?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTags?: TradeReviewUpdatereviewTagsInput | string[]
    tradeRole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyReferralCodeInput = {
    id?: string
    referrerAddress: string
    refereeAddress: string
    qualified?: boolean
    qualifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateWithoutReferralCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsMadeNestedInput
    referee?: UserUpdateOneRequiredWithoutReferralsReceivedNestedInput
    commissions?: CommissionLedgerUpdateManyWithoutReferralNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferralCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerAddress?: StringFieldUpdateOperationsInput | string
    refereeAddress?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: CommissionLedgerUncheckedUpdateManyWithoutReferralNestedInput
  }

  export type ReferralUncheckedUpdateManyWithoutReferralCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerAddress?: StringFieldUpdateOperationsInput | string
    refereeAddress?: StringFieldUpdateOperationsInput | string
    qualified?: BoolFieldUpdateOperationsInput | boolean
    qualifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionLedgerCreateManyReferralInput = {
    id?: string
    feeAmount: Decimal | DecimalJsLike | number | string
    commissionRate: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    feeType: string
    createdAt?: Date | string
  }

  export type CommissionLedgerUpdateWithoutReferralInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionLedgerUncheckedUpdateWithoutReferralInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionLedgerUncheckedUpdateManyWithoutReferralInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralWalletTransactionCreateManyWalletInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    status: string
    targetAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralWalletTransactionUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralWalletTransactionUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralWalletTransactionUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowCountOutputTypeDefaultArgs instead
     */
    export type EscrowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralCodeCountOutputTypeDefaultArgs instead
     */
    export type ReferralCodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralCodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralCountOutputTypeDefaultArgs instead
     */
    export type ReferralCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralWalletCountOutputTypeDefaultArgs instead
     */
    export type ReferralWalletCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralWalletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TradeReviewDefaultArgs instead
     */
    export type TradeReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TradeReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowDefaultArgs instead
     */
    export type EscrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowTimelineDefaultArgs instead
     */
    export type EscrowTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowTimelineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowMessageDefaultArgs instead
     */
    export type EscrowMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowPaymentInstructionDefaultArgs instead
     */
    export type EscrowPaymentInstructionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowPaymentInstructionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowFiatStatusDefaultArgs instead
     */
    export type EscrowFiatStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowFiatStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenceItemDefaultArgs instead
     */
    export type EvidenceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DisputeDefaultArgs instead
     */
    export type DisputeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DisputeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndexerCheckpointDefaultArgs instead
     */
    export type IndexerCheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndexerCheckpointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenRegistryDefaultArgs instead
     */
    export type TokenRegistryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenRegistryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NonceDefaultArgs instead
     */
    export type NonceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NonceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationPreferenceDefaultArgs instead
     */
    export type NotificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralCodeDefaultArgs instead
     */
    export type ReferralCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralDefaultArgs instead
     */
    export type ReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommissionLedgerDefaultArgs instead
     */
    export type CommissionLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommissionLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralWalletDefaultArgs instead
     */
    export type ReferralWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralWalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralWalletTransactionDefaultArgs instead
     */
    export type ReferralWalletTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralWalletTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrimeStatusDefaultArgs instead
     */
    export type PrimeStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrimeStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralConfigDefaultArgs instead
     */
    export type ReferralConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferDefaultArgs instead
     */
    export type OfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OfferDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}