
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Escrow
 * 
 */
export type Escrow = $Result.DefaultSelection<Prisma.$EscrowPayload>
/**
 * Model EscrowTimeline
 * 
 */
export type EscrowTimeline = $Result.DefaultSelection<Prisma.$EscrowTimelinePayload>
/**
 * Model EscrowMessage
 * 
 */
export type EscrowMessage = $Result.DefaultSelection<Prisma.$EscrowMessagePayload>
/**
 * Model EscrowPaymentInstruction
 * 
 */
export type EscrowPaymentInstruction = $Result.DefaultSelection<Prisma.$EscrowPaymentInstructionPayload>
/**
 * Model EscrowFiatStatus
 * 
 */
export type EscrowFiatStatus = $Result.DefaultSelection<Prisma.$EscrowFiatStatusPayload>
/**
 * Model EvidenceItem
 * 
 */
export type EvidenceItem = $Result.DefaultSelection<Prisma.$EvidenceItemPayload>
/**
 * Model Dispute
 * 
 */
export type Dispute = $Result.DefaultSelection<Prisma.$DisputePayload>
/**
 * Model IndexerCheckpoint
 * 
 */
export type IndexerCheckpoint = $Result.DefaultSelection<Prisma.$IndexerCheckpointPayload>
/**
 * Model TokenRegistry
 * 
 */
export type TokenRegistry = $Result.DefaultSelection<Prisma.$TokenRegistryPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Nonce
 * 
 */
export type Nonce = $Result.DefaultSelection<Prisma.$NoncePayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.escrow`: Exposes CRUD operations for the **Escrow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escrows
    * const escrows = await prisma.escrow.findMany()
    * ```
    */
  get escrow(): Prisma.EscrowDelegate<ExtArgs>;

  /**
   * `prisma.escrowTimeline`: Exposes CRUD operations for the **EscrowTimeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowTimelines
    * const escrowTimelines = await prisma.escrowTimeline.findMany()
    * ```
    */
  get escrowTimeline(): Prisma.EscrowTimelineDelegate<ExtArgs>;

  /**
   * `prisma.escrowMessage`: Exposes CRUD operations for the **EscrowMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowMessages
    * const escrowMessages = await prisma.escrowMessage.findMany()
    * ```
    */
  get escrowMessage(): Prisma.EscrowMessageDelegate<ExtArgs>;

  /**
   * `prisma.escrowPaymentInstruction`: Exposes CRUD operations for the **EscrowPaymentInstruction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowPaymentInstructions
    * const escrowPaymentInstructions = await prisma.escrowPaymentInstruction.findMany()
    * ```
    */
  get escrowPaymentInstruction(): Prisma.EscrowPaymentInstructionDelegate<ExtArgs>;

  /**
   * `prisma.escrowFiatStatus`: Exposes CRUD operations for the **EscrowFiatStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscrowFiatStatuses
    * const escrowFiatStatuses = await prisma.escrowFiatStatus.findMany()
    * ```
    */
  get escrowFiatStatus(): Prisma.EscrowFiatStatusDelegate<ExtArgs>;

  /**
   * `prisma.evidenceItem`: Exposes CRUD operations for the **EvidenceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvidenceItems
    * const evidenceItems = await prisma.evidenceItem.findMany()
    * ```
    */
  get evidenceItem(): Prisma.EvidenceItemDelegate<ExtArgs>;

  /**
   * `prisma.dispute`: Exposes CRUD operations for the **Dispute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disputes
    * const disputes = await prisma.dispute.findMany()
    * ```
    */
  get dispute(): Prisma.DisputeDelegate<ExtArgs>;

  /**
   * `prisma.indexerCheckpoint`: Exposes CRUD operations for the **IndexerCheckpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndexerCheckpoints
    * const indexerCheckpoints = await prisma.indexerCheckpoint.findMany()
    * ```
    */
  get indexerCheckpoint(): Prisma.IndexerCheckpointDelegate<ExtArgs>;

  /**
   * `prisma.tokenRegistry`: Exposes CRUD operations for the **TokenRegistry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenRegistries
    * const tokenRegistries = await prisma.tokenRegistry.findMany()
    * ```
    */
  get tokenRegistry(): Prisma.TokenRegistryDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.nonce`: Exposes CRUD operations for the **Nonce** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nonces
    * const nonces = await prisma.nonce.findMany()
    * ```
    */
  get nonce(): Prisma.NonceDelegate<ExtArgs>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Escrow: 'Escrow',
    EscrowTimeline: 'EscrowTimeline',
    EscrowMessage: 'EscrowMessage',
    EscrowPaymentInstruction: 'EscrowPaymentInstruction',
    EscrowFiatStatus: 'EscrowFiatStatus',
    EvidenceItem: 'EvidenceItem',
    Dispute: 'Dispute',
    IndexerCheckpoint: 'IndexerCheckpoint',
    TokenRegistry: 'TokenRegistry',
    AuditLog: 'AuditLog',
    Nonce: 'Nonce',
    NotificationPreference: 'NotificationPreference'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "role" | "escrow" | "escrowTimeline" | "escrowMessage" | "escrowPaymentInstruction" | "escrowFiatStatus" | "evidenceItem" | "dispute" | "indexerCheckpoint" | "tokenRegistry" | "auditLog" | "nonce" | "notificationPreference"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Escrow: {
        payload: Prisma.$EscrowPayload<ExtArgs>
        fields: Prisma.EscrowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          findFirst: {
            args: Prisma.EscrowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          findMany: {
            args: Prisma.EscrowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>[]
          }
          create: {
            args: Prisma.EscrowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          createMany: {
            args: Prisma.EscrowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>[]
          }
          delete: {
            args: Prisma.EscrowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          update: {
            args: Prisma.EscrowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          deleteMany: {
            args: Prisma.EscrowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPayload>
          }
          aggregate: {
            args: Prisma.EscrowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrow>
          }
          groupBy: {
            args: Prisma.EscrowGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowCountAggregateOutputType> | number
          }
        }
      }
      EscrowTimeline: {
        payload: Prisma.$EscrowTimelinePayload<ExtArgs>
        fields: Prisma.EscrowTimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowTimelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowTimelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          findFirst: {
            args: Prisma.EscrowTimelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowTimelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          findMany: {
            args: Prisma.EscrowTimelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>[]
          }
          create: {
            args: Prisma.EscrowTimelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          createMany: {
            args: Prisma.EscrowTimelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowTimelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>[]
          }
          delete: {
            args: Prisma.EscrowTimelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          update: {
            args: Prisma.EscrowTimelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          deleteMany: {
            args: Prisma.EscrowTimelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowTimelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowTimelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowTimelinePayload>
          }
          aggregate: {
            args: Prisma.EscrowTimelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrowTimeline>
          }
          groupBy: {
            args: Prisma.EscrowTimelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowTimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowTimelineCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowTimelineCountAggregateOutputType> | number
          }
        }
      }
      EscrowMessage: {
        payload: Prisma.$EscrowMessagePayload<ExtArgs>
        fields: Prisma.EscrowMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          findFirst: {
            args: Prisma.EscrowMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          findMany: {
            args: Prisma.EscrowMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>[]
          }
          create: {
            args: Prisma.EscrowMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          createMany: {
            args: Prisma.EscrowMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>[]
          }
          delete: {
            args: Prisma.EscrowMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          update: {
            args: Prisma.EscrowMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          deleteMany: {
            args: Prisma.EscrowMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowMessagePayload>
          }
          aggregate: {
            args: Prisma.EscrowMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrowMessage>
          }
          groupBy: {
            args: Prisma.EscrowMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowMessageCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowMessageCountAggregateOutputType> | number
          }
        }
      }
      EscrowPaymentInstruction: {
        payload: Prisma.$EscrowPaymentInstructionPayload<ExtArgs>
        fields: Prisma.EscrowPaymentInstructionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowPaymentInstructionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowPaymentInstructionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          findFirst: {
            args: Prisma.EscrowPaymentInstructionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowPaymentInstructionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          findMany: {
            args: Prisma.EscrowPaymentInstructionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>[]
          }
          create: {
            args: Prisma.EscrowPaymentInstructionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          createMany: {
            args: Prisma.EscrowPaymentInstructionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowPaymentInstructionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>[]
          }
          delete: {
            args: Prisma.EscrowPaymentInstructionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          update: {
            args: Prisma.EscrowPaymentInstructionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          deleteMany: {
            args: Prisma.EscrowPaymentInstructionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowPaymentInstructionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowPaymentInstructionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowPaymentInstructionPayload>
          }
          aggregate: {
            args: Prisma.EscrowPaymentInstructionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrowPaymentInstruction>
          }
          groupBy: {
            args: Prisma.EscrowPaymentInstructionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowPaymentInstructionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowPaymentInstructionCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowPaymentInstructionCountAggregateOutputType> | number
          }
        }
      }
      EscrowFiatStatus: {
        payload: Prisma.$EscrowFiatStatusPayload<ExtArgs>
        fields: Prisma.EscrowFiatStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscrowFiatStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscrowFiatStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          findFirst: {
            args: Prisma.EscrowFiatStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscrowFiatStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          findMany: {
            args: Prisma.EscrowFiatStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>[]
          }
          create: {
            args: Prisma.EscrowFiatStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          createMany: {
            args: Prisma.EscrowFiatStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscrowFiatStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>[]
          }
          delete: {
            args: Prisma.EscrowFiatStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          update: {
            args: Prisma.EscrowFiatStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          deleteMany: {
            args: Prisma.EscrowFiatStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscrowFiatStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscrowFiatStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscrowFiatStatusPayload>
          }
          aggregate: {
            args: Prisma.EscrowFiatStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrowFiatStatus>
          }
          groupBy: {
            args: Prisma.EscrowFiatStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowFiatStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscrowFiatStatusCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowFiatStatusCountAggregateOutputType> | number
          }
        }
      }
      EvidenceItem: {
        payload: Prisma.$EvidenceItemPayload<ExtArgs>
        fields: Prisma.EvidenceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          findFirst: {
            args: Prisma.EvidenceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          findMany: {
            args: Prisma.EvidenceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>[]
          }
          create: {
            args: Prisma.EvidenceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          createMany: {
            args: Prisma.EvidenceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>[]
          }
          delete: {
            args: Prisma.EvidenceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          update: {
            args: Prisma.EvidenceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          deleteMany: {
            args: Prisma.EvidenceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvidenceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceItemPayload>
          }
          aggregate: {
            args: Prisma.EvidenceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidenceItem>
          }
          groupBy: {
            args: Prisma.EvidenceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenceItemCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenceItemCountAggregateOutputType> | number
          }
        }
      }
      Dispute: {
        payload: Prisma.$DisputePayload<ExtArgs>
        fields: Prisma.DisputeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisputeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisputeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          findFirst: {
            args: Prisma.DisputeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisputeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          findMany: {
            args: Prisma.DisputeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          create: {
            args: Prisma.DisputeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          createMany: {
            args: Prisma.DisputeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisputeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          delete: {
            args: Prisma.DisputeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          update: {
            args: Prisma.DisputeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          deleteMany: {
            args: Prisma.DisputeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisputeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisputeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          aggregate: {
            args: Prisma.DisputeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispute>
          }
          groupBy: {
            args: Prisma.DisputeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisputeCountArgs<ExtArgs>
            result: $Utils.Optional<DisputeCountAggregateOutputType> | number
          }
        }
      }
      IndexerCheckpoint: {
        payload: Prisma.$IndexerCheckpointPayload<ExtArgs>
        fields: Prisma.IndexerCheckpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndexerCheckpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndexerCheckpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          findFirst: {
            args: Prisma.IndexerCheckpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndexerCheckpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          findMany: {
            args: Prisma.IndexerCheckpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>[]
          }
          create: {
            args: Prisma.IndexerCheckpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          createMany: {
            args: Prisma.IndexerCheckpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndexerCheckpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>[]
          }
          delete: {
            args: Prisma.IndexerCheckpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          update: {
            args: Prisma.IndexerCheckpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          deleteMany: {
            args: Prisma.IndexerCheckpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndexerCheckpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndexerCheckpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndexerCheckpointPayload>
          }
          aggregate: {
            args: Prisma.IndexerCheckpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndexerCheckpoint>
          }
          groupBy: {
            args: Prisma.IndexerCheckpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndexerCheckpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndexerCheckpointCountArgs<ExtArgs>
            result: $Utils.Optional<IndexerCheckpointCountAggregateOutputType> | number
          }
        }
      }
      TokenRegistry: {
        payload: Prisma.$TokenRegistryPayload<ExtArgs>
        fields: Prisma.TokenRegistryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenRegistryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenRegistryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          findFirst: {
            args: Prisma.TokenRegistryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenRegistryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          findMany: {
            args: Prisma.TokenRegistryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>[]
          }
          create: {
            args: Prisma.TokenRegistryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          createMany: {
            args: Prisma.TokenRegistryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenRegistryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>[]
          }
          delete: {
            args: Prisma.TokenRegistryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          update: {
            args: Prisma.TokenRegistryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          deleteMany: {
            args: Prisma.TokenRegistryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenRegistryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenRegistryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRegistryPayload>
          }
          aggregate: {
            args: Prisma.TokenRegistryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenRegistry>
          }
          groupBy: {
            args: Prisma.TokenRegistryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenRegistryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenRegistryCountArgs<ExtArgs>
            result: $Utils.Optional<TokenRegistryCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Nonce: {
        payload: Prisma.$NoncePayload<ExtArgs>
        fields: Prisma.NonceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NonceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NonceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          findFirst: {
            args: Prisma.NonceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NonceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          findMany: {
            args: Prisma.NonceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>[]
          }
          create: {
            args: Prisma.NonceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          createMany: {
            args: Prisma.NonceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NonceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>[]
          }
          delete: {
            args: Prisma.NonceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          update: {
            args: Prisma.NonceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          deleteMany: {
            args: Prisma.NonceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NonceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NonceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoncePayload>
          }
          aggregate: {
            args: Prisma.NonceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNonce>
          }
          groupBy: {
            args: Prisma.NonceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NonceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NonceCountArgs<ExtArgs>
            result: $Utils.Optional<NonceCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UserCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }


  /**
   * Count Type EscrowCountOutputType
   */

  export type EscrowCountOutputType = {
    timeline: number
    messages: number
    fiatStatuses: number
    evidence: number
  }

  export type EscrowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeline?: boolean | EscrowCountOutputTypeCountTimelineArgs
    messages?: boolean | EscrowCountOutputTypeCountMessagesArgs
    fiatStatuses?: boolean | EscrowCountOutputTypeCountFiatStatusesArgs
    evidence?: boolean | EscrowCountOutputTypeCountEvidenceArgs
  }

  // Custom InputTypes
  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowCountOutputType
     */
    select?: EscrowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowTimelineWhereInput
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowMessageWhereInput
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountFiatStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowFiatStatusWhereInput
  }

  /**
   * EscrowCountOutputType without action
   */
  export type EscrowCountOutputTypeCountEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    address: string | null
    displayName: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    address: string | null
    displayName: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    address: number
    displayName: number
    createdAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    address?: true
    displayName?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    address?: true
    displayName?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    address?: true
    displayName?: true
    createdAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    address: string
    displayName: string | null
    createdAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    displayName?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    roles?: boolean | User$rolesArgs<ExtArgs>
    notificationPreference?: boolean | User$notificationPreferenceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    displayName?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    address?: boolean
    displayName?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | User$rolesArgs<ExtArgs>
    notificationPreference?: boolean | User$notificationPreferenceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      roles: Prisma.$RolePayload<ExtArgs>[]
      notificationPreference: Prisma.$NotificationPreferencePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      address: string
      displayName: string | null
      createdAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `address`
     * const userWithAddressOnly = await prisma.user.findMany({ select: { address: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `address`
     * const userWithAddressOnly = await prisma.user.createManyAndReturn({ 
     *   select: { address: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany"> | Null>
    notificationPreference<T extends User$notificationPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferenceArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly address: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * User.notificationPreference
   */
  export type User$notificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    address: string | null
    role: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    address: string | null
    role: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    address: number
    role: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    address?: true
    role?: true
    createdBy?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    address?: true
    role?: true
    createdBy?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    address?: true
    role?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    address: string
    role: string
    createdBy: string | null
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    role?: boolean
    createdBy?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    role?: boolean
    createdBy?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    address?: boolean
    role?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      role: string
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly address: FieldRef<"Role", 'String'>
    readonly role: FieldRef<"Role", 'String'>
    readonly createdBy: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Escrow
   */

  export type AggregateEscrow = {
    _count: EscrowCountAggregateOutputType | null
    _avg: EscrowAvgAggregateOutputType | null
    _sum: EscrowSumAggregateOutputType | null
    _min: EscrowMinAggregateOutputType | null
    _max: EscrowMaxAggregateOutputType | null
  }

  export type EscrowAvgAggregateOutputType = {
    chainId: number | null
    amount: Decimal | null
    feeAmount: Decimal | null
    sellerBond: Decimal | null
    buyerBond: Decimal | null
    createdAtBlock: number | null
    updatedAtBlock: number | null
  }

  export type EscrowSumAggregateOutputType = {
    chainId: number | null
    amount: Decimal | null
    feeAmount: Decimal | null
    sellerBond: Decimal | null
    buyerBond: Decimal | null
    createdAtBlock: bigint | null
    updatedAtBlock: bigint | null
  }

  export type EscrowMinAggregateOutputType = {
    escrowId: Buffer | null
    chainId: number | null
    contractAddress: string | null
    tokenKey: string | null
    amount: Decimal | null
    feeAmount: Decimal | null
    sellerBond: Decimal | null
    buyerBond: Decimal | null
    state: string | null
    seller: string | null
    buyer: string | null
    createdAtBlock: bigint | null
    updatedAtBlock: bigint | null
    txHashCreate: string | null
    txHashLast: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EscrowMaxAggregateOutputType = {
    escrowId: Buffer | null
    chainId: number | null
    contractAddress: string | null
    tokenKey: string | null
    amount: Decimal | null
    feeAmount: Decimal | null
    sellerBond: Decimal | null
    buyerBond: Decimal | null
    state: string | null
    seller: string | null
    buyer: string | null
    createdAtBlock: bigint | null
    updatedAtBlock: bigint | null
    txHashCreate: string | null
    txHashLast: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EscrowCountAggregateOutputType = {
    escrowId: number
    chainId: number
    contractAddress: number
    tokenKey: number
    amount: number
    feeAmount: number
    sellerBond: number
    buyerBond: number
    state: number
    seller: number
    buyer: number
    createdAtBlock: number
    updatedAtBlock: number
    txHashCreate: number
    txHashLast: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EscrowAvgAggregateInputType = {
    chainId?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    createdAtBlock?: true
    updatedAtBlock?: true
  }

  export type EscrowSumAggregateInputType = {
    chainId?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    createdAtBlock?: true
    updatedAtBlock?: true
  }

  export type EscrowMinAggregateInputType = {
    escrowId?: true
    chainId?: true
    contractAddress?: true
    tokenKey?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    state?: true
    seller?: true
    buyer?: true
    createdAtBlock?: true
    updatedAtBlock?: true
    txHashCreate?: true
    txHashLast?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EscrowMaxAggregateInputType = {
    escrowId?: true
    chainId?: true
    contractAddress?: true
    tokenKey?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    state?: true
    seller?: true
    buyer?: true
    createdAtBlock?: true
    updatedAtBlock?: true
    txHashCreate?: true
    txHashLast?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EscrowCountAggregateInputType = {
    escrowId?: true
    chainId?: true
    contractAddress?: true
    tokenKey?: true
    amount?: true
    feeAmount?: true
    sellerBond?: true
    buyerBond?: true
    state?: true
    seller?: true
    buyer?: true
    createdAtBlock?: true
    updatedAtBlock?: true
    txHashCreate?: true
    txHashLast?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EscrowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escrow to aggregate.
     */
    where?: EscrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escrows to fetch.
     */
    orderBy?: EscrowOrderByWithRelationInput | EscrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Escrows
    **/
    _count?: true | EscrowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscrowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscrowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowMaxAggregateInputType
  }

  export type GetEscrowAggregateType<T extends EscrowAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrow[P]>
      : GetScalarType<T[P], AggregateEscrow[P]>
  }




  export type EscrowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowWhereInput
    orderBy?: EscrowOrderByWithAggregationInput | EscrowOrderByWithAggregationInput[]
    by: EscrowScalarFieldEnum[] | EscrowScalarFieldEnum
    having?: EscrowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowCountAggregateInputType | true
    _avg?: EscrowAvgAggregateInputType
    _sum?: EscrowSumAggregateInputType
    _min?: EscrowMinAggregateInputType
    _max?: EscrowMaxAggregateInputType
  }

  export type EscrowGroupByOutputType = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal
    feeAmount: Decimal
    sellerBond: Decimal
    buyerBond: Decimal
    state: string
    seller: string
    buyer: string | null
    createdAtBlock: bigint
    updatedAtBlock: bigint
    txHashCreate: string | null
    txHashLast: string | null
    createdAt: Date
    updatedAt: Date
    _count: EscrowCountAggregateOutputType | null
    _avg: EscrowAvgAggregateOutputType | null
    _sum: EscrowSumAggregateOutputType | null
    _min: EscrowMinAggregateOutputType | null
    _max: EscrowMaxAggregateOutputType | null
  }

  type GetEscrowGroupByPayload<T extends EscrowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowGroupByOutputType[P]>
        }
      >
    >


  export type EscrowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    chainId?: boolean
    contractAddress?: boolean
    tokenKey?: boolean
    amount?: boolean
    feeAmount?: boolean
    sellerBond?: boolean
    buyerBond?: boolean
    state?: boolean
    seller?: boolean
    buyer?: boolean
    createdAtBlock?: boolean
    updatedAtBlock?: boolean
    txHashCreate?: boolean
    txHashLast?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeline?: boolean | Escrow$timelineArgs<ExtArgs>
    messages?: boolean | Escrow$messagesArgs<ExtArgs>
    paymentInstruction?: boolean | Escrow$paymentInstructionArgs<ExtArgs>
    fiatStatuses?: boolean | Escrow$fiatStatusesArgs<ExtArgs>
    evidence?: boolean | Escrow$evidenceArgs<ExtArgs>
    dispute?: boolean | Escrow$disputeArgs<ExtArgs>
    _count?: boolean | EscrowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrow"]>

  export type EscrowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    chainId?: boolean
    contractAddress?: boolean
    tokenKey?: boolean
    amount?: boolean
    feeAmount?: boolean
    sellerBond?: boolean
    buyerBond?: boolean
    state?: boolean
    seller?: boolean
    buyer?: boolean
    createdAtBlock?: boolean
    updatedAtBlock?: boolean
    txHashCreate?: boolean
    txHashLast?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["escrow"]>

  export type EscrowSelectScalar = {
    escrowId?: boolean
    chainId?: boolean
    contractAddress?: boolean
    tokenKey?: boolean
    amount?: boolean
    feeAmount?: boolean
    sellerBond?: boolean
    buyerBond?: boolean
    state?: boolean
    seller?: boolean
    buyer?: boolean
    createdAtBlock?: boolean
    updatedAtBlock?: boolean
    txHashCreate?: boolean
    txHashLast?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EscrowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeline?: boolean | Escrow$timelineArgs<ExtArgs>
    messages?: boolean | Escrow$messagesArgs<ExtArgs>
    paymentInstruction?: boolean | Escrow$paymentInstructionArgs<ExtArgs>
    fiatStatuses?: boolean | Escrow$fiatStatusesArgs<ExtArgs>
    evidence?: boolean | Escrow$evidenceArgs<ExtArgs>
    dispute?: boolean | Escrow$disputeArgs<ExtArgs>
    _count?: boolean | EscrowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EscrowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EscrowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Escrow"
    objects: {
      timeline: Prisma.$EscrowTimelinePayload<ExtArgs>[]
      messages: Prisma.$EscrowMessagePayload<ExtArgs>[]
      paymentInstruction: Prisma.$EscrowPaymentInstructionPayload<ExtArgs> | null
      fiatStatuses: Prisma.$EscrowFiatStatusPayload<ExtArgs>[]
      evidence: Prisma.$EvidenceItemPayload<ExtArgs>[]
      dispute: Prisma.$DisputePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      escrowId: Buffer
      chainId: number
      contractAddress: string
      tokenKey: string
      amount: Prisma.Decimal
      feeAmount: Prisma.Decimal
      sellerBond: Prisma.Decimal
      buyerBond: Prisma.Decimal
      state: string
      seller: string
      buyer: string | null
      createdAtBlock: bigint
      updatedAtBlock: bigint
      txHashCreate: string | null
      txHashLast: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["escrow"]>
    composites: {}
  }

  type EscrowGetPayload<S extends boolean | null | undefined | EscrowDefaultArgs> = $Result.GetResult<Prisma.$EscrowPayload, S>

  type EscrowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowCountAggregateInputType | true
    }

  export interface EscrowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Escrow'], meta: { name: 'Escrow' } }
    /**
     * Find zero or one Escrow that matches the filter.
     * @param {EscrowFindUniqueArgs} args - Arguments to find a Escrow
     * @example
     * // Get one Escrow
     * const escrow = await prisma.escrow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowFindUniqueArgs>(args: SelectSubset<T, EscrowFindUniqueArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Escrow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowFindUniqueOrThrowArgs} args - Arguments to find a Escrow
     * @example
     * // Get one Escrow
     * const escrow = await prisma.escrow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Escrow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFindFirstArgs} args - Arguments to find a Escrow
     * @example
     * // Get one Escrow
     * const escrow = await prisma.escrow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowFindFirstArgs>(args?: SelectSubset<T, EscrowFindFirstArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Escrow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFindFirstOrThrowArgs} args - Arguments to find a Escrow
     * @example
     * // Get one Escrow
     * const escrow = await prisma.escrow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Escrows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escrows
     * const escrows = await prisma.escrow.findMany()
     * 
     * // Get first 10 Escrows
     * const escrows = await prisma.escrow.findMany({ take: 10 })
     * 
     * // Only select the `escrowId`
     * const escrowWithEscrowIdOnly = await prisma.escrow.findMany({ select: { escrowId: true } })
     * 
     */
    findMany<T extends EscrowFindManyArgs>(args?: SelectSubset<T, EscrowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Escrow.
     * @param {EscrowCreateArgs} args - Arguments to create a Escrow.
     * @example
     * // Create one Escrow
     * const Escrow = await prisma.escrow.create({
     *   data: {
     *     // ... data to create a Escrow
     *   }
     * })
     * 
     */
    create<T extends EscrowCreateArgs>(args: SelectSubset<T, EscrowCreateArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Escrows.
     * @param {EscrowCreateManyArgs} args - Arguments to create many Escrows.
     * @example
     * // Create many Escrows
     * const escrow = await prisma.escrow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowCreateManyArgs>(args?: SelectSubset<T, EscrowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escrows and returns the data saved in the database.
     * @param {EscrowCreateManyAndReturnArgs} args - Arguments to create many Escrows.
     * @example
     * // Create many Escrows
     * const escrow = await prisma.escrow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escrows and only return the `escrowId`
     * const escrowWithEscrowIdOnly = await prisma.escrow.createManyAndReturn({ 
     *   select: { escrowId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Escrow.
     * @param {EscrowDeleteArgs} args - Arguments to delete one Escrow.
     * @example
     * // Delete one Escrow
     * const Escrow = await prisma.escrow.delete({
     *   where: {
     *     // ... filter to delete one Escrow
     *   }
     * })
     * 
     */
    delete<T extends EscrowDeleteArgs>(args: SelectSubset<T, EscrowDeleteArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Escrow.
     * @param {EscrowUpdateArgs} args - Arguments to update one Escrow.
     * @example
     * // Update one Escrow
     * const escrow = await prisma.escrow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowUpdateArgs>(args: SelectSubset<T, EscrowUpdateArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Escrows.
     * @param {EscrowDeleteManyArgs} args - Arguments to filter Escrows to delete.
     * @example
     * // Delete a few Escrows
     * const { count } = await prisma.escrow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowDeleteManyArgs>(args?: SelectSubset<T, EscrowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escrows
     * const escrow = await prisma.escrow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowUpdateManyArgs>(args: SelectSubset<T, EscrowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Escrow.
     * @param {EscrowUpsertArgs} args - Arguments to update or create a Escrow.
     * @example
     * // Update or create a Escrow
     * const escrow = await prisma.escrow.upsert({
     *   create: {
     *     // ... data to create a Escrow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escrow we want to update
     *   }
     * })
     */
    upsert<T extends EscrowUpsertArgs>(args: SelectSubset<T, EscrowUpsertArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Escrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowCountArgs} args - Arguments to filter Escrows to count.
     * @example
     * // Count the number of Escrows
     * const count = await prisma.escrow.count({
     *   where: {
     *     // ... the filter for the Escrows we want to count
     *   }
     * })
    **/
    count<T extends EscrowCountArgs>(
      args?: Subset<T, EscrowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowAggregateArgs>(args: Subset<T, EscrowAggregateArgs>): Prisma.PrismaPromise<GetEscrowAggregateType<T>>

    /**
     * Group by Escrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowGroupByArgs['orderBy'] }
        : { orderBy?: EscrowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Escrow model
   */
  readonly fields: EscrowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Escrow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    timeline<T extends Escrow$timelineArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$timelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Escrow$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findMany"> | Null>
    paymentInstruction<T extends Escrow$paymentInstructionArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$paymentInstructionArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    fiatStatuses<T extends Escrow$fiatStatusesArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$fiatStatusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findMany"> | Null>
    evidence<T extends Escrow$evidenceArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$evidenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findMany"> | Null>
    dispute<T extends Escrow$disputeArgs<ExtArgs> = {}>(args?: Subset<T, Escrow$disputeArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Escrow model
   */ 
  interface EscrowFieldRefs {
    readonly escrowId: FieldRef<"Escrow", 'Bytes'>
    readonly chainId: FieldRef<"Escrow", 'Int'>
    readonly contractAddress: FieldRef<"Escrow", 'String'>
    readonly tokenKey: FieldRef<"Escrow", 'String'>
    readonly amount: FieldRef<"Escrow", 'Decimal'>
    readonly feeAmount: FieldRef<"Escrow", 'Decimal'>
    readonly sellerBond: FieldRef<"Escrow", 'Decimal'>
    readonly buyerBond: FieldRef<"Escrow", 'Decimal'>
    readonly state: FieldRef<"Escrow", 'String'>
    readonly seller: FieldRef<"Escrow", 'String'>
    readonly buyer: FieldRef<"Escrow", 'String'>
    readonly createdAtBlock: FieldRef<"Escrow", 'BigInt'>
    readonly updatedAtBlock: FieldRef<"Escrow", 'BigInt'>
    readonly txHashCreate: FieldRef<"Escrow", 'String'>
    readonly txHashLast: FieldRef<"Escrow", 'String'>
    readonly createdAt: FieldRef<"Escrow", 'DateTime'>
    readonly updatedAt: FieldRef<"Escrow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Escrow findUnique
   */
  export type EscrowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrow to fetch.
     */
    where: EscrowWhereUniqueInput
  }

  /**
   * Escrow findUniqueOrThrow
   */
  export type EscrowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrow to fetch.
     */
    where: EscrowWhereUniqueInput
  }

  /**
   * Escrow findFirst
   */
  export type EscrowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrow to fetch.
     */
    where?: EscrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escrows to fetch.
     */
    orderBy?: EscrowOrderByWithRelationInput | EscrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escrows.
     */
    cursor?: EscrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escrows.
     */
    distinct?: EscrowScalarFieldEnum | EscrowScalarFieldEnum[]
  }

  /**
   * Escrow findFirstOrThrow
   */
  export type EscrowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrow to fetch.
     */
    where?: EscrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escrows to fetch.
     */
    orderBy?: EscrowOrderByWithRelationInput | EscrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escrows.
     */
    cursor?: EscrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escrows.
     */
    distinct?: EscrowScalarFieldEnum | EscrowScalarFieldEnum[]
  }

  /**
   * Escrow findMany
   */
  export type EscrowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter, which Escrows to fetch.
     */
    where?: EscrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escrows to fetch.
     */
    orderBy?: EscrowOrderByWithRelationInput | EscrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Escrows.
     */
    cursor?: EscrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escrows.
     */
    skip?: number
    distinct?: EscrowScalarFieldEnum | EscrowScalarFieldEnum[]
  }

  /**
   * Escrow create
   */
  export type EscrowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * The data needed to create a Escrow.
     */
    data: XOR<EscrowCreateInput, EscrowUncheckedCreateInput>
  }

  /**
   * Escrow createMany
   */
  export type EscrowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Escrows.
     */
    data: EscrowCreateManyInput | EscrowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Escrow createManyAndReturn
   */
  export type EscrowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Escrows.
     */
    data: EscrowCreateManyInput | EscrowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Escrow update
   */
  export type EscrowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * The data needed to update a Escrow.
     */
    data: XOR<EscrowUpdateInput, EscrowUncheckedUpdateInput>
    /**
     * Choose, which Escrow to update.
     */
    where: EscrowWhereUniqueInput
  }

  /**
   * Escrow updateMany
   */
  export type EscrowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Escrows.
     */
    data: XOR<EscrowUpdateManyMutationInput, EscrowUncheckedUpdateManyInput>
    /**
     * Filter which Escrows to update
     */
    where?: EscrowWhereInput
  }

  /**
   * Escrow upsert
   */
  export type EscrowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * The filter to search for the Escrow to update in case it exists.
     */
    where: EscrowWhereUniqueInput
    /**
     * In case the Escrow found by the `where` argument doesn't exist, create a new Escrow with this data.
     */
    create: XOR<EscrowCreateInput, EscrowUncheckedCreateInput>
    /**
     * In case the Escrow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowUpdateInput, EscrowUncheckedUpdateInput>
  }

  /**
   * Escrow delete
   */
  export type EscrowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    /**
     * Filter which Escrow to delete.
     */
    where: EscrowWhereUniqueInput
  }

  /**
   * Escrow deleteMany
   */
  export type EscrowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escrows to delete
     */
    where?: EscrowWhereInput
  }

  /**
   * Escrow.timeline
   */
  export type Escrow$timelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    where?: EscrowTimelineWhereInput
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    cursor?: EscrowTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscrowTimelineScalarFieldEnum | EscrowTimelineScalarFieldEnum[]
  }

  /**
   * Escrow.messages
   */
  export type Escrow$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    where?: EscrowMessageWhereInput
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    cursor?: EscrowMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscrowMessageScalarFieldEnum | EscrowMessageScalarFieldEnum[]
  }

  /**
   * Escrow.paymentInstruction
   */
  export type Escrow$paymentInstructionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    where?: EscrowPaymentInstructionWhereInput
  }

  /**
   * Escrow.fiatStatuses
   */
  export type Escrow$fiatStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    where?: EscrowFiatStatusWhereInput
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    cursor?: EscrowFiatStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscrowFiatStatusScalarFieldEnum | EscrowFiatStatusScalarFieldEnum[]
  }

  /**
   * Escrow.evidence
   */
  export type Escrow$evidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    where?: EvidenceItemWhereInput
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    cursor?: EvidenceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceItemScalarFieldEnum | EvidenceItemScalarFieldEnum[]
  }

  /**
   * Escrow.dispute
   */
  export type Escrow$disputeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    where?: DisputeWhereInput
  }

  /**
   * Escrow without action
   */
  export type EscrowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
  }


  /**
   * Model EscrowTimeline
   */

  export type AggregateEscrowTimeline = {
    _count: EscrowTimelineCountAggregateOutputType | null
    _avg: EscrowTimelineAvgAggregateOutputType | null
    _sum: EscrowTimelineSumAggregateOutputType | null
    _min: EscrowTimelineMinAggregateOutputType | null
    _max: EscrowTimelineMaxAggregateOutputType | null
  }

  export type EscrowTimelineAvgAggregateOutputType = {
    id: number | null
    chainId: number | null
    blockNumber: number | null
    logIndex: number | null
  }

  export type EscrowTimelineSumAggregateOutputType = {
    id: bigint | null
    chainId: number | null
    blockNumber: bigint | null
    logIndex: number | null
  }

  export type EscrowTimelineMinAggregateOutputType = {
    id: bigint | null
    escrowId: Buffer | null
    chainId: number | null
    eventName: string | null
    stateAfter: string | null
    txHash: string | null
    blockNumber: bigint | null
    logIndex: number | null
    timestamp: Date | null
  }

  export type EscrowTimelineMaxAggregateOutputType = {
    id: bigint | null
    escrowId: Buffer | null
    chainId: number | null
    eventName: string | null
    stateAfter: string | null
    txHash: string | null
    blockNumber: bigint | null
    logIndex: number | null
    timestamp: Date | null
  }

  export type EscrowTimelineCountAggregateOutputType = {
    id: number
    escrowId: number
    chainId: number
    eventName: number
    stateAfter: number
    txHash: number
    blockNumber: number
    logIndex: number
    timestamp: number
    payload: number
    _all: number
  }


  export type EscrowTimelineAvgAggregateInputType = {
    id?: true
    chainId?: true
    blockNumber?: true
    logIndex?: true
  }

  export type EscrowTimelineSumAggregateInputType = {
    id?: true
    chainId?: true
    blockNumber?: true
    logIndex?: true
  }

  export type EscrowTimelineMinAggregateInputType = {
    id?: true
    escrowId?: true
    chainId?: true
    eventName?: true
    stateAfter?: true
    txHash?: true
    blockNumber?: true
    logIndex?: true
    timestamp?: true
  }

  export type EscrowTimelineMaxAggregateInputType = {
    id?: true
    escrowId?: true
    chainId?: true
    eventName?: true
    stateAfter?: true
    txHash?: true
    blockNumber?: true
    logIndex?: true
    timestamp?: true
  }

  export type EscrowTimelineCountAggregateInputType = {
    id?: true
    escrowId?: true
    chainId?: true
    eventName?: true
    stateAfter?: true
    txHash?: true
    blockNumber?: true
    logIndex?: true
    timestamp?: true
    payload?: true
    _all?: true
  }

  export type EscrowTimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowTimeline to aggregate.
     */
    where?: EscrowTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowTimelines to fetch.
     */
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowTimelines
    **/
    _count?: true | EscrowTimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscrowTimelineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscrowTimelineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowTimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowTimelineMaxAggregateInputType
  }

  export type GetEscrowTimelineAggregateType<T extends EscrowTimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowTimeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowTimeline[P]>
      : GetScalarType<T[P], AggregateEscrowTimeline[P]>
  }




  export type EscrowTimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowTimelineWhereInput
    orderBy?: EscrowTimelineOrderByWithAggregationInput | EscrowTimelineOrderByWithAggregationInput[]
    by: EscrowTimelineScalarFieldEnum[] | EscrowTimelineScalarFieldEnum
    having?: EscrowTimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowTimelineCountAggregateInputType | true
    _avg?: EscrowTimelineAvgAggregateInputType
    _sum?: EscrowTimelineSumAggregateInputType
    _min?: EscrowTimelineMinAggregateInputType
    _max?: EscrowTimelineMaxAggregateInputType
  }

  export type EscrowTimelineGroupByOutputType = {
    id: bigint
    escrowId: Buffer
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint
    logIndex: number
    timestamp: Date
    payload: JsonValue
    _count: EscrowTimelineCountAggregateOutputType | null
    _avg: EscrowTimelineAvgAggregateOutputType | null
    _sum: EscrowTimelineSumAggregateOutputType | null
    _min: EscrowTimelineMinAggregateOutputType | null
    _max: EscrowTimelineMaxAggregateOutputType | null
  }

  type GetEscrowTimelineGroupByPayload<T extends EscrowTimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowTimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowTimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowTimelineGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowTimelineGroupByOutputType[P]>
        }
      >
    >


  export type EscrowTimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    chainId?: boolean
    eventName?: boolean
    stateAfter?: boolean
    txHash?: boolean
    blockNumber?: boolean
    logIndex?: boolean
    timestamp?: boolean
    payload?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrowTimeline"]>

  export type EscrowTimelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    chainId?: boolean
    eventName?: boolean
    stateAfter?: boolean
    txHash?: boolean
    blockNumber?: boolean
    logIndex?: boolean
    timestamp?: boolean
    payload?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrowTimeline"]>

  export type EscrowTimelineSelectScalar = {
    id?: boolean
    escrowId?: boolean
    chainId?: boolean
    eventName?: boolean
    stateAfter?: boolean
    txHash?: boolean
    blockNumber?: boolean
    logIndex?: boolean
    timestamp?: boolean
    payload?: boolean
  }

  export type EscrowTimelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }
  export type EscrowTimelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }

  export type $EscrowTimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowTimeline"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      escrowId: Buffer
      chainId: number
      eventName: string
      stateAfter: string
      txHash: string
      blockNumber: bigint
      logIndex: number
      timestamp: Date
      payload: Prisma.JsonValue
    }, ExtArgs["result"]["escrowTimeline"]>
    composites: {}
  }

  type EscrowTimelineGetPayload<S extends boolean | null | undefined | EscrowTimelineDefaultArgs> = $Result.GetResult<Prisma.$EscrowTimelinePayload, S>

  type EscrowTimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowTimelineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowTimelineCountAggregateInputType | true
    }

  export interface EscrowTimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowTimeline'], meta: { name: 'EscrowTimeline' } }
    /**
     * Find zero or one EscrowTimeline that matches the filter.
     * @param {EscrowTimelineFindUniqueArgs} args - Arguments to find a EscrowTimeline
     * @example
     * // Get one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowTimelineFindUniqueArgs>(args: SelectSubset<T, EscrowTimelineFindUniqueArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscrowTimeline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowTimelineFindUniqueOrThrowArgs} args - Arguments to find a EscrowTimeline
     * @example
     * // Get one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowTimelineFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowTimelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscrowTimeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineFindFirstArgs} args - Arguments to find a EscrowTimeline
     * @example
     * // Get one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowTimelineFindFirstArgs>(args?: SelectSubset<T, EscrowTimelineFindFirstArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscrowTimeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineFindFirstOrThrowArgs} args - Arguments to find a EscrowTimeline
     * @example
     * // Get one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowTimelineFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowTimelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscrowTimelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowTimelines
     * const escrowTimelines = await prisma.escrowTimeline.findMany()
     * 
     * // Get first 10 EscrowTimelines
     * const escrowTimelines = await prisma.escrowTimeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrowTimelineWithIdOnly = await prisma.escrowTimeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscrowTimelineFindManyArgs>(args?: SelectSubset<T, EscrowTimelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscrowTimeline.
     * @param {EscrowTimelineCreateArgs} args - Arguments to create a EscrowTimeline.
     * @example
     * // Create one EscrowTimeline
     * const EscrowTimeline = await prisma.escrowTimeline.create({
     *   data: {
     *     // ... data to create a EscrowTimeline
     *   }
     * })
     * 
     */
    create<T extends EscrowTimelineCreateArgs>(args: SelectSubset<T, EscrowTimelineCreateArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscrowTimelines.
     * @param {EscrowTimelineCreateManyArgs} args - Arguments to create many EscrowTimelines.
     * @example
     * // Create many EscrowTimelines
     * const escrowTimeline = await prisma.escrowTimeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowTimelineCreateManyArgs>(args?: SelectSubset<T, EscrowTimelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscrowTimelines and returns the data saved in the database.
     * @param {EscrowTimelineCreateManyAndReturnArgs} args - Arguments to create many EscrowTimelines.
     * @example
     * // Create many EscrowTimelines
     * const escrowTimeline = await prisma.escrowTimeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscrowTimelines and only return the `id`
     * const escrowTimelineWithIdOnly = await prisma.escrowTimeline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowTimelineCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowTimelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscrowTimeline.
     * @param {EscrowTimelineDeleteArgs} args - Arguments to delete one EscrowTimeline.
     * @example
     * // Delete one EscrowTimeline
     * const EscrowTimeline = await prisma.escrowTimeline.delete({
     *   where: {
     *     // ... filter to delete one EscrowTimeline
     *   }
     * })
     * 
     */
    delete<T extends EscrowTimelineDeleteArgs>(args: SelectSubset<T, EscrowTimelineDeleteArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscrowTimeline.
     * @param {EscrowTimelineUpdateArgs} args - Arguments to update one EscrowTimeline.
     * @example
     * // Update one EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowTimelineUpdateArgs>(args: SelectSubset<T, EscrowTimelineUpdateArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscrowTimelines.
     * @param {EscrowTimelineDeleteManyArgs} args - Arguments to filter EscrowTimelines to delete.
     * @example
     * // Delete a few EscrowTimelines
     * const { count } = await prisma.escrowTimeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowTimelineDeleteManyArgs>(args?: SelectSubset<T, EscrowTimelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowTimelines
     * const escrowTimeline = await prisma.escrowTimeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowTimelineUpdateManyArgs>(args: SelectSubset<T, EscrowTimelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowTimeline.
     * @param {EscrowTimelineUpsertArgs} args - Arguments to update or create a EscrowTimeline.
     * @example
     * // Update or create a EscrowTimeline
     * const escrowTimeline = await prisma.escrowTimeline.upsert({
     *   create: {
     *     // ... data to create a EscrowTimeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowTimeline we want to update
     *   }
     * })
     */
    upsert<T extends EscrowTimelineUpsertArgs>(args: SelectSubset<T, EscrowTimelineUpsertArgs<ExtArgs>>): Prisma__EscrowTimelineClient<$Result.GetResult<Prisma.$EscrowTimelinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscrowTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineCountArgs} args - Arguments to filter EscrowTimelines to count.
     * @example
     * // Count the number of EscrowTimelines
     * const count = await prisma.escrowTimeline.count({
     *   where: {
     *     // ... the filter for the EscrowTimelines we want to count
     *   }
     * })
    **/
    count<T extends EscrowTimelineCountArgs>(
      args?: Subset<T, EscrowTimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowTimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowTimelineAggregateArgs>(args: Subset<T, EscrowTimelineAggregateArgs>): Prisma.PrismaPromise<GetEscrowTimelineAggregateType<T>>

    /**
     * Group by EscrowTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowTimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowTimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowTimelineGroupByArgs['orderBy'] }
        : { orderBy?: EscrowTimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowTimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowTimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowTimeline model
   */
  readonly fields: EscrowTimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowTimeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowTimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscrowDefaultArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscrowTimeline model
   */ 
  interface EscrowTimelineFieldRefs {
    readonly id: FieldRef<"EscrowTimeline", 'BigInt'>
    readonly escrowId: FieldRef<"EscrowTimeline", 'Bytes'>
    readonly chainId: FieldRef<"EscrowTimeline", 'Int'>
    readonly eventName: FieldRef<"EscrowTimeline", 'String'>
    readonly stateAfter: FieldRef<"EscrowTimeline", 'String'>
    readonly txHash: FieldRef<"EscrowTimeline", 'String'>
    readonly blockNumber: FieldRef<"EscrowTimeline", 'BigInt'>
    readonly logIndex: FieldRef<"EscrowTimeline", 'Int'>
    readonly timestamp: FieldRef<"EscrowTimeline", 'DateTime'>
    readonly payload: FieldRef<"EscrowTimeline", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EscrowTimeline findUnique
   */
  export type EscrowTimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimeline to fetch.
     */
    where: EscrowTimelineWhereUniqueInput
  }

  /**
   * EscrowTimeline findUniqueOrThrow
   */
  export type EscrowTimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimeline to fetch.
     */
    where: EscrowTimelineWhereUniqueInput
  }

  /**
   * EscrowTimeline findFirst
   */
  export type EscrowTimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimeline to fetch.
     */
    where?: EscrowTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowTimelines to fetch.
     */
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowTimelines.
     */
    cursor?: EscrowTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowTimelines.
     */
    distinct?: EscrowTimelineScalarFieldEnum | EscrowTimelineScalarFieldEnum[]
  }

  /**
   * EscrowTimeline findFirstOrThrow
   */
  export type EscrowTimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimeline to fetch.
     */
    where?: EscrowTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowTimelines to fetch.
     */
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowTimelines.
     */
    cursor?: EscrowTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowTimelines.
     */
    distinct?: EscrowTimelineScalarFieldEnum | EscrowTimelineScalarFieldEnum[]
  }

  /**
   * EscrowTimeline findMany
   */
  export type EscrowTimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter, which EscrowTimelines to fetch.
     */
    where?: EscrowTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowTimelines to fetch.
     */
    orderBy?: EscrowTimelineOrderByWithRelationInput | EscrowTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowTimelines.
     */
    cursor?: EscrowTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowTimelines.
     */
    skip?: number
    distinct?: EscrowTimelineScalarFieldEnum | EscrowTimelineScalarFieldEnum[]
  }

  /**
   * EscrowTimeline create
   */
  export type EscrowTimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * The data needed to create a EscrowTimeline.
     */
    data: XOR<EscrowTimelineCreateInput, EscrowTimelineUncheckedCreateInput>
  }

  /**
   * EscrowTimeline createMany
   */
  export type EscrowTimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowTimelines.
     */
    data: EscrowTimelineCreateManyInput | EscrowTimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowTimeline createManyAndReturn
   */
  export type EscrowTimelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscrowTimelines.
     */
    data: EscrowTimelineCreateManyInput | EscrowTimelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscrowTimeline update
   */
  export type EscrowTimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * The data needed to update a EscrowTimeline.
     */
    data: XOR<EscrowTimelineUpdateInput, EscrowTimelineUncheckedUpdateInput>
    /**
     * Choose, which EscrowTimeline to update.
     */
    where: EscrowTimelineWhereUniqueInput
  }

  /**
   * EscrowTimeline updateMany
   */
  export type EscrowTimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowTimelines.
     */
    data: XOR<EscrowTimelineUpdateManyMutationInput, EscrowTimelineUncheckedUpdateManyInput>
    /**
     * Filter which EscrowTimelines to update
     */
    where?: EscrowTimelineWhereInput
  }

  /**
   * EscrowTimeline upsert
   */
  export type EscrowTimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * The filter to search for the EscrowTimeline to update in case it exists.
     */
    where: EscrowTimelineWhereUniqueInput
    /**
     * In case the EscrowTimeline found by the `where` argument doesn't exist, create a new EscrowTimeline with this data.
     */
    create: XOR<EscrowTimelineCreateInput, EscrowTimelineUncheckedCreateInput>
    /**
     * In case the EscrowTimeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowTimelineUpdateInput, EscrowTimelineUncheckedUpdateInput>
  }

  /**
   * EscrowTimeline delete
   */
  export type EscrowTimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
    /**
     * Filter which EscrowTimeline to delete.
     */
    where: EscrowTimelineWhereUniqueInput
  }

  /**
   * EscrowTimeline deleteMany
   */
  export type EscrowTimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowTimelines to delete
     */
    where?: EscrowTimelineWhereInput
  }

  /**
   * EscrowTimeline without action
   */
  export type EscrowTimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowTimeline
     */
    select?: EscrowTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowTimelineInclude<ExtArgs> | null
  }


  /**
   * Model EscrowMessage
   */

  export type AggregateEscrowMessage = {
    _count: EscrowMessageCountAggregateOutputType | null
    _min: EscrowMessageMinAggregateOutputType | null
    _max: EscrowMessageMaxAggregateOutputType | null
  }

  export type EscrowMessageMinAggregateOutputType = {
    id: string | null
    escrowId: Buffer | null
    sender: string | null
    text: string | null
    attachment: string | null
    hash: string | null
    createdAt: Date | null
    editedAt: Date | null
  }

  export type EscrowMessageMaxAggregateOutputType = {
    id: string | null
    escrowId: Buffer | null
    sender: string | null
    text: string | null
    attachment: string | null
    hash: string | null
    createdAt: Date | null
    editedAt: Date | null
  }

  export type EscrowMessageCountAggregateOutputType = {
    id: number
    escrowId: number
    sender: number
    text: number
    attachment: number
    hash: number
    createdAt: number
    editedAt: number
    _all: number
  }


  export type EscrowMessageMinAggregateInputType = {
    id?: true
    escrowId?: true
    sender?: true
    text?: true
    attachment?: true
    hash?: true
    createdAt?: true
    editedAt?: true
  }

  export type EscrowMessageMaxAggregateInputType = {
    id?: true
    escrowId?: true
    sender?: true
    text?: true
    attachment?: true
    hash?: true
    createdAt?: true
    editedAt?: true
  }

  export type EscrowMessageCountAggregateInputType = {
    id?: true
    escrowId?: true
    sender?: true
    text?: true
    attachment?: true
    hash?: true
    createdAt?: true
    editedAt?: true
    _all?: true
  }

  export type EscrowMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowMessage to aggregate.
     */
    where?: EscrowMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowMessages to fetch.
     */
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowMessages
    **/
    _count?: true | EscrowMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowMessageMaxAggregateInputType
  }

  export type GetEscrowMessageAggregateType<T extends EscrowMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowMessage[P]>
      : GetScalarType<T[P], AggregateEscrowMessage[P]>
  }




  export type EscrowMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowMessageWhereInput
    orderBy?: EscrowMessageOrderByWithAggregationInput | EscrowMessageOrderByWithAggregationInput[]
    by: EscrowMessageScalarFieldEnum[] | EscrowMessageScalarFieldEnum
    having?: EscrowMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowMessageCountAggregateInputType | true
    _min?: EscrowMessageMinAggregateInputType
    _max?: EscrowMessageMaxAggregateInputType
  }

  export type EscrowMessageGroupByOutputType = {
    id: string
    escrowId: Buffer | null
    sender: string
    text: string
    attachment: string | null
    hash: string | null
    createdAt: Date
    editedAt: Date | null
    _count: EscrowMessageCountAggregateOutputType | null
    _min: EscrowMessageMinAggregateOutputType | null
    _max: EscrowMessageMaxAggregateOutputType | null
  }

  type GetEscrowMessageGroupByPayload<T extends EscrowMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowMessageGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowMessageGroupByOutputType[P]>
        }
      >
    >


  export type EscrowMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    sender?: boolean
    text?: boolean
    attachment?: boolean
    hash?: boolean
    createdAt?: boolean
    editedAt?: boolean
    Escrow?: boolean | EscrowMessage$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["escrowMessage"]>

  export type EscrowMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    sender?: boolean
    text?: boolean
    attachment?: boolean
    hash?: boolean
    createdAt?: boolean
    editedAt?: boolean
    Escrow?: boolean | EscrowMessage$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["escrowMessage"]>

  export type EscrowMessageSelectScalar = {
    id?: boolean
    escrowId?: boolean
    sender?: boolean
    text?: boolean
    attachment?: boolean
    hash?: boolean
    createdAt?: boolean
    editedAt?: boolean
  }

  export type EscrowMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowMessage$EscrowArgs<ExtArgs>
  }
  export type EscrowMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowMessage$EscrowArgs<ExtArgs>
  }

  export type $EscrowMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowMessage"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      escrowId: Buffer | null
      sender: string
      text: string
      attachment: string | null
      hash: string | null
      createdAt: Date
      editedAt: Date | null
    }, ExtArgs["result"]["escrowMessage"]>
    composites: {}
  }

  type EscrowMessageGetPayload<S extends boolean | null | undefined | EscrowMessageDefaultArgs> = $Result.GetResult<Prisma.$EscrowMessagePayload, S>

  type EscrowMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowMessageCountAggregateInputType | true
    }

  export interface EscrowMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowMessage'], meta: { name: 'EscrowMessage' } }
    /**
     * Find zero or one EscrowMessage that matches the filter.
     * @param {EscrowMessageFindUniqueArgs} args - Arguments to find a EscrowMessage
     * @example
     * // Get one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowMessageFindUniqueArgs>(args: SelectSubset<T, EscrowMessageFindUniqueArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscrowMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowMessageFindUniqueOrThrowArgs} args - Arguments to find a EscrowMessage
     * @example
     * // Get one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscrowMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageFindFirstArgs} args - Arguments to find a EscrowMessage
     * @example
     * // Get one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowMessageFindFirstArgs>(args?: SelectSubset<T, EscrowMessageFindFirstArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscrowMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageFindFirstOrThrowArgs} args - Arguments to find a EscrowMessage
     * @example
     * // Get one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscrowMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowMessages
     * const escrowMessages = await prisma.escrowMessage.findMany()
     * 
     * // Get first 10 EscrowMessages
     * const escrowMessages = await prisma.escrowMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrowMessageWithIdOnly = await prisma.escrowMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscrowMessageFindManyArgs>(args?: SelectSubset<T, EscrowMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscrowMessage.
     * @param {EscrowMessageCreateArgs} args - Arguments to create a EscrowMessage.
     * @example
     * // Create one EscrowMessage
     * const EscrowMessage = await prisma.escrowMessage.create({
     *   data: {
     *     // ... data to create a EscrowMessage
     *   }
     * })
     * 
     */
    create<T extends EscrowMessageCreateArgs>(args: SelectSubset<T, EscrowMessageCreateArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscrowMessages.
     * @param {EscrowMessageCreateManyArgs} args - Arguments to create many EscrowMessages.
     * @example
     * // Create many EscrowMessages
     * const escrowMessage = await prisma.escrowMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowMessageCreateManyArgs>(args?: SelectSubset<T, EscrowMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscrowMessages and returns the data saved in the database.
     * @param {EscrowMessageCreateManyAndReturnArgs} args - Arguments to create many EscrowMessages.
     * @example
     * // Create many EscrowMessages
     * const escrowMessage = await prisma.escrowMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscrowMessages and only return the `id`
     * const escrowMessageWithIdOnly = await prisma.escrowMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscrowMessage.
     * @param {EscrowMessageDeleteArgs} args - Arguments to delete one EscrowMessage.
     * @example
     * // Delete one EscrowMessage
     * const EscrowMessage = await prisma.escrowMessage.delete({
     *   where: {
     *     // ... filter to delete one EscrowMessage
     *   }
     * })
     * 
     */
    delete<T extends EscrowMessageDeleteArgs>(args: SelectSubset<T, EscrowMessageDeleteArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscrowMessage.
     * @param {EscrowMessageUpdateArgs} args - Arguments to update one EscrowMessage.
     * @example
     * // Update one EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowMessageUpdateArgs>(args: SelectSubset<T, EscrowMessageUpdateArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscrowMessages.
     * @param {EscrowMessageDeleteManyArgs} args - Arguments to filter EscrowMessages to delete.
     * @example
     * // Delete a few EscrowMessages
     * const { count } = await prisma.escrowMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowMessageDeleteManyArgs>(args?: SelectSubset<T, EscrowMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowMessages
     * const escrowMessage = await prisma.escrowMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowMessageUpdateManyArgs>(args: SelectSubset<T, EscrowMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowMessage.
     * @param {EscrowMessageUpsertArgs} args - Arguments to update or create a EscrowMessage.
     * @example
     * // Update or create a EscrowMessage
     * const escrowMessage = await prisma.escrowMessage.upsert({
     *   create: {
     *     // ... data to create a EscrowMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowMessage we want to update
     *   }
     * })
     */
    upsert<T extends EscrowMessageUpsertArgs>(args: SelectSubset<T, EscrowMessageUpsertArgs<ExtArgs>>): Prisma__EscrowMessageClient<$Result.GetResult<Prisma.$EscrowMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscrowMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageCountArgs} args - Arguments to filter EscrowMessages to count.
     * @example
     * // Count the number of EscrowMessages
     * const count = await prisma.escrowMessage.count({
     *   where: {
     *     // ... the filter for the EscrowMessages we want to count
     *   }
     * })
    **/
    count<T extends EscrowMessageCountArgs>(
      args?: Subset<T, EscrowMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowMessageAggregateArgs>(args: Subset<T, EscrowMessageAggregateArgs>): Prisma.PrismaPromise<GetEscrowMessageAggregateType<T>>

    /**
     * Group by EscrowMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowMessageGroupByArgs['orderBy'] }
        : { orderBy?: EscrowMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowMessage model
   */
  readonly fields: EscrowMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowMessage$EscrowArgs<ExtArgs> = {}>(args?: Subset<T, EscrowMessage$EscrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscrowMessage model
   */ 
  interface EscrowMessageFieldRefs {
    readonly id: FieldRef<"EscrowMessage", 'String'>
    readonly escrowId: FieldRef<"EscrowMessage", 'Bytes'>
    readonly sender: FieldRef<"EscrowMessage", 'String'>
    readonly text: FieldRef<"EscrowMessage", 'String'>
    readonly attachment: FieldRef<"EscrowMessage", 'String'>
    readonly hash: FieldRef<"EscrowMessage", 'String'>
    readonly createdAt: FieldRef<"EscrowMessage", 'DateTime'>
    readonly editedAt: FieldRef<"EscrowMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EscrowMessage findUnique
   */
  export type EscrowMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessage to fetch.
     */
    where: EscrowMessageWhereUniqueInput
  }

  /**
   * EscrowMessage findUniqueOrThrow
   */
  export type EscrowMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessage to fetch.
     */
    where: EscrowMessageWhereUniqueInput
  }

  /**
   * EscrowMessage findFirst
   */
  export type EscrowMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessage to fetch.
     */
    where?: EscrowMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowMessages to fetch.
     */
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowMessages.
     */
    cursor?: EscrowMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowMessages.
     */
    distinct?: EscrowMessageScalarFieldEnum | EscrowMessageScalarFieldEnum[]
  }

  /**
   * EscrowMessage findFirstOrThrow
   */
  export type EscrowMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessage to fetch.
     */
    where?: EscrowMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowMessages to fetch.
     */
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowMessages.
     */
    cursor?: EscrowMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowMessages.
     */
    distinct?: EscrowMessageScalarFieldEnum | EscrowMessageScalarFieldEnum[]
  }

  /**
   * EscrowMessage findMany
   */
  export type EscrowMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter, which EscrowMessages to fetch.
     */
    where?: EscrowMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowMessages to fetch.
     */
    orderBy?: EscrowMessageOrderByWithRelationInput | EscrowMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowMessages.
     */
    cursor?: EscrowMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowMessages.
     */
    skip?: number
    distinct?: EscrowMessageScalarFieldEnum | EscrowMessageScalarFieldEnum[]
  }

  /**
   * EscrowMessage create
   */
  export type EscrowMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a EscrowMessage.
     */
    data: XOR<EscrowMessageCreateInput, EscrowMessageUncheckedCreateInput>
  }

  /**
   * EscrowMessage createMany
   */
  export type EscrowMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowMessages.
     */
    data: EscrowMessageCreateManyInput | EscrowMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowMessage createManyAndReturn
   */
  export type EscrowMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscrowMessages.
     */
    data: EscrowMessageCreateManyInput | EscrowMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscrowMessage update
   */
  export type EscrowMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a EscrowMessage.
     */
    data: XOR<EscrowMessageUpdateInput, EscrowMessageUncheckedUpdateInput>
    /**
     * Choose, which EscrowMessage to update.
     */
    where: EscrowMessageWhereUniqueInput
  }

  /**
   * EscrowMessage updateMany
   */
  export type EscrowMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowMessages.
     */
    data: XOR<EscrowMessageUpdateManyMutationInput, EscrowMessageUncheckedUpdateManyInput>
    /**
     * Filter which EscrowMessages to update
     */
    where?: EscrowMessageWhereInput
  }

  /**
   * EscrowMessage upsert
   */
  export type EscrowMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the EscrowMessage to update in case it exists.
     */
    where: EscrowMessageWhereUniqueInput
    /**
     * In case the EscrowMessage found by the `where` argument doesn't exist, create a new EscrowMessage with this data.
     */
    create: XOR<EscrowMessageCreateInput, EscrowMessageUncheckedCreateInput>
    /**
     * In case the EscrowMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowMessageUpdateInput, EscrowMessageUncheckedUpdateInput>
  }

  /**
   * EscrowMessage delete
   */
  export type EscrowMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
    /**
     * Filter which EscrowMessage to delete.
     */
    where: EscrowMessageWhereUniqueInput
  }

  /**
   * EscrowMessage deleteMany
   */
  export type EscrowMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowMessages to delete
     */
    where?: EscrowMessageWhereInput
  }

  /**
   * EscrowMessage.Escrow
   */
  export type EscrowMessage$EscrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    where?: EscrowWhereInput
  }

  /**
   * EscrowMessage without action
   */
  export type EscrowMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowMessage
     */
    select?: EscrowMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowMessageInclude<ExtArgs> | null
  }


  /**
   * Model EscrowPaymentInstruction
   */

  export type AggregateEscrowPaymentInstruction = {
    _count: EscrowPaymentInstructionCountAggregateOutputType | null
    _min: EscrowPaymentInstructionMinAggregateOutputType | null
    _max: EscrowPaymentInstructionMaxAggregateOutputType | null
  }

  export type EscrowPaymentInstructionMinAggregateOutputType = {
    escrowId: Buffer | null
    seller: string | null
    updatedAt: Date | null
  }

  export type EscrowPaymentInstructionMaxAggregateOutputType = {
    escrowId: Buffer | null
    seller: string | null
    updatedAt: Date | null
  }

  export type EscrowPaymentInstructionCountAggregateOutputType = {
    escrowId: number
    seller: number
    content: number
    updatedAt: number
    _all: number
  }


  export type EscrowPaymentInstructionMinAggregateInputType = {
    escrowId?: true
    seller?: true
    updatedAt?: true
  }

  export type EscrowPaymentInstructionMaxAggregateInputType = {
    escrowId?: true
    seller?: true
    updatedAt?: true
  }

  export type EscrowPaymentInstructionCountAggregateInputType = {
    escrowId?: true
    seller?: true
    content?: true
    updatedAt?: true
    _all?: true
  }

  export type EscrowPaymentInstructionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowPaymentInstruction to aggregate.
     */
    where?: EscrowPaymentInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowPaymentInstructions to fetch.
     */
    orderBy?: EscrowPaymentInstructionOrderByWithRelationInput | EscrowPaymentInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowPaymentInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowPaymentInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowPaymentInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowPaymentInstructions
    **/
    _count?: true | EscrowPaymentInstructionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowPaymentInstructionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowPaymentInstructionMaxAggregateInputType
  }

  export type GetEscrowPaymentInstructionAggregateType<T extends EscrowPaymentInstructionAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowPaymentInstruction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowPaymentInstruction[P]>
      : GetScalarType<T[P], AggregateEscrowPaymentInstruction[P]>
  }




  export type EscrowPaymentInstructionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowPaymentInstructionWhereInput
    orderBy?: EscrowPaymentInstructionOrderByWithAggregationInput | EscrowPaymentInstructionOrderByWithAggregationInput[]
    by: EscrowPaymentInstructionScalarFieldEnum[] | EscrowPaymentInstructionScalarFieldEnum
    having?: EscrowPaymentInstructionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowPaymentInstructionCountAggregateInputType | true
    _min?: EscrowPaymentInstructionMinAggregateInputType
    _max?: EscrowPaymentInstructionMaxAggregateInputType
  }

  export type EscrowPaymentInstructionGroupByOutputType = {
    escrowId: Buffer
    seller: string
    content: JsonValue | null
    updatedAt: Date
    _count: EscrowPaymentInstructionCountAggregateOutputType | null
    _min: EscrowPaymentInstructionMinAggregateOutputType | null
    _max: EscrowPaymentInstructionMaxAggregateOutputType | null
  }

  type GetEscrowPaymentInstructionGroupByPayload<T extends EscrowPaymentInstructionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowPaymentInstructionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowPaymentInstructionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowPaymentInstructionGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowPaymentInstructionGroupByOutputType[P]>
        }
      >
    >


  export type EscrowPaymentInstructionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    seller?: boolean
    content?: boolean
    updatedAt?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrowPaymentInstruction"]>

  export type EscrowPaymentInstructionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    seller?: boolean
    content?: boolean
    updatedAt?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrowPaymentInstruction"]>

  export type EscrowPaymentInstructionSelectScalar = {
    escrowId?: boolean
    seller?: boolean
    content?: boolean
    updatedAt?: boolean
  }

  export type EscrowPaymentInstructionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }
  export type EscrowPaymentInstructionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }

  export type $EscrowPaymentInstructionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowPaymentInstruction"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      escrowId: Buffer
      seller: string
      content: Prisma.JsonValue | null
      updatedAt: Date
    }, ExtArgs["result"]["escrowPaymentInstruction"]>
    composites: {}
  }

  type EscrowPaymentInstructionGetPayload<S extends boolean | null | undefined | EscrowPaymentInstructionDefaultArgs> = $Result.GetResult<Prisma.$EscrowPaymentInstructionPayload, S>

  type EscrowPaymentInstructionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowPaymentInstructionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowPaymentInstructionCountAggregateInputType | true
    }

  export interface EscrowPaymentInstructionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowPaymentInstruction'], meta: { name: 'EscrowPaymentInstruction' } }
    /**
     * Find zero or one EscrowPaymentInstruction that matches the filter.
     * @param {EscrowPaymentInstructionFindUniqueArgs} args - Arguments to find a EscrowPaymentInstruction
     * @example
     * // Get one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowPaymentInstructionFindUniqueArgs>(args: SelectSubset<T, EscrowPaymentInstructionFindUniqueArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscrowPaymentInstruction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowPaymentInstructionFindUniqueOrThrowArgs} args - Arguments to find a EscrowPaymentInstruction
     * @example
     * // Get one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowPaymentInstructionFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowPaymentInstructionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscrowPaymentInstruction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionFindFirstArgs} args - Arguments to find a EscrowPaymentInstruction
     * @example
     * // Get one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowPaymentInstructionFindFirstArgs>(args?: SelectSubset<T, EscrowPaymentInstructionFindFirstArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscrowPaymentInstruction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionFindFirstOrThrowArgs} args - Arguments to find a EscrowPaymentInstruction
     * @example
     * // Get one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowPaymentInstructionFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowPaymentInstructionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscrowPaymentInstructions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowPaymentInstructions
     * const escrowPaymentInstructions = await prisma.escrowPaymentInstruction.findMany()
     * 
     * // Get first 10 EscrowPaymentInstructions
     * const escrowPaymentInstructions = await prisma.escrowPaymentInstruction.findMany({ take: 10 })
     * 
     * // Only select the `escrowId`
     * const escrowPaymentInstructionWithEscrowIdOnly = await prisma.escrowPaymentInstruction.findMany({ select: { escrowId: true } })
     * 
     */
    findMany<T extends EscrowPaymentInstructionFindManyArgs>(args?: SelectSubset<T, EscrowPaymentInstructionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscrowPaymentInstruction.
     * @param {EscrowPaymentInstructionCreateArgs} args - Arguments to create a EscrowPaymentInstruction.
     * @example
     * // Create one EscrowPaymentInstruction
     * const EscrowPaymentInstruction = await prisma.escrowPaymentInstruction.create({
     *   data: {
     *     // ... data to create a EscrowPaymentInstruction
     *   }
     * })
     * 
     */
    create<T extends EscrowPaymentInstructionCreateArgs>(args: SelectSubset<T, EscrowPaymentInstructionCreateArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscrowPaymentInstructions.
     * @param {EscrowPaymentInstructionCreateManyArgs} args - Arguments to create many EscrowPaymentInstructions.
     * @example
     * // Create many EscrowPaymentInstructions
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowPaymentInstructionCreateManyArgs>(args?: SelectSubset<T, EscrowPaymentInstructionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscrowPaymentInstructions and returns the data saved in the database.
     * @param {EscrowPaymentInstructionCreateManyAndReturnArgs} args - Arguments to create many EscrowPaymentInstructions.
     * @example
     * // Create many EscrowPaymentInstructions
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscrowPaymentInstructions and only return the `escrowId`
     * const escrowPaymentInstructionWithEscrowIdOnly = await prisma.escrowPaymentInstruction.createManyAndReturn({ 
     *   select: { escrowId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowPaymentInstructionCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowPaymentInstructionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscrowPaymentInstruction.
     * @param {EscrowPaymentInstructionDeleteArgs} args - Arguments to delete one EscrowPaymentInstruction.
     * @example
     * // Delete one EscrowPaymentInstruction
     * const EscrowPaymentInstruction = await prisma.escrowPaymentInstruction.delete({
     *   where: {
     *     // ... filter to delete one EscrowPaymentInstruction
     *   }
     * })
     * 
     */
    delete<T extends EscrowPaymentInstructionDeleteArgs>(args: SelectSubset<T, EscrowPaymentInstructionDeleteArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscrowPaymentInstruction.
     * @param {EscrowPaymentInstructionUpdateArgs} args - Arguments to update one EscrowPaymentInstruction.
     * @example
     * // Update one EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowPaymentInstructionUpdateArgs>(args: SelectSubset<T, EscrowPaymentInstructionUpdateArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscrowPaymentInstructions.
     * @param {EscrowPaymentInstructionDeleteManyArgs} args - Arguments to filter EscrowPaymentInstructions to delete.
     * @example
     * // Delete a few EscrowPaymentInstructions
     * const { count } = await prisma.escrowPaymentInstruction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowPaymentInstructionDeleteManyArgs>(args?: SelectSubset<T, EscrowPaymentInstructionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowPaymentInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowPaymentInstructions
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowPaymentInstructionUpdateManyArgs>(args: SelectSubset<T, EscrowPaymentInstructionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowPaymentInstruction.
     * @param {EscrowPaymentInstructionUpsertArgs} args - Arguments to update or create a EscrowPaymentInstruction.
     * @example
     * // Update or create a EscrowPaymentInstruction
     * const escrowPaymentInstruction = await prisma.escrowPaymentInstruction.upsert({
     *   create: {
     *     // ... data to create a EscrowPaymentInstruction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowPaymentInstruction we want to update
     *   }
     * })
     */
    upsert<T extends EscrowPaymentInstructionUpsertArgs>(args: SelectSubset<T, EscrowPaymentInstructionUpsertArgs<ExtArgs>>): Prisma__EscrowPaymentInstructionClient<$Result.GetResult<Prisma.$EscrowPaymentInstructionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscrowPaymentInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionCountArgs} args - Arguments to filter EscrowPaymentInstructions to count.
     * @example
     * // Count the number of EscrowPaymentInstructions
     * const count = await prisma.escrowPaymentInstruction.count({
     *   where: {
     *     // ... the filter for the EscrowPaymentInstructions we want to count
     *   }
     * })
    **/
    count<T extends EscrowPaymentInstructionCountArgs>(
      args?: Subset<T, EscrowPaymentInstructionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowPaymentInstructionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowPaymentInstruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowPaymentInstructionAggregateArgs>(args: Subset<T, EscrowPaymentInstructionAggregateArgs>): Prisma.PrismaPromise<GetEscrowPaymentInstructionAggregateType<T>>

    /**
     * Group by EscrowPaymentInstruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowPaymentInstructionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowPaymentInstructionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowPaymentInstructionGroupByArgs['orderBy'] }
        : { orderBy?: EscrowPaymentInstructionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowPaymentInstructionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowPaymentInstructionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowPaymentInstruction model
   */
  readonly fields: EscrowPaymentInstructionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowPaymentInstruction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowPaymentInstructionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscrowDefaultArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscrowPaymentInstruction model
   */ 
  interface EscrowPaymentInstructionFieldRefs {
    readonly escrowId: FieldRef<"EscrowPaymentInstruction", 'Bytes'>
    readonly seller: FieldRef<"EscrowPaymentInstruction", 'String'>
    readonly content: FieldRef<"EscrowPaymentInstruction", 'Json'>
    readonly updatedAt: FieldRef<"EscrowPaymentInstruction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EscrowPaymentInstruction findUnique
   */
  export type EscrowPaymentInstructionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstruction to fetch.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
  }

  /**
   * EscrowPaymentInstruction findUniqueOrThrow
   */
  export type EscrowPaymentInstructionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstruction to fetch.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
  }

  /**
   * EscrowPaymentInstruction findFirst
   */
  export type EscrowPaymentInstructionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstruction to fetch.
     */
    where?: EscrowPaymentInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowPaymentInstructions to fetch.
     */
    orderBy?: EscrowPaymentInstructionOrderByWithRelationInput | EscrowPaymentInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowPaymentInstructions.
     */
    cursor?: EscrowPaymentInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowPaymentInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowPaymentInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowPaymentInstructions.
     */
    distinct?: EscrowPaymentInstructionScalarFieldEnum | EscrowPaymentInstructionScalarFieldEnum[]
  }

  /**
   * EscrowPaymentInstruction findFirstOrThrow
   */
  export type EscrowPaymentInstructionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstruction to fetch.
     */
    where?: EscrowPaymentInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowPaymentInstructions to fetch.
     */
    orderBy?: EscrowPaymentInstructionOrderByWithRelationInput | EscrowPaymentInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowPaymentInstructions.
     */
    cursor?: EscrowPaymentInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowPaymentInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowPaymentInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowPaymentInstructions.
     */
    distinct?: EscrowPaymentInstructionScalarFieldEnum | EscrowPaymentInstructionScalarFieldEnum[]
  }

  /**
   * EscrowPaymentInstruction findMany
   */
  export type EscrowPaymentInstructionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter, which EscrowPaymentInstructions to fetch.
     */
    where?: EscrowPaymentInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowPaymentInstructions to fetch.
     */
    orderBy?: EscrowPaymentInstructionOrderByWithRelationInput | EscrowPaymentInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowPaymentInstructions.
     */
    cursor?: EscrowPaymentInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowPaymentInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowPaymentInstructions.
     */
    skip?: number
    distinct?: EscrowPaymentInstructionScalarFieldEnum | EscrowPaymentInstructionScalarFieldEnum[]
  }

  /**
   * EscrowPaymentInstruction create
   */
  export type EscrowPaymentInstructionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * The data needed to create a EscrowPaymentInstruction.
     */
    data: XOR<EscrowPaymentInstructionCreateInput, EscrowPaymentInstructionUncheckedCreateInput>
  }

  /**
   * EscrowPaymentInstruction createMany
   */
  export type EscrowPaymentInstructionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowPaymentInstructions.
     */
    data: EscrowPaymentInstructionCreateManyInput | EscrowPaymentInstructionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowPaymentInstruction createManyAndReturn
   */
  export type EscrowPaymentInstructionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscrowPaymentInstructions.
     */
    data: EscrowPaymentInstructionCreateManyInput | EscrowPaymentInstructionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscrowPaymentInstruction update
   */
  export type EscrowPaymentInstructionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * The data needed to update a EscrowPaymentInstruction.
     */
    data: XOR<EscrowPaymentInstructionUpdateInput, EscrowPaymentInstructionUncheckedUpdateInput>
    /**
     * Choose, which EscrowPaymentInstruction to update.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
  }

  /**
   * EscrowPaymentInstruction updateMany
   */
  export type EscrowPaymentInstructionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowPaymentInstructions.
     */
    data: XOR<EscrowPaymentInstructionUpdateManyMutationInput, EscrowPaymentInstructionUncheckedUpdateManyInput>
    /**
     * Filter which EscrowPaymentInstructions to update
     */
    where?: EscrowPaymentInstructionWhereInput
  }

  /**
   * EscrowPaymentInstruction upsert
   */
  export type EscrowPaymentInstructionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * The filter to search for the EscrowPaymentInstruction to update in case it exists.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
    /**
     * In case the EscrowPaymentInstruction found by the `where` argument doesn't exist, create a new EscrowPaymentInstruction with this data.
     */
    create: XOR<EscrowPaymentInstructionCreateInput, EscrowPaymentInstructionUncheckedCreateInput>
    /**
     * In case the EscrowPaymentInstruction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowPaymentInstructionUpdateInput, EscrowPaymentInstructionUncheckedUpdateInput>
  }

  /**
   * EscrowPaymentInstruction delete
   */
  export type EscrowPaymentInstructionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
    /**
     * Filter which EscrowPaymentInstruction to delete.
     */
    where: EscrowPaymentInstructionWhereUniqueInput
  }

  /**
   * EscrowPaymentInstruction deleteMany
   */
  export type EscrowPaymentInstructionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowPaymentInstructions to delete
     */
    where?: EscrowPaymentInstructionWhereInput
  }

  /**
   * EscrowPaymentInstruction without action
   */
  export type EscrowPaymentInstructionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowPaymentInstruction
     */
    select?: EscrowPaymentInstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowPaymentInstructionInclude<ExtArgs> | null
  }


  /**
   * Model EscrowFiatStatus
   */

  export type AggregateEscrowFiatStatus = {
    _count: EscrowFiatStatusCountAggregateOutputType | null
    _avg: EscrowFiatStatusAvgAggregateOutputType | null
    _sum: EscrowFiatStatusSumAggregateOutputType | null
    _min: EscrowFiatStatusMinAggregateOutputType | null
    _max: EscrowFiatStatusMaxAggregateOutputType | null
  }

  export type EscrowFiatStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type EscrowFiatStatusSumAggregateOutputType = {
    id: bigint | null
  }

  export type EscrowFiatStatusMinAggregateOutputType = {
    id: bigint | null
    escrowId: Buffer | null
    actor: string | null
    status: string | null
    note: string | null
    createdAt: Date | null
  }

  export type EscrowFiatStatusMaxAggregateOutputType = {
    id: bigint | null
    escrowId: Buffer | null
    actor: string | null
    status: string | null
    note: string | null
    createdAt: Date | null
  }

  export type EscrowFiatStatusCountAggregateOutputType = {
    id: number
    escrowId: number
    actor: number
    status: number
    note: number
    createdAt: number
    _all: number
  }


  export type EscrowFiatStatusAvgAggregateInputType = {
    id?: true
  }

  export type EscrowFiatStatusSumAggregateInputType = {
    id?: true
  }

  export type EscrowFiatStatusMinAggregateInputType = {
    id?: true
    escrowId?: true
    actor?: true
    status?: true
    note?: true
    createdAt?: true
  }

  export type EscrowFiatStatusMaxAggregateInputType = {
    id?: true
    escrowId?: true
    actor?: true
    status?: true
    note?: true
    createdAt?: true
  }

  export type EscrowFiatStatusCountAggregateInputType = {
    id?: true
    escrowId?: true
    actor?: true
    status?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type EscrowFiatStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowFiatStatus to aggregate.
     */
    where?: EscrowFiatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowFiatStatuses to fetch.
     */
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscrowFiatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowFiatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowFiatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscrowFiatStatuses
    **/
    _count?: true | EscrowFiatStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscrowFiatStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscrowFiatStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowFiatStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowFiatStatusMaxAggregateInputType
  }

  export type GetEscrowFiatStatusAggregateType<T extends EscrowFiatStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrowFiatStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrowFiatStatus[P]>
      : GetScalarType<T[P], AggregateEscrowFiatStatus[P]>
  }




  export type EscrowFiatStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscrowFiatStatusWhereInput
    orderBy?: EscrowFiatStatusOrderByWithAggregationInput | EscrowFiatStatusOrderByWithAggregationInput[]
    by: EscrowFiatStatusScalarFieldEnum[] | EscrowFiatStatusScalarFieldEnum
    having?: EscrowFiatStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowFiatStatusCountAggregateInputType | true
    _avg?: EscrowFiatStatusAvgAggregateInputType
    _sum?: EscrowFiatStatusSumAggregateInputType
    _min?: EscrowFiatStatusMinAggregateInputType
    _max?: EscrowFiatStatusMaxAggregateInputType
  }

  export type EscrowFiatStatusGroupByOutputType = {
    id: bigint
    escrowId: Buffer | null
    actor: string
    status: string
    note: string | null
    createdAt: Date
    _count: EscrowFiatStatusCountAggregateOutputType | null
    _avg: EscrowFiatStatusAvgAggregateOutputType | null
    _sum: EscrowFiatStatusSumAggregateOutputType | null
    _min: EscrowFiatStatusMinAggregateOutputType | null
    _max: EscrowFiatStatusMaxAggregateOutputType | null
  }

  type GetEscrowFiatStatusGroupByPayload<T extends EscrowFiatStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowFiatStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowFiatStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowFiatStatusGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowFiatStatusGroupByOutputType[P]>
        }
      >
    >


  export type EscrowFiatStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    actor?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    Escrow?: boolean | EscrowFiatStatus$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["escrowFiatStatus"]>

  export type EscrowFiatStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    actor?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    Escrow?: boolean | EscrowFiatStatus$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["escrowFiatStatus"]>

  export type EscrowFiatStatusSelectScalar = {
    id?: boolean
    escrowId?: boolean
    actor?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type EscrowFiatStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowFiatStatus$EscrowArgs<ExtArgs>
  }
  export type EscrowFiatStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowFiatStatus$EscrowArgs<ExtArgs>
  }

  export type $EscrowFiatStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscrowFiatStatus"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      escrowId: Buffer | null
      actor: string
      status: string
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["escrowFiatStatus"]>
    composites: {}
  }

  type EscrowFiatStatusGetPayload<S extends boolean | null | undefined | EscrowFiatStatusDefaultArgs> = $Result.GetResult<Prisma.$EscrowFiatStatusPayload, S>

  type EscrowFiatStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscrowFiatStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscrowFiatStatusCountAggregateInputType | true
    }

  export interface EscrowFiatStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscrowFiatStatus'], meta: { name: 'EscrowFiatStatus' } }
    /**
     * Find zero or one EscrowFiatStatus that matches the filter.
     * @param {EscrowFiatStatusFindUniqueArgs} args - Arguments to find a EscrowFiatStatus
     * @example
     * // Get one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscrowFiatStatusFindUniqueArgs>(args: SelectSubset<T, EscrowFiatStatusFindUniqueArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscrowFiatStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscrowFiatStatusFindUniqueOrThrowArgs} args - Arguments to find a EscrowFiatStatus
     * @example
     * // Get one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscrowFiatStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, EscrowFiatStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscrowFiatStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusFindFirstArgs} args - Arguments to find a EscrowFiatStatus
     * @example
     * // Get one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscrowFiatStatusFindFirstArgs>(args?: SelectSubset<T, EscrowFiatStatusFindFirstArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscrowFiatStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusFindFirstOrThrowArgs} args - Arguments to find a EscrowFiatStatus
     * @example
     * // Get one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscrowFiatStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, EscrowFiatStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscrowFiatStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscrowFiatStatuses
     * const escrowFiatStatuses = await prisma.escrowFiatStatus.findMany()
     * 
     * // Get first 10 EscrowFiatStatuses
     * const escrowFiatStatuses = await prisma.escrowFiatStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrowFiatStatusWithIdOnly = await prisma.escrowFiatStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscrowFiatStatusFindManyArgs>(args?: SelectSubset<T, EscrowFiatStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscrowFiatStatus.
     * @param {EscrowFiatStatusCreateArgs} args - Arguments to create a EscrowFiatStatus.
     * @example
     * // Create one EscrowFiatStatus
     * const EscrowFiatStatus = await prisma.escrowFiatStatus.create({
     *   data: {
     *     // ... data to create a EscrowFiatStatus
     *   }
     * })
     * 
     */
    create<T extends EscrowFiatStatusCreateArgs>(args: SelectSubset<T, EscrowFiatStatusCreateArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscrowFiatStatuses.
     * @param {EscrowFiatStatusCreateManyArgs} args - Arguments to create many EscrowFiatStatuses.
     * @example
     * // Create many EscrowFiatStatuses
     * const escrowFiatStatus = await prisma.escrowFiatStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscrowFiatStatusCreateManyArgs>(args?: SelectSubset<T, EscrowFiatStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscrowFiatStatuses and returns the data saved in the database.
     * @param {EscrowFiatStatusCreateManyAndReturnArgs} args - Arguments to create many EscrowFiatStatuses.
     * @example
     * // Create many EscrowFiatStatuses
     * const escrowFiatStatus = await prisma.escrowFiatStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscrowFiatStatuses and only return the `id`
     * const escrowFiatStatusWithIdOnly = await prisma.escrowFiatStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscrowFiatStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, EscrowFiatStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscrowFiatStatus.
     * @param {EscrowFiatStatusDeleteArgs} args - Arguments to delete one EscrowFiatStatus.
     * @example
     * // Delete one EscrowFiatStatus
     * const EscrowFiatStatus = await prisma.escrowFiatStatus.delete({
     *   where: {
     *     // ... filter to delete one EscrowFiatStatus
     *   }
     * })
     * 
     */
    delete<T extends EscrowFiatStatusDeleteArgs>(args: SelectSubset<T, EscrowFiatStatusDeleteArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscrowFiatStatus.
     * @param {EscrowFiatStatusUpdateArgs} args - Arguments to update one EscrowFiatStatus.
     * @example
     * // Update one EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscrowFiatStatusUpdateArgs>(args: SelectSubset<T, EscrowFiatStatusUpdateArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscrowFiatStatuses.
     * @param {EscrowFiatStatusDeleteManyArgs} args - Arguments to filter EscrowFiatStatuses to delete.
     * @example
     * // Delete a few EscrowFiatStatuses
     * const { count } = await prisma.escrowFiatStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscrowFiatStatusDeleteManyArgs>(args?: SelectSubset<T, EscrowFiatStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscrowFiatStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscrowFiatStatuses
     * const escrowFiatStatus = await prisma.escrowFiatStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscrowFiatStatusUpdateManyArgs>(args: SelectSubset<T, EscrowFiatStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscrowFiatStatus.
     * @param {EscrowFiatStatusUpsertArgs} args - Arguments to update or create a EscrowFiatStatus.
     * @example
     * // Update or create a EscrowFiatStatus
     * const escrowFiatStatus = await prisma.escrowFiatStatus.upsert({
     *   create: {
     *     // ... data to create a EscrowFiatStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscrowFiatStatus we want to update
     *   }
     * })
     */
    upsert<T extends EscrowFiatStatusUpsertArgs>(args: SelectSubset<T, EscrowFiatStatusUpsertArgs<ExtArgs>>): Prisma__EscrowFiatStatusClient<$Result.GetResult<Prisma.$EscrowFiatStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscrowFiatStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusCountArgs} args - Arguments to filter EscrowFiatStatuses to count.
     * @example
     * // Count the number of EscrowFiatStatuses
     * const count = await prisma.escrowFiatStatus.count({
     *   where: {
     *     // ... the filter for the EscrowFiatStatuses we want to count
     *   }
     * })
    **/
    count<T extends EscrowFiatStatusCountArgs>(
      args?: Subset<T, EscrowFiatStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowFiatStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscrowFiatStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowFiatStatusAggregateArgs>(args: Subset<T, EscrowFiatStatusAggregateArgs>): Prisma.PrismaPromise<GetEscrowFiatStatusAggregateType<T>>

    /**
     * Group by EscrowFiatStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowFiatStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscrowFiatStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscrowFiatStatusGroupByArgs['orderBy'] }
        : { orderBy?: EscrowFiatStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscrowFiatStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowFiatStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscrowFiatStatus model
   */
  readonly fields: EscrowFiatStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscrowFiatStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscrowFiatStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowFiatStatus$EscrowArgs<ExtArgs> = {}>(args?: Subset<T, EscrowFiatStatus$EscrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscrowFiatStatus model
   */ 
  interface EscrowFiatStatusFieldRefs {
    readonly id: FieldRef<"EscrowFiatStatus", 'BigInt'>
    readonly escrowId: FieldRef<"EscrowFiatStatus", 'Bytes'>
    readonly actor: FieldRef<"EscrowFiatStatus", 'String'>
    readonly status: FieldRef<"EscrowFiatStatus", 'String'>
    readonly note: FieldRef<"EscrowFiatStatus", 'String'>
    readonly createdAt: FieldRef<"EscrowFiatStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EscrowFiatStatus findUnique
   */
  export type EscrowFiatStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatus to fetch.
     */
    where: EscrowFiatStatusWhereUniqueInput
  }

  /**
   * EscrowFiatStatus findUniqueOrThrow
   */
  export type EscrowFiatStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatus to fetch.
     */
    where: EscrowFiatStatusWhereUniqueInput
  }

  /**
   * EscrowFiatStatus findFirst
   */
  export type EscrowFiatStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatus to fetch.
     */
    where?: EscrowFiatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowFiatStatuses to fetch.
     */
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowFiatStatuses.
     */
    cursor?: EscrowFiatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowFiatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowFiatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowFiatStatuses.
     */
    distinct?: EscrowFiatStatusScalarFieldEnum | EscrowFiatStatusScalarFieldEnum[]
  }

  /**
   * EscrowFiatStatus findFirstOrThrow
   */
  export type EscrowFiatStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatus to fetch.
     */
    where?: EscrowFiatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowFiatStatuses to fetch.
     */
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscrowFiatStatuses.
     */
    cursor?: EscrowFiatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowFiatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowFiatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscrowFiatStatuses.
     */
    distinct?: EscrowFiatStatusScalarFieldEnum | EscrowFiatStatusScalarFieldEnum[]
  }

  /**
   * EscrowFiatStatus findMany
   */
  export type EscrowFiatStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter, which EscrowFiatStatuses to fetch.
     */
    where?: EscrowFiatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscrowFiatStatuses to fetch.
     */
    orderBy?: EscrowFiatStatusOrderByWithRelationInput | EscrowFiatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscrowFiatStatuses.
     */
    cursor?: EscrowFiatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscrowFiatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscrowFiatStatuses.
     */
    skip?: number
    distinct?: EscrowFiatStatusScalarFieldEnum | EscrowFiatStatusScalarFieldEnum[]
  }

  /**
   * EscrowFiatStatus create
   */
  export type EscrowFiatStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a EscrowFiatStatus.
     */
    data: XOR<EscrowFiatStatusCreateInput, EscrowFiatStatusUncheckedCreateInput>
  }

  /**
   * EscrowFiatStatus createMany
   */
  export type EscrowFiatStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscrowFiatStatuses.
     */
    data: EscrowFiatStatusCreateManyInput | EscrowFiatStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscrowFiatStatus createManyAndReturn
   */
  export type EscrowFiatStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscrowFiatStatuses.
     */
    data: EscrowFiatStatusCreateManyInput | EscrowFiatStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscrowFiatStatus update
   */
  export type EscrowFiatStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a EscrowFiatStatus.
     */
    data: XOR<EscrowFiatStatusUpdateInput, EscrowFiatStatusUncheckedUpdateInput>
    /**
     * Choose, which EscrowFiatStatus to update.
     */
    where: EscrowFiatStatusWhereUniqueInput
  }

  /**
   * EscrowFiatStatus updateMany
   */
  export type EscrowFiatStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscrowFiatStatuses.
     */
    data: XOR<EscrowFiatStatusUpdateManyMutationInput, EscrowFiatStatusUncheckedUpdateManyInput>
    /**
     * Filter which EscrowFiatStatuses to update
     */
    where?: EscrowFiatStatusWhereInput
  }

  /**
   * EscrowFiatStatus upsert
   */
  export type EscrowFiatStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the EscrowFiatStatus to update in case it exists.
     */
    where: EscrowFiatStatusWhereUniqueInput
    /**
     * In case the EscrowFiatStatus found by the `where` argument doesn't exist, create a new EscrowFiatStatus with this data.
     */
    create: XOR<EscrowFiatStatusCreateInput, EscrowFiatStatusUncheckedCreateInput>
    /**
     * In case the EscrowFiatStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscrowFiatStatusUpdateInput, EscrowFiatStatusUncheckedUpdateInput>
  }

  /**
   * EscrowFiatStatus delete
   */
  export type EscrowFiatStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
    /**
     * Filter which EscrowFiatStatus to delete.
     */
    where: EscrowFiatStatusWhereUniqueInput
  }

  /**
   * EscrowFiatStatus deleteMany
   */
  export type EscrowFiatStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscrowFiatStatuses to delete
     */
    where?: EscrowFiatStatusWhereInput
  }

  /**
   * EscrowFiatStatus.Escrow
   */
  export type EscrowFiatStatus$EscrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    where?: EscrowWhereInput
  }

  /**
   * EscrowFiatStatus without action
   */
  export type EscrowFiatStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscrowFiatStatus
     */
    select?: EscrowFiatStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowFiatStatusInclude<ExtArgs> | null
  }


  /**
   * Model EvidenceItem
   */

  export type AggregateEvidenceItem = {
    _count: EvidenceItemCountAggregateOutputType | null
    _avg: EvidenceItemAvgAggregateOutputType | null
    _sum: EvidenceItemSumAggregateOutputType | null
    _min: EvidenceItemMinAggregateOutputType | null
    _max: EvidenceItemMaxAggregateOutputType | null
  }

  export type EvidenceItemAvgAggregateOutputType = {
    size: number | null
  }

  export type EvidenceItemSumAggregateOutputType = {
    size: bigint | null
  }

  export type EvidenceItemMinAggregateOutputType = {
    id: string | null
    escrowId: Buffer | null
    uploader: string | null
    uri: string | null
    sha256: string | null
    mime: string | null
    size: bigint | null
    description: string | null
    createdAt: Date | null
  }

  export type EvidenceItemMaxAggregateOutputType = {
    id: string | null
    escrowId: Buffer | null
    uploader: string | null
    uri: string | null
    sha256: string | null
    mime: string | null
    size: bigint | null
    description: string | null
    createdAt: Date | null
  }

  export type EvidenceItemCountAggregateOutputType = {
    id: number
    escrowId: number
    uploader: number
    uri: number
    sha256: number
    mime: number
    size: number
    description: number
    createdAt: number
    _all: number
  }


  export type EvidenceItemAvgAggregateInputType = {
    size?: true
  }

  export type EvidenceItemSumAggregateInputType = {
    size?: true
  }

  export type EvidenceItemMinAggregateInputType = {
    id?: true
    escrowId?: true
    uploader?: true
    uri?: true
    sha256?: true
    mime?: true
    size?: true
    description?: true
    createdAt?: true
  }

  export type EvidenceItemMaxAggregateInputType = {
    id?: true
    escrowId?: true
    uploader?: true
    uri?: true
    sha256?: true
    mime?: true
    size?: true
    description?: true
    createdAt?: true
  }

  export type EvidenceItemCountAggregateInputType = {
    id?: true
    escrowId?: true
    uploader?: true
    uri?: true
    sha256?: true
    mime?: true
    size?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type EvidenceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvidenceItem to aggregate.
     */
    where?: EvidenceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvidenceItems to fetch.
     */
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvidenceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvidenceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvidenceItems
    **/
    _count?: true | EvidenceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvidenceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvidenceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenceItemMaxAggregateInputType
  }

  export type GetEvidenceItemAggregateType<T extends EvidenceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidenceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidenceItem[P]>
      : GetScalarType<T[P], AggregateEvidenceItem[P]>
  }




  export type EvidenceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceItemWhereInput
    orderBy?: EvidenceItemOrderByWithAggregationInput | EvidenceItemOrderByWithAggregationInput[]
    by: EvidenceItemScalarFieldEnum[] | EvidenceItemScalarFieldEnum
    having?: EvidenceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenceItemCountAggregateInputType | true
    _avg?: EvidenceItemAvgAggregateInputType
    _sum?: EvidenceItemSumAggregateInputType
    _min?: EvidenceItemMinAggregateInputType
    _max?: EvidenceItemMaxAggregateInputType
  }

  export type EvidenceItemGroupByOutputType = {
    id: string
    escrowId: Buffer | null
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint
    description: string | null
    createdAt: Date
    _count: EvidenceItemCountAggregateOutputType | null
    _avg: EvidenceItemAvgAggregateOutputType | null
    _sum: EvidenceItemSumAggregateOutputType | null
    _min: EvidenceItemMinAggregateOutputType | null
    _max: EvidenceItemMaxAggregateOutputType | null
  }

  type GetEvidenceItemGroupByPayload<T extends EvidenceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenceItemGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenceItemGroupByOutputType[P]>
        }
      >
    >


  export type EvidenceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    uploader?: boolean
    uri?: boolean
    sha256?: boolean
    mime?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
    Escrow?: boolean | EvidenceItem$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["evidenceItem"]>

  export type EvidenceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrowId?: boolean
    uploader?: boolean
    uri?: boolean
    sha256?: boolean
    mime?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
    Escrow?: boolean | EvidenceItem$EscrowArgs<ExtArgs>
  }, ExtArgs["result"]["evidenceItem"]>

  export type EvidenceItemSelectScalar = {
    id?: boolean
    escrowId?: boolean
    uploader?: boolean
    uri?: boolean
    sha256?: boolean
    mime?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type EvidenceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EvidenceItem$EscrowArgs<ExtArgs>
  }
  export type EvidenceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EvidenceItem$EscrowArgs<ExtArgs>
  }

  export type $EvidenceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvidenceItem"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      escrowId: Buffer | null
      uploader: string
      uri: string
      sha256: string
      mime: string
      size: bigint
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["evidenceItem"]>
    composites: {}
  }

  type EvidenceItemGetPayload<S extends boolean | null | undefined | EvidenceItemDefaultArgs> = $Result.GetResult<Prisma.$EvidenceItemPayload, S>

  type EvidenceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvidenceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvidenceItemCountAggregateInputType | true
    }

  export interface EvidenceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvidenceItem'], meta: { name: 'EvidenceItem' } }
    /**
     * Find zero or one EvidenceItem that matches the filter.
     * @param {EvidenceItemFindUniqueArgs} args - Arguments to find a EvidenceItem
     * @example
     * // Get one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenceItemFindUniqueArgs>(args: SelectSubset<T, EvidenceItemFindUniqueArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvidenceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvidenceItemFindUniqueOrThrowArgs} args - Arguments to find a EvidenceItem
     * @example
     * // Get one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvidenceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemFindFirstArgs} args - Arguments to find a EvidenceItem
     * @example
     * // Get one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenceItemFindFirstArgs>(args?: SelectSubset<T, EvidenceItemFindFirstArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvidenceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemFindFirstOrThrowArgs} args - Arguments to find a EvidenceItem
     * @example
     * // Get one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvidenceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvidenceItems
     * const evidenceItems = await prisma.evidenceItem.findMany()
     * 
     * // Get first 10 EvidenceItems
     * const evidenceItems = await prisma.evidenceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenceItemWithIdOnly = await prisma.evidenceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenceItemFindManyArgs>(args?: SelectSubset<T, EvidenceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvidenceItem.
     * @param {EvidenceItemCreateArgs} args - Arguments to create a EvidenceItem.
     * @example
     * // Create one EvidenceItem
     * const EvidenceItem = await prisma.evidenceItem.create({
     *   data: {
     *     // ... data to create a EvidenceItem
     *   }
     * })
     * 
     */
    create<T extends EvidenceItemCreateArgs>(args: SelectSubset<T, EvidenceItemCreateArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvidenceItems.
     * @param {EvidenceItemCreateManyArgs} args - Arguments to create many EvidenceItems.
     * @example
     * // Create many EvidenceItems
     * const evidenceItem = await prisma.evidenceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenceItemCreateManyArgs>(args?: SelectSubset<T, EvidenceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvidenceItems and returns the data saved in the database.
     * @param {EvidenceItemCreateManyAndReturnArgs} args - Arguments to create many EvidenceItems.
     * @example
     * // Create many EvidenceItems
     * const evidenceItem = await prisma.evidenceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvidenceItems and only return the `id`
     * const evidenceItemWithIdOnly = await prisma.evidenceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvidenceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvidenceItem.
     * @param {EvidenceItemDeleteArgs} args - Arguments to delete one EvidenceItem.
     * @example
     * // Delete one EvidenceItem
     * const EvidenceItem = await prisma.evidenceItem.delete({
     *   where: {
     *     // ... filter to delete one EvidenceItem
     *   }
     * })
     * 
     */
    delete<T extends EvidenceItemDeleteArgs>(args: SelectSubset<T, EvidenceItemDeleteArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvidenceItem.
     * @param {EvidenceItemUpdateArgs} args - Arguments to update one EvidenceItem.
     * @example
     * // Update one EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenceItemUpdateArgs>(args: SelectSubset<T, EvidenceItemUpdateArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvidenceItems.
     * @param {EvidenceItemDeleteManyArgs} args - Arguments to filter EvidenceItems to delete.
     * @example
     * // Delete a few EvidenceItems
     * const { count } = await prisma.evidenceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenceItemDeleteManyArgs>(args?: SelectSubset<T, EvidenceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvidenceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvidenceItems
     * const evidenceItem = await prisma.evidenceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenceItemUpdateManyArgs>(args: SelectSubset<T, EvidenceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvidenceItem.
     * @param {EvidenceItemUpsertArgs} args - Arguments to update or create a EvidenceItem.
     * @example
     * // Update or create a EvidenceItem
     * const evidenceItem = await prisma.evidenceItem.upsert({
     *   create: {
     *     // ... data to create a EvidenceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvidenceItem we want to update
     *   }
     * })
     */
    upsert<T extends EvidenceItemUpsertArgs>(args: SelectSubset<T, EvidenceItemUpsertArgs<ExtArgs>>): Prisma__EvidenceItemClient<$Result.GetResult<Prisma.$EvidenceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvidenceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemCountArgs} args - Arguments to filter EvidenceItems to count.
     * @example
     * // Count the number of EvidenceItems
     * const count = await prisma.evidenceItem.count({
     *   where: {
     *     // ... the filter for the EvidenceItems we want to count
     *   }
     * })
    **/
    count<T extends EvidenceItemCountArgs>(
      args?: Subset<T, EvidenceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvidenceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenceItemAggregateArgs>(args: Subset<T, EvidenceItemAggregateArgs>): Prisma.PrismaPromise<GetEvidenceItemAggregateType<T>>

    /**
     * Group by EvidenceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenceItemGroupByArgs['orderBy'] }
        : { orderBy?: EvidenceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvidenceItem model
   */
  readonly fields: EvidenceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvidenceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EvidenceItem$EscrowArgs<ExtArgs> = {}>(args?: Subset<T, EvidenceItem$EscrowArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvidenceItem model
   */ 
  interface EvidenceItemFieldRefs {
    readonly id: FieldRef<"EvidenceItem", 'String'>
    readonly escrowId: FieldRef<"EvidenceItem", 'Bytes'>
    readonly uploader: FieldRef<"EvidenceItem", 'String'>
    readonly uri: FieldRef<"EvidenceItem", 'String'>
    readonly sha256: FieldRef<"EvidenceItem", 'String'>
    readonly mime: FieldRef<"EvidenceItem", 'String'>
    readonly size: FieldRef<"EvidenceItem", 'BigInt'>
    readonly description: FieldRef<"EvidenceItem", 'String'>
    readonly createdAt: FieldRef<"EvidenceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvidenceItem findUnique
   */
  export type EvidenceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItem to fetch.
     */
    where: EvidenceItemWhereUniqueInput
  }

  /**
   * EvidenceItem findUniqueOrThrow
   */
  export type EvidenceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItem to fetch.
     */
    where: EvidenceItemWhereUniqueInput
  }

  /**
   * EvidenceItem findFirst
   */
  export type EvidenceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItem to fetch.
     */
    where?: EvidenceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvidenceItems to fetch.
     */
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvidenceItems.
     */
    cursor?: EvidenceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvidenceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvidenceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvidenceItems.
     */
    distinct?: EvidenceItemScalarFieldEnum | EvidenceItemScalarFieldEnum[]
  }

  /**
   * EvidenceItem findFirstOrThrow
   */
  export type EvidenceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItem to fetch.
     */
    where?: EvidenceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvidenceItems to fetch.
     */
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvidenceItems.
     */
    cursor?: EvidenceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvidenceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvidenceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvidenceItems.
     */
    distinct?: EvidenceItemScalarFieldEnum | EvidenceItemScalarFieldEnum[]
  }

  /**
   * EvidenceItem findMany
   */
  export type EvidenceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceItems to fetch.
     */
    where?: EvidenceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvidenceItems to fetch.
     */
    orderBy?: EvidenceItemOrderByWithRelationInput | EvidenceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvidenceItems.
     */
    cursor?: EvidenceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvidenceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvidenceItems.
     */
    skip?: number
    distinct?: EvidenceItemScalarFieldEnum | EvidenceItemScalarFieldEnum[]
  }

  /**
   * EvidenceItem create
   */
  export type EvidenceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a EvidenceItem.
     */
    data: XOR<EvidenceItemCreateInput, EvidenceItemUncheckedCreateInput>
  }

  /**
   * EvidenceItem createMany
   */
  export type EvidenceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvidenceItems.
     */
    data: EvidenceItemCreateManyInput | EvidenceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvidenceItem createManyAndReturn
   */
  export type EvidenceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvidenceItems.
     */
    data: EvidenceItemCreateManyInput | EvidenceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvidenceItem update
   */
  export type EvidenceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a EvidenceItem.
     */
    data: XOR<EvidenceItemUpdateInput, EvidenceItemUncheckedUpdateInput>
    /**
     * Choose, which EvidenceItem to update.
     */
    where: EvidenceItemWhereUniqueInput
  }

  /**
   * EvidenceItem updateMany
   */
  export type EvidenceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvidenceItems.
     */
    data: XOR<EvidenceItemUpdateManyMutationInput, EvidenceItemUncheckedUpdateManyInput>
    /**
     * Filter which EvidenceItems to update
     */
    where?: EvidenceItemWhereInput
  }

  /**
   * EvidenceItem upsert
   */
  export type EvidenceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the EvidenceItem to update in case it exists.
     */
    where: EvidenceItemWhereUniqueInput
    /**
     * In case the EvidenceItem found by the `where` argument doesn't exist, create a new EvidenceItem with this data.
     */
    create: XOR<EvidenceItemCreateInput, EvidenceItemUncheckedCreateInput>
    /**
     * In case the EvidenceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenceItemUpdateInput, EvidenceItemUncheckedUpdateInput>
  }

  /**
   * EvidenceItem delete
   */
  export type EvidenceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
    /**
     * Filter which EvidenceItem to delete.
     */
    where: EvidenceItemWhereUniqueInput
  }

  /**
   * EvidenceItem deleteMany
   */
  export type EvidenceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvidenceItems to delete
     */
    where?: EvidenceItemWhereInput
  }

  /**
   * EvidenceItem.Escrow
   */
  export type EvidenceItem$EscrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow
     */
    select?: EscrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscrowInclude<ExtArgs> | null
    where?: EscrowWhereInput
  }

  /**
   * EvidenceItem without action
   */
  export type EvidenceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceItem
     */
    select?: EvidenceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceItemInclude<ExtArgs> | null
  }


  /**
   * Model Dispute
   */

  export type AggregateDispute = {
    _count: DisputeCountAggregateOutputType | null
    _min: DisputeMinAggregateOutputType | null
    _max: DisputeMaxAggregateOutputType | null
  }

  export type DisputeMinAggregateOutputType = {
    escrowId: Buffer | null
    openedBy: string | null
    reasonCode: string | null
    summary: string | null
    status: string | null
    arbitratorAssigned: string | null
    outcome: string | null
    ref: Buffer | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputeMaxAggregateOutputType = {
    escrowId: Buffer | null
    openedBy: string | null
    reasonCode: string | null
    summary: string | null
    status: string | null
    arbitratorAssigned: string | null
    outcome: string | null
    ref: Buffer | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputeCountAggregateOutputType = {
    escrowId: number
    openedBy: number
    reasonCode: number
    summary: number
    status: number
    arbitratorAssigned: number
    outcome: number
    ref: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisputeMinAggregateInputType = {
    escrowId?: true
    openedBy?: true
    reasonCode?: true
    summary?: true
    status?: true
    arbitratorAssigned?: true
    outcome?: true
    ref?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputeMaxAggregateInputType = {
    escrowId?: true
    openedBy?: true
    reasonCode?: true
    summary?: true
    status?: true
    arbitratorAssigned?: true
    outcome?: true
    ref?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputeCountAggregateInputType = {
    escrowId?: true
    openedBy?: true
    reasonCode?: true
    summary?: true
    status?: true
    arbitratorAssigned?: true
    outcome?: true
    ref?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisputeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispute to aggregate.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Disputes
    **/
    _count?: true | DisputeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputeMaxAggregateInputType
  }

  export type GetDisputeAggregateType<T extends DisputeAggregateArgs> = {
        [P in keyof T & keyof AggregateDispute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispute[P]>
      : GetScalarType<T[P], AggregateDispute[P]>
  }




  export type DisputeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithAggregationInput | DisputeOrderByWithAggregationInput[]
    by: DisputeScalarFieldEnum[] | DisputeScalarFieldEnum
    having?: DisputeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputeCountAggregateInputType | true
    _min?: DisputeMinAggregateInputType
    _max?: DisputeMaxAggregateInputType
  }

  export type DisputeGroupByOutputType = {
    escrowId: Buffer
    openedBy: string
    reasonCode: string | null
    summary: string | null
    status: string
    arbitratorAssigned: string | null
    outcome: string | null
    ref: Buffer | null
    createdAt: Date
    updatedAt: Date
    _count: DisputeCountAggregateOutputType | null
    _min: DisputeMinAggregateOutputType | null
    _max: DisputeMaxAggregateOutputType | null
  }

  type GetDisputeGroupByPayload<T extends DisputeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputeGroupByOutputType[P]>
            : GetScalarType<T[P], DisputeGroupByOutputType[P]>
        }
      >
    >


  export type DisputeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    openedBy?: boolean
    reasonCode?: boolean
    summary?: boolean
    status?: boolean
    arbitratorAssigned?: boolean
    outcome?: boolean
    ref?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    escrowId?: boolean
    openedBy?: boolean
    reasonCode?: boolean
    summary?: boolean
    status?: boolean
    arbitratorAssigned?: boolean
    outcome?: boolean
    ref?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectScalar = {
    escrowId?: boolean
    openedBy?: boolean
    reasonCode?: boolean
    summary?: boolean
    status?: boolean
    arbitratorAssigned?: boolean
    outcome?: boolean
    ref?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DisputeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }
  export type DisputeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Escrow?: boolean | EscrowDefaultArgs<ExtArgs>
  }

  export type $DisputePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dispute"
    objects: {
      Escrow: Prisma.$EscrowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      escrowId: Buffer
      openedBy: string
      reasonCode: string | null
      summary: string | null
      status: string
      arbitratorAssigned: string | null
      outcome: string | null
      ref: Buffer | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dispute"]>
    composites: {}
  }

  type DisputeGetPayload<S extends boolean | null | undefined | DisputeDefaultArgs> = $Result.GetResult<Prisma.$DisputePayload, S>

  type DisputeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DisputeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DisputeCountAggregateInputType | true
    }

  export interface DisputeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dispute'], meta: { name: 'Dispute' } }
    /**
     * Find zero or one Dispute that matches the filter.
     * @param {DisputeFindUniqueArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisputeFindUniqueArgs>(args: SelectSubset<T, DisputeFindUniqueArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dispute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DisputeFindUniqueOrThrowArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisputeFindUniqueOrThrowArgs>(args: SelectSubset<T, DisputeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dispute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindFirstArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisputeFindFirstArgs>(args?: SelectSubset<T, DisputeFindFirstArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dispute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindFirstOrThrowArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisputeFindFirstOrThrowArgs>(args?: SelectSubset<T, DisputeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Disputes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disputes
     * const disputes = await prisma.dispute.findMany()
     * 
     * // Get first 10 Disputes
     * const disputes = await prisma.dispute.findMany({ take: 10 })
     * 
     * // Only select the `escrowId`
     * const disputeWithEscrowIdOnly = await prisma.dispute.findMany({ select: { escrowId: true } })
     * 
     */
    findMany<T extends DisputeFindManyArgs>(args?: SelectSubset<T, DisputeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dispute.
     * @param {DisputeCreateArgs} args - Arguments to create a Dispute.
     * @example
     * // Create one Dispute
     * const Dispute = await prisma.dispute.create({
     *   data: {
     *     // ... data to create a Dispute
     *   }
     * })
     * 
     */
    create<T extends DisputeCreateArgs>(args: SelectSubset<T, DisputeCreateArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Disputes.
     * @param {DisputeCreateManyArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const dispute = await prisma.dispute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisputeCreateManyArgs>(args?: SelectSubset<T, DisputeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Disputes and returns the data saved in the database.
     * @param {DisputeCreateManyAndReturnArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const dispute = await prisma.dispute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Disputes and only return the `escrowId`
     * const disputeWithEscrowIdOnly = await prisma.dispute.createManyAndReturn({ 
     *   select: { escrowId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisputeCreateManyAndReturnArgs>(args?: SelectSubset<T, DisputeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dispute.
     * @param {DisputeDeleteArgs} args - Arguments to delete one Dispute.
     * @example
     * // Delete one Dispute
     * const Dispute = await prisma.dispute.delete({
     *   where: {
     *     // ... filter to delete one Dispute
     *   }
     * })
     * 
     */
    delete<T extends DisputeDeleteArgs>(args: SelectSubset<T, DisputeDeleteArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dispute.
     * @param {DisputeUpdateArgs} args - Arguments to update one Dispute.
     * @example
     * // Update one Dispute
     * const dispute = await prisma.dispute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisputeUpdateArgs>(args: SelectSubset<T, DisputeUpdateArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Disputes.
     * @param {DisputeDeleteManyArgs} args - Arguments to filter Disputes to delete.
     * @example
     * // Delete a few Disputes
     * const { count } = await prisma.dispute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisputeDeleteManyArgs>(args?: SelectSubset<T, DisputeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disputes
     * const dispute = await prisma.dispute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisputeUpdateManyArgs>(args: SelectSubset<T, DisputeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dispute.
     * @param {DisputeUpsertArgs} args - Arguments to update or create a Dispute.
     * @example
     * // Update or create a Dispute
     * const dispute = await prisma.dispute.upsert({
     *   create: {
     *     // ... data to create a Dispute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispute we want to update
     *   }
     * })
     */
    upsert<T extends DisputeUpsertArgs>(args: SelectSubset<T, DisputeUpsertArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeCountArgs} args - Arguments to filter Disputes to count.
     * @example
     * // Count the number of Disputes
     * const count = await prisma.dispute.count({
     *   where: {
     *     // ... the filter for the Disputes we want to count
     *   }
     * })
    **/
    count<T extends DisputeCountArgs>(
      args?: Subset<T, DisputeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputeAggregateArgs>(args: Subset<T, DisputeAggregateArgs>): Prisma.PrismaPromise<GetDisputeAggregateType<T>>

    /**
     * Group by Dispute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisputeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisputeGroupByArgs['orderBy'] }
        : { orderBy?: DisputeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisputeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dispute model
   */
  readonly fields: DisputeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dispute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisputeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Escrow<T extends EscrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscrowDefaultArgs<ExtArgs>>): Prisma__EscrowClient<$Result.GetResult<Prisma.$EscrowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dispute model
   */ 
  interface DisputeFieldRefs {
    readonly escrowId: FieldRef<"Dispute", 'Bytes'>
    readonly openedBy: FieldRef<"Dispute", 'String'>
    readonly reasonCode: FieldRef<"Dispute", 'String'>
    readonly summary: FieldRef<"Dispute", 'String'>
    readonly status: FieldRef<"Dispute", 'String'>
    readonly arbitratorAssigned: FieldRef<"Dispute", 'String'>
    readonly outcome: FieldRef<"Dispute", 'String'>
    readonly ref: FieldRef<"Dispute", 'Bytes'>
    readonly createdAt: FieldRef<"Dispute", 'DateTime'>
    readonly updatedAt: FieldRef<"Dispute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dispute findUnique
   */
  export type DisputeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute findUniqueOrThrow
   */
  export type DisputeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute findFirst
   */
  export type DisputeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disputes.
     */
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute findFirstOrThrow
   */
  export type DisputeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disputes.
     */
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute findMany
   */
  export type DisputeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Disputes to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute create
   */
  export type DisputeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The data needed to create a Dispute.
     */
    data: XOR<DisputeCreateInput, DisputeUncheckedCreateInput>
  }

  /**
   * Dispute createMany
   */
  export type DisputeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Disputes.
     */
    data: DisputeCreateManyInput | DisputeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dispute createManyAndReturn
   */
  export type DisputeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Disputes.
     */
    data: DisputeCreateManyInput | DisputeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispute update
   */
  export type DisputeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The data needed to update a Dispute.
     */
    data: XOR<DisputeUpdateInput, DisputeUncheckedUpdateInput>
    /**
     * Choose, which Dispute to update.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute updateMany
   */
  export type DisputeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Disputes.
     */
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyInput>
    /**
     * Filter which Disputes to update
     */
    where?: DisputeWhereInput
  }

  /**
   * Dispute upsert
   */
  export type DisputeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The filter to search for the Dispute to update in case it exists.
     */
    where: DisputeWhereUniqueInput
    /**
     * In case the Dispute found by the `where` argument doesn't exist, create a new Dispute with this data.
     */
    create: XOR<DisputeCreateInput, DisputeUncheckedCreateInput>
    /**
     * In case the Dispute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisputeUpdateInput, DisputeUncheckedUpdateInput>
  }

  /**
   * Dispute delete
   */
  export type DisputeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter which Dispute to delete.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute deleteMany
   */
  export type DisputeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disputes to delete
     */
    where?: DisputeWhereInput
  }

  /**
   * Dispute without action
   */
  export type DisputeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
  }


  /**
   * Model IndexerCheckpoint
   */

  export type AggregateIndexerCheckpoint = {
    _count: IndexerCheckpointCountAggregateOutputType | null
    _avg: IndexerCheckpointAvgAggregateOutputType | null
    _sum: IndexerCheckpointSumAggregateOutputType | null
    _min: IndexerCheckpointMinAggregateOutputType | null
    _max: IndexerCheckpointMaxAggregateOutputType | null
  }

  export type IndexerCheckpointAvgAggregateOutputType = {
    chainId: number | null
    lastSyncedBlock: number | null
  }

  export type IndexerCheckpointSumAggregateOutputType = {
    chainId: number | null
    lastSyncedBlock: bigint | null
  }

  export type IndexerCheckpointMinAggregateOutputType = {
    chainId: number | null
    contractAddress: string | null
    lastSyncedBlock: bigint | null
    updatedAt: Date | null
  }

  export type IndexerCheckpointMaxAggregateOutputType = {
    chainId: number | null
    contractAddress: string | null
    lastSyncedBlock: bigint | null
    updatedAt: Date | null
  }

  export type IndexerCheckpointCountAggregateOutputType = {
    chainId: number
    contractAddress: number
    lastSyncedBlock: number
    updatedAt: number
    _all: number
  }


  export type IndexerCheckpointAvgAggregateInputType = {
    chainId?: true
    lastSyncedBlock?: true
  }

  export type IndexerCheckpointSumAggregateInputType = {
    chainId?: true
    lastSyncedBlock?: true
  }

  export type IndexerCheckpointMinAggregateInputType = {
    chainId?: true
    contractAddress?: true
    lastSyncedBlock?: true
    updatedAt?: true
  }

  export type IndexerCheckpointMaxAggregateInputType = {
    chainId?: true
    contractAddress?: true
    lastSyncedBlock?: true
    updatedAt?: true
  }

  export type IndexerCheckpointCountAggregateInputType = {
    chainId?: true
    contractAddress?: true
    lastSyncedBlock?: true
    updatedAt?: true
    _all?: true
  }

  export type IndexerCheckpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndexerCheckpoint to aggregate.
     */
    where?: IndexerCheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndexerCheckpoints to fetch.
     */
    orderBy?: IndexerCheckpointOrderByWithRelationInput | IndexerCheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndexerCheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndexerCheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndexerCheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndexerCheckpoints
    **/
    _count?: true | IndexerCheckpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndexerCheckpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndexerCheckpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndexerCheckpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndexerCheckpointMaxAggregateInputType
  }

  export type GetIndexerCheckpointAggregateType<T extends IndexerCheckpointAggregateArgs> = {
        [P in keyof T & keyof AggregateIndexerCheckpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndexerCheckpoint[P]>
      : GetScalarType<T[P], AggregateIndexerCheckpoint[P]>
  }




  export type IndexerCheckpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndexerCheckpointWhereInput
    orderBy?: IndexerCheckpointOrderByWithAggregationInput | IndexerCheckpointOrderByWithAggregationInput[]
    by: IndexerCheckpointScalarFieldEnum[] | IndexerCheckpointScalarFieldEnum
    having?: IndexerCheckpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndexerCheckpointCountAggregateInputType | true
    _avg?: IndexerCheckpointAvgAggregateInputType
    _sum?: IndexerCheckpointSumAggregateInputType
    _min?: IndexerCheckpointMinAggregateInputType
    _max?: IndexerCheckpointMaxAggregateInputType
  }

  export type IndexerCheckpointGroupByOutputType = {
    chainId: number
    contractAddress: string
    lastSyncedBlock: bigint
    updatedAt: Date
    _count: IndexerCheckpointCountAggregateOutputType | null
    _avg: IndexerCheckpointAvgAggregateOutputType | null
    _sum: IndexerCheckpointSumAggregateOutputType | null
    _min: IndexerCheckpointMinAggregateOutputType | null
    _max: IndexerCheckpointMaxAggregateOutputType | null
  }

  type GetIndexerCheckpointGroupByPayload<T extends IndexerCheckpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndexerCheckpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndexerCheckpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndexerCheckpointGroupByOutputType[P]>
            : GetScalarType<T[P], IndexerCheckpointGroupByOutputType[P]>
        }
      >
    >


  export type IndexerCheckpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chainId?: boolean
    contractAddress?: boolean
    lastSyncedBlock?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["indexerCheckpoint"]>

  export type IndexerCheckpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chainId?: boolean
    contractAddress?: boolean
    lastSyncedBlock?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["indexerCheckpoint"]>

  export type IndexerCheckpointSelectScalar = {
    chainId?: boolean
    contractAddress?: boolean
    lastSyncedBlock?: boolean
    updatedAt?: boolean
  }


  export type $IndexerCheckpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndexerCheckpoint"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      chainId: number
      contractAddress: string
      lastSyncedBlock: bigint
      updatedAt: Date
    }, ExtArgs["result"]["indexerCheckpoint"]>
    composites: {}
  }

  type IndexerCheckpointGetPayload<S extends boolean | null | undefined | IndexerCheckpointDefaultArgs> = $Result.GetResult<Prisma.$IndexerCheckpointPayload, S>

  type IndexerCheckpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndexerCheckpointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndexerCheckpointCountAggregateInputType | true
    }

  export interface IndexerCheckpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndexerCheckpoint'], meta: { name: 'IndexerCheckpoint' } }
    /**
     * Find zero or one IndexerCheckpoint that matches the filter.
     * @param {IndexerCheckpointFindUniqueArgs} args - Arguments to find a IndexerCheckpoint
     * @example
     * // Get one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndexerCheckpointFindUniqueArgs>(args: SelectSubset<T, IndexerCheckpointFindUniqueArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IndexerCheckpoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndexerCheckpointFindUniqueOrThrowArgs} args - Arguments to find a IndexerCheckpoint
     * @example
     * // Get one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndexerCheckpointFindUniqueOrThrowArgs>(args: SelectSubset<T, IndexerCheckpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IndexerCheckpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointFindFirstArgs} args - Arguments to find a IndexerCheckpoint
     * @example
     * // Get one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndexerCheckpointFindFirstArgs>(args?: SelectSubset<T, IndexerCheckpointFindFirstArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IndexerCheckpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointFindFirstOrThrowArgs} args - Arguments to find a IndexerCheckpoint
     * @example
     * // Get one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndexerCheckpointFindFirstOrThrowArgs>(args?: SelectSubset<T, IndexerCheckpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IndexerCheckpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndexerCheckpoints
     * const indexerCheckpoints = await prisma.indexerCheckpoint.findMany()
     * 
     * // Get first 10 IndexerCheckpoints
     * const indexerCheckpoints = await prisma.indexerCheckpoint.findMany({ take: 10 })
     * 
     * // Only select the `chainId`
     * const indexerCheckpointWithChainIdOnly = await prisma.indexerCheckpoint.findMany({ select: { chainId: true } })
     * 
     */
    findMany<T extends IndexerCheckpointFindManyArgs>(args?: SelectSubset<T, IndexerCheckpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IndexerCheckpoint.
     * @param {IndexerCheckpointCreateArgs} args - Arguments to create a IndexerCheckpoint.
     * @example
     * // Create one IndexerCheckpoint
     * const IndexerCheckpoint = await prisma.indexerCheckpoint.create({
     *   data: {
     *     // ... data to create a IndexerCheckpoint
     *   }
     * })
     * 
     */
    create<T extends IndexerCheckpointCreateArgs>(args: SelectSubset<T, IndexerCheckpointCreateArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IndexerCheckpoints.
     * @param {IndexerCheckpointCreateManyArgs} args - Arguments to create many IndexerCheckpoints.
     * @example
     * // Create many IndexerCheckpoints
     * const indexerCheckpoint = await prisma.indexerCheckpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndexerCheckpointCreateManyArgs>(args?: SelectSubset<T, IndexerCheckpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndexerCheckpoints and returns the data saved in the database.
     * @param {IndexerCheckpointCreateManyAndReturnArgs} args - Arguments to create many IndexerCheckpoints.
     * @example
     * // Create many IndexerCheckpoints
     * const indexerCheckpoint = await prisma.indexerCheckpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndexerCheckpoints and only return the `chainId`
     * const indexerCheckpointWithChainIdOnly = await prisma.indexerCheckpoint.createManyAndReturn({ 
     *   select: { chainId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndexerCheckpointCreateManyAndReturnArgs>(args?: SelectSubset<T, IndexerCheckpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IndexerCheckpoint.
     * @param {IndexerCheckpointDeleteArgs} args - Arguments to delete one IndexerCheckpoint.
     * @example
     * // Delete one IndexerCheckpoint
     * const IndexerCheckpoint = await prisma.indexerCheckpoint.delete({
     *   where: {
     *     // ... filter to delete one IndexerCheckpoint
     *   }
     * })
     * 
     */
    delete<T extends IndexerCheckpointDeleteArgs>(args: SelectSubset<T, IndexerCheckpointDeleteArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IndexerCheckpoint.
     * @param {IndexerCheckpointUpdateArgs} args - Arguments to update one IndexerCheckpoint.
     * @example
     * // Update one IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndexerCheckpointUpdateArgs>(args: SelectSubset<T, IndexerCheckpointUpdateArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IndexerCheckpoints.
     * @param {IndexerCheckpointDeleteManyArgs} args - Arguments to filter IndexerCheckpoints to delete.
     * @example
     * // Delete a few IndexerCheckpoints
     * const { count } = await prisma.indexerCheckpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndexerCheckpointDeleteManyArgs>(args?: SelectSubset<T, IndexerCheckpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndexerCheckpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndexerCheckpoints
     * const indexerCheckpoint = await prisma.indexerCheckpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndexerCheckpointUpdateManyArgs>(args: SelectSubset<T, IndexerCheckpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndexerCheckpoint.
     * @param {IndexerCheckpointUpsertArgs} args - Arguments to update or create a IndexerCheckpoint.
     * @example
     * // Update or create a IndexerCheckpoint
     * const indexerCheckpoint = await prisma.indexerCheckpoint.upsert({
     *   create: {
     *     // ... data to create a IndexerCheckpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndexerCheckpoint we want to update
     *   }
     * })
     */
    upsert<T extends IndexerCheckpointUpsertArgs>(args: SelectSubset<T, IndexerCheckpointUpsertArgs<ExtArgs>>): Prisma__IndexerCheckpointClient<$Result.GetResult<Prisma.$IndexerCheckpointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IndexerCheckpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointCountArgs} args - Arguments to filter IndexerCheckpoints to count.
     * @example
     * // Count the number of IndexerCheckpoints
     * const count = await prisma.indexerCheckpoint.count({
     *   where: {
     *     // ... the filter for the IndexerCheckpoints we want to count
     *   }
     * })
    **/
    count<T extends IndexerCheckpointCountArgs>(
      args?: Subset<T, IndexerCheckpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndexerCheckpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndexerCheckpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndexerCheckpointAggregateArgs>(args: Subset<T, IndexerCheckpointAggregateArgs>): Prisma.PrismaPromise<GetIndexerCheckpointAggregateType<T>>

    /**
     * Group by IndexerCheckpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndexerCheckpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndexerCheckpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndexerCheckpointGroupByArgs['orderBy'] }
        : { orderBy?: IndexerCheckpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndexerCheckpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndexerCheckpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndexerCheckpoint model
   */
  readonly fields: IndexerCheckpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndexerCheckpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndexerCheckpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndexerCheckpoint model
   */ 
  interface IndexerCheckpointFieldRefs {
    readonly chainId: FieldRef<"IndexerCheckpoint", 'Int'>
    readonly contractAddress: FieldRef<"IndexerCheckpoint", 'String'>
    readonly lastSyncedBlock: FieldRef<"IndexerCheckpoint", 'BigInt'>
    readonly updatedAt: FieldRef<"IndexerCheckpoint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndexerCheckpoint findUnique
   */
  export type IndexerCheckpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoint to fetch.
     */
    where: IndexerCheckpointWhereUniqueInput
  }

  /**
   * IndexerCheckpoint findUniqueOrThrow
   */
  export type IndexerCheckpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoint to fetch.
     */
    where: IndexerCheckpointWhereUniqueInput
  }

  /**
   * IndexerCheckpoint findFirst
   */
  export type IndexerCheckpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoint to fetch.
     */
    where?: IndexerCheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndexerCheckpoints to fetch.
     */
    orderBy?: IndexerCheckpointOrderByWithRelationInput | IndexerCheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndexerCheckpoints.
     */
    cursor?: IndexerCheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndexerCheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndexerCheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndexerCheckpoints.
     */
    distinct?: IndexerCheckpointScalarFieldEnum | IndexerCheckpointScalarFieldEnum[]
  }

  /**
   * IndexerCheckpoint findFirstOrThrow
   */
  export type IndexerCheckpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoint to fetch.
     */
    where?: IndexerCheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndexerCheckpoints to fetch.
     */
    orderBy?: IndexerCheckpointOrderByWithRelationInput | IndexerCheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndexerCheckpoints.
     */
    cursor?: IndexerCheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndexerCheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndexerCheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndexerCheckpoints.
     */
    distinct?: IndexerCheckpointScalarFieldEnum | IndexerCheckpointScalarFieldEnum[]
  }

  /**
   * IndexerCheckpoint findMany
   */
  export type IndexerCheckpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter, which IndexerCheckpoints to fetch.
     */
    where?: IndexerCheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndexerCheckpoints to fetch.
     */
    orderBy?: IndexerCheckpointOrderByWithRelationInput | IndexerCheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndexerCheckpoints.
     */
    cursor?: IndexerCheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndexerCheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndexerCheckpoints.
     */
    skip?: number
    distinct?: IndexerCheckpointScalarFieldEnum | IndexerCheckpointScalarFieldEnum[]
  }

  /**
   * IndexerCheckpoint create
   */
  export type IndexerCheckpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * The data needed to create a IndexerCheckpoint.
     */
    data: XOR<IndexerCheckpointCreateInput, IndexerCheckpointUncheckedCreateInput>
  }

  /**
   * IndexerCheckpoint createMany
   */
  export type IndexerCheckpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndexerCheckpoints.
     */
    data: IndexerCheckpointCreateManyInput | IndexerCheckpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndexerCheckpoint createManyAndReturn
   */
  export type IndexerCheckpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IndexerCheckpoints.
     */
    data: IndexerCheckpointCreateManyInput | IndexerCheckpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndexerCheckpoint update
   */
  export type IndexerCheckpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * The data needed to update a IndexerCheckpoint.
     */
    data: XOR<IndexerCheckpointUpdateInput, IndexerCheckpointUncheckedUpdateInput>
    /**
     * Choose, which IndexerCheckpoint to update.
     */
    where: IndexerCheckpointWhereUniqueInput
  }

  /**
   * IndexerCheckpoint updateMany
   */
  export type IndexerCheckpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndexerCheckpoints.
     */
    data: XOR<IndexerCheckpointUpdateManyMutationInput, IndexerCheckpointUncheckedUpdateManyInput>
    /**
     * Filter which IndexerCheckpoints to update
     */
    where?: IndexerCheckpointWhereInput
  }

  /**
   * IndexerCheckpoint upsert
   */
  export type IndexerCheckpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * The filter to search for the IndexerCheckpoint to update in case it exists.
     */
    where: IndexerCheckpointWhereUniqueInput
    /**
     * In case the IndexerCheckpoint found by the `where` argument doesn't exist, create a new IndexerCheckpoint with this data.
     */
    create: XOR<IndexerCheckpointCreateInput, IndexerCheckpointUncheckedCreateInput>
    /**
     * In case the IndexerCheckpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndexerCheckpointUpdateInput, IndexerCheckpointUncheckedUpdateInput>
  }

  /**
   * IndexerCheckpoint delete
   */
  export type IndexerCheckpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
    /**
     * Filter which IndexerCheckpoint to delete.
     */
    where: IndexerCheckpointWhereUniqueInput
  }

  /**
   * IndexerCheckpoint deleteMany
   */
  export type IndexerCheckpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndexerCheckpoints to delete
     */
    where?: IndexerCheckpointWhereInput
  }

  /**
   * IndexerCheckpoint without action
   */
  export type IndexerCheckpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndexerCheckpoint
     */
    select?: IndexerCheckpointSelect<ExtArgs> | null
  }


  /**
   * Model TokenRegistry
   */

  export type AggregateTokenRegistry = {
    _count: TokenRegistryCountAggregateOutputType | null
    _avg: TokenRegistryAvgAggregateOutputType | null
    _sum: TokenRegistrySumAggregateOutputType | null
    _min: TokenRegistryMinAggregateOutputType | null
    _max: TokenRegistryMaxAggregateOutputType | null
  }

  export type TokenRegistryAvgAggregateOutputType = {
    chainId: number | null
    decimals: number | null
  }

  export type TokenRegistrySumAggregateOutputType = {
    chainId: number | null
    decimals: number | null
  }

  export type TokenRegistryMinAggregateOutputType = {
    chainId: number | null
    tokenKey: string | null
    symbol: string | null
    decimals: number | null
    name: string | null
    enabled: boolean | null
  }

  export type TokenRegistryMaxAggregateOutputType = {
    chainId: number | null
    tokenKey: string | null
    symbol: string | null
    decimals: number | null
    name: string | null
    enabled: boolean | null
  }

  export type TokenRegistryCountAggregateOutputType = {
    chainId: number
    tokenKey: number
    symbol: number
    decimals: number
    name: number
    enabled: number
    _all: number
  }


  export type TokenRegistryAvgAggregateInputType = {
    chainId?: true
    decimals?: true
  }

  export type TokenRegistrySumAggregateInputType = {
    chainId?: true
    decimals?: true
  }

  export type TokenRegistryMinAggregateInputType = {
    chainId?: true
    tokenKey?: true
    symbol?: true
    decimals?: true
    name?: true
    enabled?: true
  }

  export type TokenRegistryMaxAggregateInputType = {
    chainId?: true
    tokenKey?: true
    symbol?: true
    decimals?: true
    name?: true
    enabled?: true
  }

  export type TokenRegistryCountAggregateInputType = {
    chainId?: true
    tokenKey?: true
    symbol?: true
    decimals?: true
    name?: true
    enabled?: true
    _all?: true
  }

  export type TokenRegistryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenRegistry to aggregate.
     */
    where?: TokenRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRegistries to fetch.
     */
    orderBy?: TokenRegistryOrderByWithRelationInput | TokenRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenRegistries
    **/
    _count?: true | TokenRegistryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenRegistryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenRegistrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenRegistryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenRegistryMaxAggregateInputType
  }

  export type GetTokenRegistryAggregateType<T extends TokenRegistryAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenRegistry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenRegistry[P]>
      : GetScalarType<T[P], AggregateTokenRegistry[P]>
  }




  export type TokenRegistryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenRegistryWhereInput
    orderBy?: TokenRegistryOrderByWithAggregationInput | TokenRegistryOrderByWithAggregationInput[]
    by: TokenRegistryScalarFieldEnum[] | TokenRegistryScalarFieldEnum
    having?: TokenRegistryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenRegistryCountAggregateInputType | true
    _avg?: TokenRegistryAvgAggregateInputType
    _sum?: TokenRegistrySumAggregateInputType
    _min?: TokenRegistryMinAggregateInputType
    _max?: TokenRegistryMaxAggregateInputType
  }

  export type TokenRegistryGroupByOutputType = {
    chainId: number
    tokenKey: string
    symbol: string
    decimals: number
    name: string
    enabled: boolean
    _count: TokenRegistryCountAggregateOutputType | null
    _avg: TokenRegistryAvgAggregateOutputType | null
    _sum: TokenRegistrySumAggregateOutputType | null
    _min: TokenRegistryMinAggregateOutputType | null
    _max: TokenRegistryMaxAggregateOutputType | null
  }

  type GetTokenRegistryGroupByPayload<T extends TokenRegistryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenRegistryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenRegistryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenRegistryGroupByOutputType[P]>
            : GetScalarType<T[P], TokenRegistryGroupByOutputType[P]>
        }
      >
    >


  export type TokenRegistrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chainId?: boolean
    tokenKey?: boolean
    symbol?: boolean
    decimals?: boolean
    name?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["tokenRegistry"]>

  export type TokenRegistrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chainId?: boolean
    tokenKey?: boolean
    symbol?: boolean
    decimals?: boolean
    name?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["tokenRegistry"]>

  export type TokenRegistrySelectScalar = {
    chainId?: boolean
    tokenKey?: boolean
    symbol?: boolean
    decimals?: boolean
    name?: boolean
    enabled?: boolean
  }


  export type $TokenRegistryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenRegistry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      chainId: number
      tokenKey: string
      symbol: string
      decimals: number
      name: string
      enabled: boolean
    }, ExtArgs["result"]["tokenRegistry"]>
    composites: {}
  }

  type TokenRegistryGetPayload<S extends boolean | null | undefined | TokenRegistryDefaultArgs> = $Result.GetResult<Prisma.$TokenRegistryPayload, S>

  type TokenRegistryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenRegistryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenRegistryCountAggregateInputType | true
    }

  export interface TokenRegistryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenRegistry'], meta: { name: 'TokenRegistry' } }
    /**
     * Find zero or one TokenRegistry that matches the filter.
     * @param {TokenRegistryFindUniqueArgs} args - Arguments to find a TokenRegistry
     * @example
     * // Get one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenRegistryFindUniqueArgs>(args: SelectSubset<T, TokenRegistryFindUniqueArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TokenRegistry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenRegistryFindUniqueOrThrowArgs} args - Arguments to find a TokenRegistry
     * @example
     * // Get one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenRegistryFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenRegistryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TokenRegistry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryFindFirstArgs} args - Arguments to find a TokenRegistry
     * @example
     * // Get one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenRegistryFindFirstArgs>(args?: SelectSubset<T, TokenRegistryFindFirstArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TokenRegistry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryFindFirstOrThrowArgs} args - Arguments to find a TokenRegistry
     * @example
     * // Get one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenRegistryFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenRegistryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TokenRegistries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenRegistries
     * const tokenRegistries = await prisma.tokenRegistry.findMany()
     * 
     * // Get first 10 TokenRegistries
     * const tokenRegistries = await prisma.tokenRegistry.findMany({ take: 10 })
     * 
     * // Only select the `chainId`
     * const tokenRegistryWithChainIdOnly = await prisma.tokenRegistry.findMany({ select: { chainId: true } })
     * 
     */
    findMany<T extends TokenRegistryFindManyArgs>(args?: SelectSubset<T, TokenRegistryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TokenRegistry.
     * @param {TokenRegistryCreateArgs} args - Arguments to create a TokenRegistry.
     * @example
     * // Create one TokenRegistry
     * const TokenRegistry = await prisma.tokenRegistry.create({
     *   data: {
     *     // ... data to create a TokenRegistry
     *   }
     * })
     * 
     */
    create<T extends TokenRegistryCreateArgs>(args: SelectSubset<T, TokenRegistryCreateArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TokenRegistries.
     * @param {TokenRegistryCreateManyArgs} args - Arguments to create many TokenRegistries.
     * @example
     * // Create many TokenRegistries
     * const tokenRegistry = await prisma.tokenRegistry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenRegistryCreateManyArgs>(args?: SelectSubset<T, TokenRegistryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenRegistries and returns the data saved in the database.
     * @param {TokenRegistryCreateManyAndReturnArgs} args - Arguments to create many TokenRegistries.
     * @example
     * // Create many TokenRegistries
     * const tokenRegistry = await prisma.tokenRegistry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenRegistries and only return the `chainId`
     * const tokenRegistryWithChainIdOnly = await prisma.tokenRegistry.createManyAndReturn({ 
     *   select: { chainId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenRegistryCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenRegistryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TokenRegistry.
     * @param {TokenRegistryDeleteArgs} args - Arguments to delete one TokenRegistry.
     * @example
     * // Delete one TokenRegistry
     * const TokenRegistry = await prisma.tokenRegistry.delete({
     *   where: {
     *     // ... filter to delete one TokenRegistry
     *   }
     * })
     * 
     */
    delete<T extends TokenRegistryDeleteArgs>(args: SelectSubset<T, TokenRegistryDeleteArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TokenRegistry.
     * @param {TokenRegistryUpdateArgs} args - Arguments to update one TokenRegistry.
     * @example
     * // Update one TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenRegistryUpdateArgs>(args: SelectSubset<T, TokenRegistryUpdateArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TokenRegistries.
     * @param {TokenRegistryDeleteManyArgs} args - Arguments to filter TokenRegistries to delete.
     * @example
     * // Delete a few TokenRegistries
     * const { count } = await prisma.tokenRegistry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenRegistryDeleteManyArgs>(args?: SelectSubset<T, TokenRegistryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenRegistries
     * const tokenRegistry = await prisma.tokenRegistry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenRegistryUpdateManyArgs>(args: SelectSubset<T, TokenRegistryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenRegistry.
     * @param {TokenRegistryUpsertArgs} args - Arguments to update or create a TokenRegistry.
     * @example
     * // Update or create a TokenRegistry
     * const tokenRegistry = await prisma.tokenRegistry.upsert({
     *   create: {
     *     // ... data to create a TokenRegistry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenRegistry we want to update
     *   }
     * })
     */
    upsert<T extends TokenRegistryUpsertArgs>(args: SelectSubset<T, TokenRegistryUpsertArgs<ExtArgs>>): Prisma__TokenRegistryClient<$Result.GetResult<Prisma.$TokenRegistryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TokenRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryCountArgs} args - Arguments to filter TokenRegistries to count.
     * @example
     * // Count the number of TokenRegistries
     * const count = await prisma.tokenRegistry.count({
     *   where: {
     *     // ... the filter for the TokenRegistries we want to count
     *   }
     * })
    **/
    count<T extends TokenRegistryCountArgs>(
      args?: Subset<T, TokenRegistryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenRegistryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenRegistryAggregateArgs>(args: Subset<T, TokenRegistryAggregateArgs>): Prisma.PrismaPromise<GetTokenRegistryAggregateType<T>>

    /**
     * Group by TokenRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRegistryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenRegistryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenRegistryGroupByArgs['orderBy'] }
        : { orderBy?: TokenRegistryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenRegistryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenRegistryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenRegistry model
   */
  readonly fields: TokenRegistryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenRegistry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenRegistryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenRegistry model
   */ 
  interface TokenRegistryFieldRefs {
    readonly chainId: FieldRef<"TokenRegistry", 'Int'>
    readonly tokenKey: FieldRef<"TokenRegistry", 'String'>
    readonly symbol: FieldRef<"TokenRegistry", 'String'>
    readonly decimals: FieldRef<"TokenRegistry", 'Int'>
    readonly name: FieldRef<"TokenRegistry", 'String'>
    readonly enabled: FieldRef<"TokenRegistry", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TokenRegistry findUnique
   */
  export type TokenRegistryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistry to fetch.
     */
    where: TokenRegistryWhereUniqueInput
  }

  /**
   * TokenRegistry findUniqueOrThrow
   */
  export type TokenRegistryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistry to fetch.
     */
    where: TokenRegistryWhereUniqueInput
  }

  /**
   * TokenRegistry findFirst
   */
  export type TokenRegistryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistry to fetch.
     */
    where?: TokenRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRegistries to fetch.
     */
    orderBy?: TokenRegistryOrderByWithRelationInput | TokenRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenRegistries.
     */
    cursor?: TokenRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenRegistries.
     */
    distinct?: TokenRegistryScalarFieldEnum | TokenRegistryScalarFieldEnum[]
  }

  /**
   * TokenRegistry findFirstOrThrow
   */
  export type TokenRegistryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistry to fetch.
     */
    where?: TokenRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRegistries to fetch.
     */
    orderBy?: TokenRegistryOrderByWithRelationInput | TokenRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenRegistries.
     */
    cursor?: TokenRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenRegistries.
     */
    distinct?: TokenRegistryScalarFieldEnum | TokenRegistryScalarFieldEnum[]
  }

  /**
   * TokenRegistry findMany
   */
  export type TokenRegistryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter, which TokenRegistries to fetch.
     */
    where?: TokenRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRegistries to fetch.
     */
    orderBy?: TokenRegistryOrderByWithRelationInput | TokenRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenRegistries.
     */
    cursor?: TokenRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRegistries.
     */
    skip?: number
    distinct?: TokenRegistryScalarFieldEnum | TokenRegistryScalarFieldEnum[]
  }

  /**
   * TokenRegistry create
   */
  export type TokenRegistryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * The data needed to create a TokenRegistry.
     */
    data: XOR<TokenRegistryCreateInput, TokenRegistryUncheckedCreateInput>
  }

  /**
   * TokenRegistry createMany
   */
  export type TokenRegistryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenRegistries.
     */
    data: TokenRegistryCreateManyInput | TokenRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenRegistry createManyAndReturn
   */
  export type TokenRegistryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TokenRegistries.
     */
    data: TokenRegistryCreateManyInput | TokenRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenRegistry update
   */
  export type TokenRegistryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * The data needed to update a TokenRegistry.
     */
    data: XOR<TokenRegistryUpdateInput, TokenRegistryUncheckedUpdateInput>
    /**
     * Choose, which TokenRegistry to update.
     */
    where: TokenRegistryWhereUniqueInput
  }

  /**
   * TokenRegistry updateMany
   */
  export type TokenRegistryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenRegistries.
     */
    data: XOR<TokenRegistryUpdateManyMutationInput, TokenRegistryUncheckedUpdateManyInput>
    /**
     * Filter which TokenRegistries to update
     */
    where?: TokenRegistryWhereInput
  }

  /**
   * TokenRegistry upsert
   */
  export type TokenRegistryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * The filter to search for the TokenRegistry to update in case it exists.
     */
    where: TokenRegistryWhereUniqueInput
    /**
     * In case the TokenRegistry found by the `where` argument doesn't exist, create a new TokenRegistry with this data.
     */
    create: XOR<TokenRegistryCreateInput, TokenRegistryUncheckedCreateInput>
    /**
     * In case the TokenRegistry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenRegistryUpdateInput, TokenRegistryUncheckedUpdateInput>
  }

  /**
   * TokenRegistry delete
   */
  export type TokenRegistryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
    /**
     * Filter which TokenRegistry to delete.
     */
    where: TokenRegistryWhereUniqueInput
  }

  /**
   * TokenRegistry deleteMany
   */
  export type TokenRegistryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenRegistries to delete
     */
    where?: TokenRegistryWhereInput
  }

  /**
   * TokenRegistry without action
   */
  export type TokenRegistryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRegistry
     */
    select?: TokenRegistrySelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorAddress: string | null
    action: string | null
    target: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorAddress: string | null
    action: string | null
    target: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorAddress: number
    action: number
    target: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorAddress?: true
    action?: true
    target?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorAddress?: true
    action?: true
    target?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorAddress?: true
    action?: true
    target?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorAddress: string | null
    action: string
    target: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorAddress?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorAddress?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorAddress?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorAddress: string | null
      action: string
      target: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorAddress: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly target: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model Nonce
   */

  export type AggregateNonce = {
    _count: NonceCountAggregateOutputType | null
    _avg: NonceAvgAggregateOutputType | null
    _sum: NonceSumAggregateOutputType | null
    _min: NonceMinAggregateOutputType | null
    _max: NonceMaxAggregateOutputType | null
  }

  export type NonceAvgAggregateOutputType = {
    chainId: number | null
  }

  export type NonceSumAggregateOutputType = {
    chainId: number | null
  }

  export type NonceMinAggregateOutputType = {
    id: string | null
    address: string | null
    value: string | null
    chainId: number | null
    domain: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type NonceMaxAggregateOutputType = {
    id: string | null
    address: string | null
    value: string | null
    chainId: number | null
    domain: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type NonceCountAggregateOutputType = {
    id: number
    address: number
    value: number
    chainId: number
    domain: number
    issuedAt: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type NonceAvgAggregateInputType = {
    chainId?: true
  }

  export type NonceSumAggregateInputType = {
    chainId?: true
  }

  export type NonceMinAggregateInputType = {
    id?: true
    address?: true
    value?: true
    chainId?: true
    domain?: true
    issuedAt?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type NonceMaxAggregateInputType = {
    id?: true
    address?: true
    value?: true
    chainId?: true
    domain?: true
    issuedAt?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type NonceCountAggregateInputType = {
    id?: true
    address?: true
    value?: true
    chainId?: true
    domain?: true
    issuedAt?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type NonceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nonce to aggregate.
     */
    where?: NonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nonces to fetch.
     */
    orderBy?: NonceOrderByWithRelationInput | NonceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nonces
    **/
    _count?: true | NonceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NonceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NonceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NonceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NonceMaxAggregateInputType
  }

  export type GetNonceAggregateType<T extends NonceAggregateArgs> = {
        [P in keyof T & keyof AggregateNonce]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNonce[P]>
      : GetScalarType<T[P], AggregateNonce[P]>
  }




  export type NonceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonceWhereInput
    orderBy?: NonceOrderByWithAggregationInput | NonceOrderByWithAggregationInput[]
    by: NonceScalarFieldEnum[] | NonceScalarFieldEnum
    having?: NonceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NonceCountAggregateInputType | true
    _avg?: NonceAvgAggregateInputType
    _sum?: NonceSumAggregateInputType
    _min?: NonceMinAggregateInputType
    _max?: NonceMaxAggregateInputType
  }

  export type NonceGroupByOutputType = {
    id: string
    address: string
    value: string
    chainId: number
    domain: string | null
    issuedAt: Date
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: NonceCountAggregateOutputType | null
    _avg: NonceAvgAggregateOutputType | null
    _sum: NonceSumAggregateOutputType | null
    _min: NonceMinAggregateOutputType | null
    _max: NonceMaxAggregateOutputType | null
  }

  type GetNonceGroupByPayload<T extends NonceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NonceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NonceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NonceGroupByOutputType[P]>
            : GetScalarType<T[P], NonceGroupByOutputType[P]>
        }
      >
    >


  export type NonceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    value?: boolean
    chainId?: boolean
    domain?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nonce"]>

  export type NonceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    value?: boolean
    chainId?: boolean
    domain?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nonce"]>

  export type NonceSelectScalar = {
    id?: boolean
    address?: boolean
    value?: boolean
    chainId?: boolean
    domain?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }


  export type $NoncePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nonce"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      /**
       * hashed nonce value
       */
      value: string
      chainId: number
      domain: string | null
      issuedAt: Date
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["nonce"]>
    composites: {}
  }

  type NonceGetPayload<S extends boolean | null | undefined | NonceDefaultArgs> = $Result.GetResult<Prisma.$NoncePayload, S>

  type NonceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NonceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NonceCountAggregateInputType | true
    }

  export interface NonceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nonce'], meta: { name: 'Nonce' } }
    /**
     * Find zero or one Nonce that matches the filter.
     * @param {NonceFindUniqueArgs} args - Arguments to find a Nonce
     * @example
     * // Get one Nonce
     * const nonce = await prisma.nonce.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NonceFindUniqueArgs>(args: SelectSubset<T, NonceFindUniqueArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Nonce that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NonceFindUniqueOrThrowArgs} args - Arguments to find a Nonce
     * @example
     * // Get one Nonce
     * const nonce = await prisma.nonce.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NonceFindUniqueOrThrowArgs>(args: SelectSubset<T, NonceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Nonce that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceFindFirstArgs} args - Arguments to find a Nonce
     * @example
     * // Get one Nonce
     * const nonce = await prisma.nonce.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NonceFindFirstArgs>(args?: SelectSubset<T, NonceFindFirstArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Nonce that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceFindFirstOrThrowArgs} args - Arguments to find a Nonce
     * @example
     * // Get one Nonce
     * const nonce = await prisma.nonce.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NonceFindFirstOrThrowArgs>(args?: SelectSubset<T, NonceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Nonces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nonces
     * const nonces = await prisma.nonce.findMany()
     * 
     * // Get first 10 Nonces
     * const nonces = await prisma.nonce.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nonceWithIdOnly = await prisma.nonce.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NonceFindManyArgs>(args?: SelectSubset<T, NonceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Nonce.
     * @param {NonceCreateArgs} args - Arguments to create a Nonce.
     * @example
     * // Create one Nonce
     * const Nonce = await prisma.nonce.create({
     *   data: {
     *     // ... data to create a Nonce
     *   }
     * })
     * 
     */
    create<T extends NonceCreateArgs>(args: SelectSubset<T, NonceCreateArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Nonces.
     * @param {NonceCreateManyArgs} args - Arguments to create many Nonces.
     * @example
     * // Create many Nonces
     * const nonce = await prisma.nonce.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NonceCreateManyArgs>(args?: SelectSubset<T, NonceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nonces and returns the data saved in the database.
     * @param {NonceCreateManyAndReturnArgs} args - Arguments to create many Nonces.
     * @example
     * // Create many Nonces
     * const nonce = await prisma.nonce.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nonces and only return the `id`
     * const nonceWithIdOnly = await prisma.nonce.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NonceCreateManyAndReturnArgs>(args?: SelectSubset<T, NonceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Nonce.
     * @param {NonceDeleteArgs} args - Arguments to delete one Nonce.
     * @example
     * // Delete one Nonce
     * const Nonce = await prisma.nonce.delete({
     *   where: {
     *     // ... filter to delete one Nonce
     *   }
     * })
     * 
     */
    delete<T extends NonceDeleteArgs>(args: SelectSubset<T, NonceDeleteArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Nonce.
     * @param {NonceUpdateArgs} args - Arguments to update one Nonce.
     * @example
     * // Update one Nonce
     * const nonce = await prisma.nonce.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NonceUpdateArgs>(args: SelectSubset<T, NonceUpdateArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Nonces.
     * @param {NonceDeleteManyArgs} args - Arguments to filter Nonces to delete.
     * @example
     * // Delete a few Nonces
     * const { count } = await prisma.nonce.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NonceDeleteManyArgs>(args?: SelectSubset<T, NonceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nonces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nonces
     * const nonce = await prisma.nonce.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NonceUpdateManyArgs>(args: SelectSubset<T, NonceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Nonce.
     * @param {NonceUpsertArgs} args - Arguments to update or create a Nonce.
     * @example
     * // Update or create a Nonce
     * const nonce = await prisma.nonce.upsert({
     *   create: {
     *     // ... data to create a Nonce
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nonce we want to update
     *   }
     * })
     */
    upsert<T extends NonceUpsertArgs>(args: SelectSubset<T, NonceUpsertArgs<ExtArgs>>): Prisma__NonceClient<$Result.GetResult<Prisma.$NoncePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Nonces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceCountArgs} args - Arguments to filter Nonces to count.
     * @example
     * // Count the number of Nonces
     * const count = await prisma.nonce.count({
     *   where: {
     *     // ... the filter for the Nonces we want to count
     *   }
     * })
    **/
    count<T extends NonceCountArgs>(
      args?: Subset<T, NonceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NonceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nonce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NonceAggregateArgs>(args: Subset<T, NonceAggregateArgs>): Prisma.PrismaPromise<GetNonceAggregateType<T>>

    /**
     * Group by Nonce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NonceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NonceGroupByArgs['orderBy'] }
        : { orderBy?: NonceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NonceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNonceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nonce model
   */
  readonly fields: NonceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nonce.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NonceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nonce model
   */ 
  interface NonceFieldRefs {
    readonly id: FieldRef<"Nonce", 'String'>
    readonly address: FieldRef<"Nonce", 'String'>
    readonly value: FieldRef<"Nonce", 'String'>
    readonly chainId: FieldRef<"Nonce", 'Int'>
    readonly domain: FieldRef<"Nonce", 'String'>
    readonly issuedAt: FieldRef<"Nonce", 'DateTime'>
    readonly expiresAt: FieldRef<"Nonce", 'DateTime'>
    readonly used: FieldRef<"Nonce", 'Boolean'>
    readonly createdAt: FieldRef<"Nonce", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Nonce findUnique
   */
  export type NonceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonce to fetch.
     */
    where: NonceWhereUniqueInput
  }

  /**
   * Nonce findUniqueOrThrow
   */
  export type NonceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonce to fetch.
     */
    where: NonceWhereUniqueInput
  }

  /**
   * Nonce findFirst
   */
  export type NonceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonce to fetch.
     */
    where?: NonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nonces to fetch.
     */
    orderBy?: NonceOrderByWithRelationInput | NonceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nonces.
     */
    cursor?: NonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nonces.
     */
    distinct?: NonceScalarFieldEnum | NonceScalarFieldEnum[]
  }

  /**
   * Nonce findFirstOrThrow
   */
  export type NonceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonce to fetch.
     */
    where?: NonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nonces to fetch.
     */
    orderBy?: NonceOrderByWithRelationInput | NonceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nonces.
     */
    cursor?: NonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nonces.
     */
    distinct?: NonceScalarFieldEnum | NonceScalarFieldEnum[]
  }

  /**
   * Nonce findMany
   */
  export type NonceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter, which Nonces to fetch.
     */
    where?: NonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nonces to fetch.
     */
    orderBy?: NonceOrderByWithRelationInput | NonceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nonces.
     */
    cursor?: NonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nonces.
     */
    skip?: number
    distinct?: NonceScalarFieldEnum | NonceScalarFieldEnum[]
  }

  /**
   * Nonce create
   */
  export type NonceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * The data needed to create a Nonce.
     */
    data: XOR<NonceCreateInput, NonceUncheckedCreateInput>
  }

  /**
   * Nonce createMany
   */
  export type NonceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nonces.
     */
    data: NonceCreateManyInput | NonceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nonce createManyAndReturn
   */
  export type NonceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Nonces.
     */
    data: NonceCreateManyInput | NonceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nonce update
   */
  export type NonceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * The data needed to update a Nonce.
     */
    data: XOR<NonceUpdateInput, NonceUncheckedUpdateInput>
    /**
     * Choose, which Nonce to update.
     */
    where: NonceWhereUniqueInput
  }

  /**
   * Nonce updateMany
   */
  export type NonceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nonces.
     */
    data: XOR<NonceUpdateManyMutationInput, NonceUncheckedUpdateManyInput>
    /**
     * Filter which Nonces to update
     */
    where?: NonceWhereInput
  }

  /**
   * Nonce upsert
   */
  export type NonceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * The filter to search for the Nonce to update in case it exists.
     */
    where: NonceWhereUniqueInput
    /**
     * In case the Nonce found by the `where` argument doesn't exist, create a new Nonce with this data.
     */
    create: XOR<NonceCreateInput, NonceUncheckedCreateInput>
    /**
     * In case the Nonce was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NonceUpdateInput, NonceUncheckedUpdateInput>
  }

  /**
   * Nonce delete
   */
  export type NonceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
    /**
     * Filter which Nonce to delete.
     */
    where: NonceWhereUniqueInput
  }

  /**
   * Nonce deleteMany
   */
  export type NonceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nonces to delete
     */
    where?: NonceWhereInput
  }

  /**
   * Nonce without action
   */
  export type NonceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nonce
     */
    select?: NonceSelect<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    address: string | null
    webhookUrl: string | null
    email: string | null
    telegramId: string | null
    smsNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    address: string | null
    webhookUrl: string | null
    email: string | null
    telegramId: string | null
    smsNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    address: number
    webhookUrl: number
    email: number
    telegramId: number
    smsNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    address?: true
    webhookUrl?: true
    email?: true
    telegramId?: true
    smsNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    address?: true
    webhookUrl?: true
    email?: true
    telegramId?: true
    smsNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    address?: true
    webhookUrl?: true
    email?: true
    telegramId?: true
    smsNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    address: string
    webhookUrl: string | null
    email: string | null
    telegramId: string | null
    smsNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    webhookUrl?: boolean
    email?: boolean
    telegramId?: boolean
    smsNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    webhookUrl?: boolean
    email?: boolean
    telegramId?: boolean
    smsNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    address?: boolean
    webhookUrl?: boolean
    email?: boolean
    telegramId?: boolean
    smsNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      address: string
      webhookUrl: string | null
      email: string | null
      telegramId: string | null
      smsNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `address`
     * const notificationPreferenceWithAddressOnly = await prisma.notificationPreference.findMany({ select: { address: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `address`
     * const notificationPreferenceWithAddressOnly = await prisma.notificationPreference.createManyAndReturn({ 
     *   select: { address: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */ 
  interface NotificationPreferenceFieldRefs {
    readonly address: FieldRef<"NotificationPreference", 'String'>
    readonly webhookUrl: FieldRef<"NotificationPreference", 'String'>
    readonly email: FieldRef<"NotificationPreference", 'String'>
    readonly telegramId: FieldRef<"NotificationPreference", 'String'>
    readonly smsNumber: FieldRef<"NotificationPreference", 'String'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    address: 'address',
    displayName: 'displayName',
    createdAt: 'createdAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    address: 'address',
    role: 'role',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const EscrowScalarFieldEnum: {
    escrowId: 'escrowId',
    chainId: 'chainId',
    contractAddress: 'contractAddress',
    tokenKey: 'tokenKey',
    amount: 'amount',
    feeAmount: 'feeAmount',
    sellerBond: 'sellerBond',
    buyerBond: 'buyerBond',
    state: 'state',
    seller: 'seller',
    buyer: 'buyer',
    createdAtBlock: 'createdAtBlock',
    updatedAtBlock: 'updatedAtBlock',
    txHashCreate: 'txHashCreate',
    txHashLast: 'txHashLast',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EscrowScalarFieldEnum = (typeof EscrowScalarFieldEnum)[keyof typeof EscrowScalarFieldEnum]


  export const EscrowTimelineScalarFieldEnum: {
    id: 'id',
    escrowId: 'escrowId',
    chainId: 'chainId',
    eventName: 'eventName',
    stateAfter: 'stateAfter',
    txHash: 'txHash',
    blockNumber: 'blockNumber',
    logIndex: 'logIndex',
    timestamp: 'timestamp',
    payload: 'payload'
  };

  export type EscrowTimelineScalarFieldEnum = (typeof EscrowTimelineScalarFieldEnum)[keyof typeof EscrowTimelineScalarFieldEnum]


  export const EscrowMessageScalarFieldEnum: {
    id: 'id',
    escrowId: 'escrowId',
    sender: 'sender',
    text: 'text',
    attachment: 'attachment',
    hash: 'hash',
    createdAt: 'createdAt',
    editedAt: 'editedAt'
  };

  export type EscrowMessageScalarFieldEnum = (typeof EscrowMessageScalarFieldEnum)[keyof typeof EscrowMessageScalarFieldEnum]


  export const EscrowPaymentInstructionScalarFieldEnum: {
    escrowId: 'escrowId',
    seller: 'seller',
    content: 'content',
    updatedAt: 'updatedAt'
  };

  export type EscrowPaymentInstructionScalarFieldEnum = (typeof EscrowPaymentInstructionScalarFieldEnum)[keyof typeof EscrowPaymentInstructionScalarFieldEnum]


  export const EscrowFiatStatusScalarFieldEnum: {
    id: 'id',
    escrowId: 'escrowId',
    actor: 'actor',
    status: 'status',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type EscrowFiatStatusScalarFieldEnum = (typeof EscrowFiatStatusScalarFieldEnum)[keyof typeof EscrowFiatStatusScalarFieldEnum]


  export const EvidenceItemScalarFieldEnum: {
    id: 'id',
    escrowId: 'escrowId',
    uploader: 'uploader',
    uri: 'uri',
    sha256: 'sha256',
    mime: 'mime',
    size: 'size',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type EvidenceItemScalarFieldEnum = (typeof EvidenceItemScalarFieldEnum)[keyof typeof EvidenceItemScalarFieldEnum]


  export const DisputeScalarFieldEnum: {
    escrowId: 'escrowId',
    openedBy: 'openedBy',
    reasonCode: 'reasonCode',
    summary: 'summary',
    status: 'status',
    arbitratorAssigned: 'arbitratorAssigned',
    outcome: 'outcome',
    ref: 'ref',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisputeScalarFieldEnum = (typeof DisputeScalarFieldEnum)[keyof typeof DisputeScalarFieldEnum]


  export const IndexerCheckpointScalarFieldEnum: {
    chainId: 'chainId',
    contractAddress: 'contractAddress',
    lastSyncedBlock: 'lastSyncedBlock',
    updatedAt: 'updatedAt'
  };

  export type IndexerCheckpointScalarFieldEnum = (typeof IndexerCheckpointScalarFieldEnum)[keyof typeof IndexerCheckpointScalarFieldEnum]


  export const TokenRegistryScalarFieldEnum: {
    chainId: 'chainId',
    tokenKey: 'tokenKey',
    symbol: 'symbol',
    decimals: 'decimals',
    name: 'name',
    enabled: 'enabled'
  };

  export type TokenRegistryScalarFieldEnum = (typeof TokenRegistryScalarFieldEnum)[keyof typeof TokenRegistryScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorAddress: 'actorAddress',
    action: 'action',
    target: 'target',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NonceScalarFieldEnum: {
    id: 'id',
    address: 'address',
    value: 'value',
    chainId: 'chainId',
    domain: 'domain',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type NonceScalarFieldEnum = (typeof NonceScalarFieldEnum)[keyof typeof NonceScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    address: 'address',
    webhookUrl: 'webhookUrl',
    email: 'email',
    telegramId: 'telegramId',
    smsNumber: 'smsNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    address?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    roles?: RoleListRelationFilter
    notificationPreference?: XOR<NotificationPreferenceNullableRelationFilter, NotificationPreferenceWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    address?: SortOrder
    displayName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    roles?: RoleOrderByRelationAggregateInput
    notificationPreference?: NotificationPreferenceOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    address?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    displayName?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    roles?: RoleListRelationFilter
    notificationPreference?: XOR<NotificationPreferenceNullableRelationFilter, NotificationPreferenceWhereInput> | null
  }, "address">

  export type UserOrderByWithAggregationInput = {
    address?: SortOrder
    displayName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    address?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    address?: StringFilter<"Role"> | string
    role?: StringFilter<"Role"> | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address_role?: RoleAddressRoleCompoundUniqueInput
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    address?: StringFilter<"Role"> | string
    role?: StringFilter<"Role"> | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "address_role">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    address?: StringWithAggregatesFilter<"Role"> | string
    role?: StringWithAggregatesFilter<"Role"> | string
    createdBy?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type EscrowWhereInput = {
    AND?: EscrowWhereInput | EscrowWhereInput[]
    OR?: EscrowWhereInput[]
    NOT?: EscrowWhereInput | EscrowWhereInput[]
    escrowId?: BytesFilter<"Escrow"> | Buffer
    chainId?: IntFilter<"Escrow"> | number
    contractAddress?: StringFilter<"Escrow"> | string
    tokenKey?: StringFilter<"Escrow"> | string
    amount?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    state?: StringFilter<"Escrow"> | string
    seller?: StringFilter<"Escrow"> | string
    buyer?: StringNullableFilter<"Escrow"> | string | null
    createdAtBlock?: BigIntFilter<"Escrow"> | bigint | number
    updatedAtBlock?: BigIntFilter<"Escrow"> | bigint | number
    txHashCreate?: StringNullableFilter<"Escrow"> | string | null
    txHashLast?: StringNullableFilter<"Escrow"> | string | null
    createdAt?: DateTimeFilter<"Escrow"> | Date | string
    updatedAt?: DateTimeFilter<"Escrow"> | Date | string
    timeline?: EscrowTimelineListRelationFilter
    messages?: EscrowMessageListRelationFilter
    paymentInstruction?: XOR<EscrowPaymentInstructionNullableRelationFilter, EscrowPaymentInstructionWhereInput> | null
    fiatStatuses?: EscrowFiatStatusListRelationFilter
    evidence?: EvidenceItemListRelationFilter
    dispute?: XOR<DisputeNullableRelationFilter, DisputeWhereInput> | null
  }

  export type EscrowOrderByWithRelationInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrderInput | SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrderInput | SortOrder
    txHashLast?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeline?: EscrowTimelineOrderByRelationAggregateInput
    messages?: EscrowMessageOrderByRelationAggregateInput
    paymentInstruction?: EscrowPaymentInstructionOrderByWithRelationInput
    fiatStatuses?: EscrowFiatStatusOrderByRelationAggregateInput
    evidence?: EvidenceItemOrderByRelationAggregateInput
    dispute?: DisputeOrderByWithRelationInput
  }

  export type EscrowWhereUniqueInput = Prisma.AtLeast<{
    escrowId?: Buffer
    AND?: EscrowWhereInput | EscrowWhereInput[]
    OR?: EscrowWhereInput[]
    NOT?: EscrowWhereInput | EscrowWhereInput[]
    chainId?: IntFilter<"Escrow"> | number
    contractAddress?: StringFilter<"Escrow"> | string
    tokenKey?: StringFilter<"Escrow"> | string
    amount?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    state?: StringFilter<"Escrow"> | string
    seller?: StringFilter<"Escrow"> | string
    buyer?: StringNullableFilter<"Escrow"> | string | null
    createdAtBlock?: BigIntFilter<"Escrow"> | bigint | number
    updatedAtBlock?: BigIntFilter<"Escrow"> | bigint | number
    txHashCreate?: StringNullableFilter<"Escrow"> | string | null
    txHashLast?: StringNullableFilter<"Escrow"> | string | null
    createdAt?: DateTimeFilter<"Escrow"> | Date | string
    updatedAt?: DateTimeFilter<"Escrow"> | Date | string
    timeline?: EscrowTimelineListRelationFilter
    messages?: EscrowMessageListRelationFilter
    paymentInstruction?: XOR<EscrowPaymentInstructionNullableRelationFilter, EscrowPaymentInstructionWhereInput> | null
    fiatStatuses?: EscrowFiatStatusListRelationFilter
    evidence?: EvidenceItemListRelationFilter
    dispute?: XOR<DisputeNullableRelationFilter, DisputeWhereInput> | null
  }, "escrowId">

  export type EscrowOrderByWithAggregationInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrderInput | SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrderInput | SortOrder
    txHashLast?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EscrowCountOrderByAggregateInput
    _avg?: EscrowAvgOrderByAggregateInput
    _max?: EscrowMaxOrderByAggregateInput
    _min?: EscrowMinOrderByAggregateInput
    _sum?: EscrowSumOrderByAggregateInput
  }

  export type EscrowScalarWhereWithAggregatesInput = {
    AND?: EscrowScalarWhereWithAggregatesInput | EscrowScalarWhereWithAggregatesInput[]
    OR?: EscrowScalarWhereWithAggregatesInput[]
    NOT?: EscrowScalarWhereWithAggregatesInput | EscrowScalarWhereWithAggregatesInput[]
    escrowId?: BytesWithAggregatesFilter<"Escrow"> | Buffer
    chainId?: IntWithAggregatesFilter<"Escrow"> | number
    contractAddress?: StringWithAggregatesFilter<"Escrow"> | string
    tokenKey?: StringWithAggregatesFilter<"Escrow"> | string
    amount?: DecimalWithAggregatesFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalWithAggregatesFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalWithAggregatesFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalWithAggregatesFilter<"Escrow"> | Decimal | DecimalJsLike | number | string
    state?: StringWithAggregatesFilter<"Escrow"> | string
    seller?: StringWithAggregatesFilter<"Escrow"> | string
    buyer?: StringNullableWithAggregatesFilter<"Escrow"> | string | null
    createdAtBlock?: BigIntWithAggregatesFilter<"Escrow"> | bigint | number
    updatedAtBlock?: BigIntWithAggregatesFilter<"Escrow"> | bigint | number
    txHashCreate?: StringNullableWithAggregatesFilter<"Escrow"> | string | null
    txHashLast?: StringNullableWithAggregatesFilter<"Escrow"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Escrow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Escrow"> | Date | string
  }

  export type EscrowTimelineWhereInput = {
    AND?: EscrowTimelineWhereInput | EscrowTimelineWhereInput[]
    OR?: EscrowTimelineWhereInput[]
    NOT?: EscrowTimelineWhereInput | EscrowTimelineWhereInput[]
    id?: BigIntFilter<"EscrowTimeline"> | bigint | number
    escrowId?: BytesFilter<"EscrowTimeline"> | Buffer
    chainId?: IntFilter<"EscrowTimeline"> | number
    eventName?: StringFilter<"EscrowTimeline"> | string
    stateAfter?: StringFilter<"EscrowTimeline"> | string
    txHash?: StringFilter<"EscrowTimeline"> | string
    blockNumber?: BigIntFilter<"EscrowTimeline"> | bigint | number
    logIndex?: IntFilter<"EscrowTimeline"> | number
    timestamp?: DateTimeFilter<"EscrowTimeline"> | Date | string
    payload?: JsonFilter<"EscrowTimeline">
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }

  export type EscrowTimelineOrderByWithRelationInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
    payload?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EscrowTimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    escrowId_blockNumber_logIndex?: EscrowTimelineEscrowIdBlockNumberLogIndexCompoundUniqueInput
    AND?: EscrowTimelineWhereInput | EscrowTimelineWhereInput[]
    OR?: EscrowTimelineWhereInput[]
    NOT?: EscrowTimelineWhereInput | EscrowTimelineWhereInput[]
    escrowId?: BytesFilter<"EscrowTimeline"> | Buffer
    chainId?: IntFilter<"EscrowTimeline"> | number
    eventName?: StringFilter<"EscrowTimeline"> | string
    stateAfter?: StringFilter<"EscrowTimeline"> | string
    txHash?: StringFilter<"EscrowTimeline"> | string
    blockNumber?: BigIntFilter<"EscrowTimeline"> | bigint | number
    logIndex?: IntFilter<"EscrowTimeline"> | number
    timestamp?: DateTimeFilter<"EscrowTimeline"> | Date | string
    payload?: JsonFilter<"EscrowTimeline">
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }, "id" | "escrowId_blockNumber_logIndex">

  export type EscrowTimelineOrderByWithAggregationInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
    payload?: SortOrder
    _count?: EscrowTimelineCountOrderByAggregateInput
    _avg?: EscrowTimelineAvgOrderByAggregateInput
    _max?: EscrowTimelineMaxOrderByAggregateInput
    _min?: EscrowTimelineMinOrderByAggregateInput
    _sum?: EscrowTimelineSumOrderByAggregateInput
  }

  export type EscrowTimelineScalarWhereWithAggregatesInput = {
    AND?: EscrowTimelineScalarWhereWithAggregatesInput | EscrowTimelineScalarWhereWithAggregatesInput[]
    OR?: EscrowTimelineScalarWhereWithAggregatesInput[]
    NOT?: EscrowTimelineScalarWhereWithAggregatesInput | EscrowTimelineScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"EscrowTimeline"> | bigint | number
    escrowId?: BytesWithAggregatesFilter<"EscrowTimeline"> | Buffer
    chainId?: IntWithAggregatesFilter<"EscrowTimeline"> | number
    eventName?: StringWithAggregatesFilter<"EscrowTimeline"> | string
    stateAfter?: StringWithAggregatesFilter<"EscrowTimeline"> | string
    txHash?: StringWithAggregatesFilter<"EscrowTimeline"> | string
    blockNumber?: BigIntWithAggregatesFilter<"EscrowTimeline"> | bigint | number
    logIndex?: IntWithAggregatesFilter<"EscrowTimeline"> | number
    timestamp?: DateTimeWithAggregatesFilter<"EscrowTimeline"> | Date | string
    payload?: JsonWithAggregatesFilter<"EscrowTimeline">
  }

  export type EscrowMessageWhereInput = {
    AND?: EscrowMessageWhereInput | EscrowMessageWhereInput[]
    OR?: EscrowMessageWhereInput[]
    NOT?: EscrowMessageWhereInput | EscrowMessageWhereInput[]
    id?: StringFilter<"EscrowMessage"> | string
    escrowId?: BytesNullableFilter<"EscrowMessage"> | Buffer | null
    sender?: StringFilter<"EscrowMessage"> | string
    text?: StringFilter<"EscrowMessage"> | string
    attachment?: StringNullableFilter<"EscrowMessage"> | string | null
    hash?: StringNullableFilter<"EscrowMessage"> | string | null
    createdAt?: DateTimeFilter<"EscrowMessage"> | Date | string
    editedAt?: DateTimeNullableFilter<"EscrowMessage"> | Date | string | null
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }

  export type EscrowMessageOrderByWithRelationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EscrowMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EscrowMessageWhereInput | EscrowMessageWhereInput[]
    OR?: EscrowMessageWhereInput[]
    NOT?: EscrowMessageWhereInput | EscrowMessageWhereInput[]
    escrowId?: BytesNullableFilter<"EscrowMessage"> | Buffer | null
    sender?: StringFilter<"EscrowMessage"> | string
    text?: StringFilter<"EscrowMessage"> | string
    attachment?: StringNullableFilter<"EscrowMessage"> | string | null
    hash?: StringNullableFilter<"EscrowMessage"> | string | null
    createdAt?: DateTimeFilter<"EscrowMessage"> | Date | string
    editedAt?: DateTimeNullableFilter<"EscrowMessage"> | Date | string | null
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }, "id">

  export type EscrowMessageOrderByWithAggregationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    _count?: EscrowMessageCountOrderByAggregateInput
    _max?: EscrowMessageMaxOrderByAggregateInput
    _min?: EscrowMessageMinOrderByAggregateInput
  }

  export type EscrowMessageScalarWhereWithAggregatesInput = {
    AND?: EscrowMessageScalarWhereWithAggregatesInput | EscrowMessageScalarWhereWithAggregatesInput[]
    OR?: EscrowMessageScalarWhereWithAggregatesInput[]
    NOT?: EscrowMessageScalarWhereWithAggregatesInput | EscrowMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EscrowMessage"> | string
    escrowId?: BytesNullableWithAggregatesFilter<"EscrowMessage"> | Buffer | null
    sender?: StringWithAggregatesFilter<"EscrowMessage"> | string
    text?: StringWithAggregatesFilter<"EscrowMessage"> | string
    attachment?: StringNullableWithAggregatesFilter<"EscrowMessage"> | string | null
    hash?: StringNullableWithAggregatesFilter<"EscrowMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EscrowMessage"> | Date | string
    editedAt?: DateTimeNullableWithAggregatesFilter<"EscrowMessage"> | Date | string | null
  }

  export type EscrowPaymentInstructionWhereInput = {
    AND?: EscrowPaymentInstructionWhereInput | EscrowPaymentInstructionWhereInput[]
    OR?: EscrowPaymentInstructionWhereInput[]
    NOT?: EscrowPaymentInstructionWhereInput | EscrowPaymentInstructionWhereInput[]
    escrowId?: BytesFilter<"EscrowPaymentInstruction"> | Buffer
    seller?: StringFilter<"EscrowPaymentInstruction"> | string
    content?: JsonNullableFilter<"EscrowPaymentInstruction">
    updatedAt?: DateTimeFilter<"EscrowPaymentInstruction"> | Date | string
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }

  export type EscrowPaymentInstructionOrderByWithRelationInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    content?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EscrowPaymentInstructionWhereUniqueInput = Prisma.AtLeast<{
    escrowId?: Buffer
    AND?: EscrowPaymentInstructionWhereInput | EscrowPaymentInstructionWhereInput[]
    OR?: EscrowPaymentInstructionWhereInput[]
    NOT?: EscrowPaymentInstructionWhereInput | EscrowPaymentInstructionWhereInput[]
    seller?: StringFilter<"EscrowPaymentInstruction"> | string
    content?: JsonNullableFilter<"EscrowPaymentInstruction">
    updatedAt?: DateTimeFilter<"EscrowPaymentInstruction"> | Date | string
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }, "escrowId">

  export type EscrowPaymentInstructionOrderByWithAggregationInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    content?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: EscrowPaymentInstructionCountOrderByAggregateInput
    _max?: EscrowPaymentInstructionMaxOrderByAggregateInput
    _min?: EscrowPaymentInstructionMinOrderByAggregateInput
  }

  export type EscrowPaymentInstructionScalarWhereWithAggregatesInput = {
    AND?: EscrowPaymentInstructionScalarWhereWithAggregatesInput | EscrowPaymentInstructionScalarWhereWithAggregatesInput[]
    OR?: EscrowPaymentInstructionScalarWhereWithAggregatesInput[]
    NOT?: EscrowPaymentInstructionScalarWhereWithAggregatesInput | EscrowPaymentInstructionScalarWhereWithAggregatesInput[]
    escrowId?: BytesWithAggregatesFilter<"EscrowPaymentInstruction"> | Buffer
    seller?: StringWithAggregatesFilter<"EscrowPaymentInstruction"> | string
    content?: JsonNullableWithAggregatesFilter<"EscrowPaymentInstruction">
    updatedAt?: DateTimeWithAggregatesFilter<"EscrowPaymentInstruction"> | Date | string
  }

  export type EscrowFiatStatusWhereInput = {
    AND?: EscrowFiatStatusWhereInput | EscrowFiatStatusWhereInput[]
    OR?: EscrowFiatStatusWhereInput[]
    NOT?: EscrowFiatStatusWhereInput | EscrowFiatStatusWhereInput[]
    id?: BigIntFilter<"EscrowFiatStatus"> | bigint | number
    escrowId?: BytesNullableFilter<"EscrowFiatStatus"> | Buffer | null
    actor?: StringFilter<"EscrowFiatStatus"> | string
    status?: StringFilter<"EscrowFiatStatus"> | string
    note?: StringNullableFilter<"EscrowFiatStatus"> | string | null
    createdAt?: DateTimeFilter<"EscrowFiatStatus"> | Date | string
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }

  export type EscrowFiatStatusOrderByWithRelationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EscrowFiatStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: EscrowFiatStatusWhereInput | EscrowFiatStatusWhereInput[]
    OR?: EscrowFiatStatusWhereInput[]
    NOT?: EscrowFiatStatusWhereInput | EscrowFiatStatusWhereInput[]
    escrowId?: BytesNullableFilter<"EscrowFiatStatus"> | Buffer | null
    actor?: StringFilter<"EscrowFiatStatus"> | string
    status?: StringFilter<"EscrowFiatStatus"> | string
    note?: StringNullableFilter<"EscrowFiatStatus"> | string | null
    createdAt?: DateTimeFilter<"EscrowFiatStatus"> | Date | string
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }, "id">

  export type EscrowFiatStatusOrderByWithAggregationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EscrowFiatStatusCountOrderByAggregateInput
    _avg?: EscrowFiatStatusAvgOrderByAggregateInput
    _max?: EscrowFiatStatusMaxOrderByAggregateInput
    _min?: EscrowFiatStatusMinOrderByAggregateInput
    _sum?: EscrowFiatStatusSumOrderByAggregateInput
  }

  export type EscrowFiatStatusScalarWhereWithAggregatesInput = {
    AND?: EscrowFiatStatusScalarWhereWithAggregatesInput | EscrowFiatStatusScalarWhereWithAggregatesInput[]
    OR?: EscrowFiatStatusScalarWhereWithAggregatesInput[]
    NOT?: EscrowFiatStatusScalarWhereWithAggregatesInput | EscrowFiatStatusScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"EscrowFiatStatus"> | bigint | number
    escrowId?: BytesNullableWithAggregatesFilter<"EscrowFiatStatus"> | Buffer | null
    actor?: StringWithAggregatesFilter<"EscrowFiatStatus"> | string
    status?: StringWithAggregatesFilter<"EscrowFiatStatus"> | string
    note?: StringNullableWithAggregatesFilter<"EscrowFiatStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EscrowFiatStatus"> | Date | string
  }

  export type EvidenceItemWhereInput = {
    AND?: EvidenceItemWhereInput | EvidenceItemWhereInput[]
    OR?: EvidenceItemWhereInput[]
    NOT?: EvidenceItemWhereInput | EvidenceItemWhereInput[]
    id?: StringFilter<"EvidenceItem"> | string
    escrowId?: BytesNullableFilter<"EvidenceItem"> | Buffer | null
    uploader?: StringFilter<"EvidenceItem"> | string
    uri?: StringFilter<"EvidenceItem"> | string
    sha256?: StringFilter<"EvidenceItem"> | string
    mime?: StringFilter<"EvidenceItem"> | string
    size?: BigIntFilter<"EvidenceItem"> | bigint | number
    description?: StringNullableFilter<"EvidenceItem"> | string | null
    createdAt?: DateTimeFilter<"EvidenceItem"> | Date | string
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }

  export type EvidenceItemOrderByWithRelationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type EvidenceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvidenceItemWhereInput | EvidenceItemWhereInput[]
    OR?: EvidenceItemWhereInput[]
    NOT?: EvidenceItemWhereInput | EvidenceItemWhereInput[]
    escrowId?: BytesNullableFilter<"EvidenceItem"> | Buffer | null
    uploader?: StringFilter<"EvidenceItem"> | string
    uri?: StringFilter<"EvidenceItem"> | string
    sha256?: StringFilter<"EvidenceItem"> | string
    mime?: StringFilter<"EvidenceItem"> | string
    size?: BigIntFilter<"EvidenceItem"> | bigint | number
    description?: StringNullableFilter<"EvidenceItem"> | string | null
    createdAt?: DateTimeFilter<"EvidenceItem"> | Date | string
    Escrow?: XOR<EscrowNullableRelationFilter, EscrowWhereInput> | null
  }, "id">

  export type EvidenceItemOrderByWithAggregationInput = {
    id?: SortOrder
    escrowId?: SortOrderInput | SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EvidenceItemCountOrderByAggregateInput
    _avg?: EvidenceItemAvgOrderByAggregateInput
    _max?: EvidenceItemMaxOrderByAggregateInput
    _min?: EvidenceItemMinOrderByAggregateInput
    _sum?: EvidenceItemSumOrderByAggregateInput
  }

  export type EvidenceItemScalarWhereWithAggregatesInput = {
    AND?: EvidenceItemScalarWhereWithAggregatesInput | EvidenceItemScalarWhereWithAggregatesInput[]
    OR?: EvidenceItemScalarWhereWithAggregatesInput[]
    NOT?: EvidenceItemScalarWhereWithAggregatesInput | EvidenceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvidenceItem"> | string
    escrowId?: BytesNullableWithAggregatesFilter<"EvidenceItem"> | Buffer | null
    uploader?: StringWithAggregatesFilter<"EvidenceItem"> | string
    uri?: StringWithAggregatesFilter<"EvidenceItem"> | string
    sha256?: StringWithAggregatesFilter<"EvidenceItem"> | string
    mime?: StringWithAggregatesFilter<"EvidenceItem"> | string
    size?: BigIntWithAggregatesFilter<"EvidenceItem"> | bigint | number
    description?: StringNullableWithAggregatesFilter<"EvidenceItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EvidenceItem"> | Date | string
  }

  export type DisputeWhereInput = {
    AND?: DisputeWhereInput | DisputeWhereInput[]
    OR?: DisputeWhereInput[]
    NOT?: DisputeWhereInput | DisputeWhereInput[]
    escrowId?: BytesFilter<"Dispute"> | Buffer
    openedBy?: StringFilter<"Dispute"> | string
    reasonCode?: StringNullableFilter<"Dispute"> | string | null
    summary?: StringNullableFilter<"Dispute"> | string | null
    status?: StringFilter<"Dispute"> | string
    arbitratorAssigned?: StringNullableFilter<"Dispute"> | string | null
    outcome?: StringNullableFilter<"Dispute"> | string | null
    ref?: BytesNullableFilter<"Dispute"> | Buffer | null
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }

  export type DisputeOrderByWithRelationInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    ref?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Escrow?: EscrowOrderByWithRelationInput
  }

  export type DisputeWhereUniqueInput = Prisma.AtLeast<{
    escrowId?: Buffer
    AND?: DisputeWhereInput | DisputeWhereInput[]
    OR?: DisputeWhereInput[]
    NOT?: DisputeWhereInput | DisputeWhereInput[]
    openedBy?: StringFilter<"Dispute"> | string
    reasonCode?: StringNullableFilter<"Dispute"> | string | null
    summary?: StringNullableFilter<"Dispute"> | string | null
    status?: StringFilter<"Dispute"> | string
    arbitratorAssigned?: StringNullableFilter<"Dispute"> | string | null
    outcome?: StringNullableFilter<"Dispute"> | string | null
    ref?: BytesNullableFilter<"Dispute"> | Buffer | null
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
    Escrow?: XOR<EscrowRelationFilter, EscrowWhereInput>
  }, "escrowId">

  export type DisputeOrderByWithAggregationInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    ref?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DisputeCountOrderByAggregateInput
    _max?: DisputeMaxOrderByAggregateInput
    _min?: DisputeMinOrderByAggregateInput
  }

  export type DisputeScalarWhereWithAggregatesInput = {
    AND?: DisputeScalarWhereWithAggregatesInput | DisputeScalarWhereWithAggregatesInput[]
    OR?: DisputeScalarWhereWithAggregatesInput[]
    NOT?: DisputeScalarWhereWithAggregatesInput | DisputeScalarWhereWithAggregatesInput[]
    escrowId?: BytesWithAggregatesFilter<"Dispute"> | Buffer
    openedBy?: StringWithAggregatesFilter<"Dispute"> | string
    reasonCode?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    status?: StringWithAggregatesFilter<"Dispute"> | string
    arbitratorAssigned?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    outcome?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    ref?: BytesNullableWithAggregatesFilter<"Dispute"> | Buffer | null
    createdAt?: DateTimeWithAggregatesFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dispute"> | Date | string
  }

  export type IndexerCheckpointWhereInput = {
    AND?: IndexerCheckpointWhereInput | IndexerCheckpointWhereInput[]
    OR?: IndexerCheckpointWhereInput[]
    NOT?: IndexerCheckpointWhereInput | IndexerCheckpointWhereInput[]
    chainId?: IntFilter<"IndexerCheckpoint"> | number
    contractAddress?: StringFilter<"IndexerCheckpoint"> | string
    lastSyncedBlock?: BigIntFilter<"IndexerCheckpoint"> | bigint | number
    updatedAt?: DateTimeFilter<"IndexerCheckpoint"> | Date | string
  }

  export type IndexerCheckpointOrderByWithRelationInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointWhereUniqueInput = Prisma.AtLeast<{
    chainId_contractAddress?: IndexerCheckpointChainIdContractAddressCompoundUniqueInput
    AND?: IndexerCheckpointWhereInput | IndexerCheckpointWhereInput[]
    OR?: IndexerCheckpointWhereInput[]
    NOT?: IndexerCheckpointWhereInput | IndexerCheckpointWhereInput[]
    chainId?: IntFilter<"IndexerCheckpoint"> | number
    contractAddress?: StringFilter<"IndexerCheckpoint"> | string
    lastSyncedBlock?: BigIntFilter<"IndexerCheckpoint"> | bigint | number
    updatedAt?: DateTimeFilter<"IndexerCheckpoint"> | Date | string
  }, "chainId_contractAddress">

  export type IndexerCheckpointOrderByWithAggregationInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
    _count?: IndexerCheckpointCountOrderByAggregateInput
    _avg?: IndexerCheckpointAvgOrderByAggregateInput
    _max?: IndexerCheckpointMaxOrderByAggregateInput
    _min?: IndexerCheckpointMinOrderByAggregateInput
    _sum?: IndexerCheckpointSumOrderByAggregateInput
  }

  export type IndexerCheckpointScalarWhereWithAggregatesInput = {
    AND?: IndexerCheckpointScalarWhereWithAggregatesInput | IndexerCheckpointScalarWhereWithAggregatesInput[]
    OR?: IndexerCheckpointScalarWhereWithAggregatesInput[]
    NOT?: IndexerCheckpointScalarWhereWithAggregatesInput | IndexerCheckpointScalarWhereWithAggregatesInput[]
    chainId?: IntWithAggregatesFilter<"IndexerCheckpoint"> | number
    contractAddress?: StringWithAggregatesFilter<"IndexerCheckpoint"> | string
    lastSyncedBlock?: BigIntWithAggregatesFilter<"IndexerCheckpoint"> | bigint | number
    updatedAt?: DateTimeWithAggregatesFilter<"IndexerCheckpoint"> | Date | string
  }

  export type TokenRegistryWhereInput = {
    AND?: TokenRegistryWhereInput | TokenRegistryWhereInput[]
    OR?: TokenRegistryWhereInput[]
    NOT?: TokenRegistryWhereInput | TokenRegistryWhereInput[]
    chainId?: IntFilter<"TokenRegistry"> | number
    tokenKey?: StringFilter<"TokenRegistry"> | string
    symbol?: StringFilter<"TokenRegistry"> | string
    decimals?: IntFilter<"TokenRegistry"> | number
    name?: StringFilter<"TokenRegistry"> | string
    enabled?: BoolFilter<"TokenRegistry"> | boolean
  }

  export type TokenRegistryOrderByWithRelationInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
  }

  export type TokenRegistryWhereUniqueInput = Prisma.AtLeast<{
    chainId_tokenKey?: TokenRegistryChainIdTokenKeyCompoundUniqueInput
    AND?: TokenRegistryWhereInput | TokenRegistryWhereInput[]
    OR?: TokenRegistryWhereInput[]
    NOT?: TokenRegistryWhereInput | TokenRegistryWhereInput[]
    chainId?: IntFilter<"TokenRegistry"> | number
    tokenKey?: StringFilter<"TokenRegistry"> | string
    symbol?: StringFilter<"TokenRegistry"> | string
    decimals?: IntFilter<"TokenRegistry"> | number
    name?: StringFilter<"TokenRegistry"> | string
    enabled?: BoolFilter<"TokenRegistry"> | boolean
  }, "chainId_tokenKey">

  export type TokenRegistryOrderByWithAggregationInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    _count?: TokenRegistryCountOrderByAggregateInput
    _avg?: TokenRegistryAvgOrderByAggregateInput
    _max?: TokenRegistryMaxOrderByAggregateInput
    _min?: TokenRegistryMinOrderByAggregateInput
    _sum?: TokenRegistrySumOrderByAggregateInput
  }

  export type TokenRegistryScalarWhereWithAggregatesInput = {
    AND?: TokenRegistryScalarWhereWithAggregatesInput | TokenRegistryScalarWhereWithAggregatesInput[]
    OR?: TokenRegistryScalarWhereWithAggregatesInput[]
    NOT?: TokenRegistryScalarWhereWithAggregatesInput | TokenRegistryScalarWhereWithAggregatesInput[]
    chainId?: IntWithAggregatesFilter<"TokenRegistry"> | number
    tokenKey?: StringWithAggregatesFilter<"TokenRegistry"> | string
    symbol?: StringWithAggregatesFilter<"TokenRegistry"> | string
    decimals?: IntWithAggregatesFilter<"TokenRegistry"> | number
    name?: StringWithAggregatesFilter<"TokenRegistry"> | string
    enabled?: BoolWithAggregatesFilter<"TokenRegistry"> | boolean
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorAddress?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorAddress?: SortOrderInput | SortOrder
    action?: SortOrder
    target?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorAddress?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorAddress?: SortOrderInput | SortOrder
    action?: SortOrder
    target?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    target?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NonceWhereInput = {
    AND?: NonceWhereInput | NonceWhereInput[]
    OR?: NonceWhereInput[]
    NOT?: NonceWhereInput | NonceWhereInput[]
    id?: StringFilter<"Nonce"> | string
    address?: StringFilter<"Nonce"> | string
    value?: StringFilter<"Nonce"> | string
    chainId?: IntFilter<"Nonce"> | number
    domain?: StringNullableFilter<"Nonce"> | string | null
    issuedAt?: DateTimeFilter<"Nonce"> | Date | string
    expiresAt?: DateTimeFilter<"Nonce"> | Date | string
    used?: BoolFilter<"Nonce"> | boolean
    createdAt?: DateTimeFilter<"Nonce"> | Date | string
  }

  export type NonceOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address_value?: NonceAddressValueCompoundUniqueInput
    AND?: NonceWhereInput | NonceWhereInput[]
    OR?: NonceWhereInput[]
    NOT?: NonceWhereInput | NonceWhereInput[]
    address?: StringFilter<"Nonce"> | string
    value?: StringFilter<"Nonce"> | string
    chainId?: IntFilter<"Nonce"> | number
    domain?: StringNullableFilter<"Nonce"> | string | null
    issuedAt?: DateTimeFilter<"Nonce"> | Date | string
    expiresAt?: DateTimeFilter<"Nonce"> | Date | string
    used?: BoolFilter<"Nonce"> | boolean
    createdAt?: DateTimeFilter<"Nonce"> | Date | string
  }, "id" | "address_value">

  export type NonceOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: NonceCountOrderByAggregateInput
    _avg?: NonceAvgOrderByAggregateInput
    _max?: NonceMaxOrderByAggregateInput
    _min?: NonceMinOrderByAggregateInput
    _sum?: NonceSumOrderByAggregateInput
  }

  export type NonceScalarWhereWithAggregatesInput = {
    AND?: NonceScalarWhereWithAggregatesInput | NonceScalarWhereWithAggregatesInput[]
    OR?: NonceScalarWhereWithAggregatesInput[]
    NOT?: NonceScalarWhereWithAggregatesInput | NonceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Nonce"> | string
    address?: StringWithAggregatesFilter<"Nonce"> | string
    value?: StringWithAggregatesFilter<"Nonce"> | string
    chainId?: IntWithAggregatesFilter<"Nonce"> | number
    domain?: StringNullableWithAggregatesFilter<"Nonce"> | string | null
    issuedAt?: DateTimeWithAggregatesFilter<"Nonce"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Nonce"> | Date | string
    used?: BoolWithAggregatesFilter<"Nonce"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Nonce"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    address?: StringFilter<"NotificationPreference"> | string
    webhookUrl?: StringNullableFilter<"NotificationPreference"> | string | null
    email?: StringNullableFilter<"NotificationPreference"> | string | null
    telegramId?: StringNullableFilter<"NotificationPreference"> | string | null
    smsNumber?: StringNullableFilter<"NotificationPreference"> | string | null
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    address?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telegramId?: SortOrderInput | SortOrder
    smsNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    address?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    webhookUrl?: StringNullableFilter<"NotificationPreference"> | string | null
    email?: StringNullableFilter<"NotificationPreference"> | string | null
    telegramId?: StringNullableFilter<"NotificationPreference"> | string | null
    smsNumber?: StringNullableFilter<"NotificationPreference"> | string | null
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "address">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    address?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telegramId?: SortOrderInput | SortOrder
    smsNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    address?: StringWithAggregatesFilter<"NotificationPreference"> | string
    webhookUrl?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    email?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    telegramId?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    smsNumber?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type UserCreateInput = {
    address: string
    displayName?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    roles?: RoleCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    address: string
    displayName?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    address: string
    displayName?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    id?: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    address: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateManyInput = {
    id?: string
    address: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowCreateInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
  }

  export type EscrowUncheckedCreateInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
  }

  export type EscrowUpdateInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowCreateManyInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscrowUpdateManyMutationInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowUncheckedUpdateManyInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowTimelineCreateInput = {
    id?: bigint | number
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
    Escrow: EscrowCreateNestedOneWithoutTimelineInput
  }

  export type EscrowTimelineUncheckedCreateInput = {
    id?: bigint | number
    escrowId: Buffer
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
    Escrow?: EscrowUpdateOneRequiredWithoutTimelineNestedInput
  }

  export type EscrowTimelineUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineCreateManyInput = {
    id?: bigint | number
    escrowId: Buffer
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowMessageCreateInput = {
    id?: string
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    Escrow?: EscrowCreateNestedOneWithoutMessagesInput
  }

  export type EscrowMessageUncheckedCreateInput = {
    id?: string
    escrowId?: Buffer | null
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Escrow?: EscrowUpdateOneWithoutMessagesNestedInput
  }

  export type EscrowMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowMessageCreateManyInput = {
    id?: string
    escrowId?: Buffer | null
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowPaymentInstructionCreateInput = {
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    Escrow: EscrowCreateNestedOneWithoutPaymentInstructionInput
  }

  export type EscrowPaymentInstructionUncheckedCreateInput = {
    escrowId: Buffer
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type EscrowPaymentInstructionUpdateInput = {
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escrow?: EscrowUpdateOneRequiredWithoutPaymentInstructionNestedInput
  }

  export type EscrowPaymentInstructionUncheckedUpdateInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowPaymentInstructionCreateManyInput = {
    escrowId: Buffer
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type EscrowPaymentInstructionUpdateManyMutationInput = {
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowPaymentInstructionUncheckedUpdateManyInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusCreateInput = {
    id?: bigint | number
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
    Escrow?: EscrowCreateNestedOneWithoutFiatStatusesInput
  }

  export type EscrowFiatStatusUncheckedCreateInput = {
    id?: bigint | number
    escrowId?: Buffer | null
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EscrowFiatStatusUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escrow?: EscrowUpdateOneWithoutFiatStatusesNestedInput
  }

  export type EscrowFiatStatusUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusCreateManyInput = {
    id?: bigint | number
    escrowId?: Buffer | null
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EscrowFiatStatusUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemCreateInput = {
    id?: string
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
    Escrow?: EscrowCreateNestedOneWithoutEvidenceInput
  }

  export type EvidenceItemUncheckedCreateInput = {
    id?: string
    escrowId?: Buffer | null
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escrow?: EscrowUpdateOneWithoutEvidenceNestedInput
  }

  export type EvidenceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemCreateManyInput = {
    id?: string
    escrowId?: Buffer | null
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrowId?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeCreateInput = {
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Escrow: EscrowCreateNestedOneWithoutDisputeInput
  }

  export type DisputeUncheckedCreateInput = {
    escrowId: Buffer
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUpdateInput = {
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escrow?: EscrowUpdateOneRequiredWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeCreateManyInput = {
    escrowId: Buffer
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUpdateManyMutationInput = {
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUncheckedUpdateManyInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndexerCheckpointCreateInput = {
    chainId: number
    contractAddress: string
    lastSyncedBlock: bigint | number
    updatedAt?: Date | string
  }

  export type IndexerCheckpointUncheckedCreateInput = {
    chainId: number
    contractAddress: string
    lastSyncedBlock: bigint | number
    updatedAt?: Date | string
  }

  export type IndexerCheckpointUpdateInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    lastSyncedBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndexerCheckpointUncheckedUpdateInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    lastSyncedBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndexerCheckpointCreateManyInput = {
    chainId: number
    contractAddress: string
    lastSyncedBlock: bigint | number
    updatedAt?: Date | string
  }

  export type IndexerCheckpointUpdateManyMutationInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    lastSyncedBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndexerCheckpointUncheckedUpdateManyInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    lastSyncedBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenRegistryCreateInput = {
    chainId: number
    tokenKey: string
    symbol: string
    decimals: number
    name: string
    enabled?: boolean
  }

  export type TokenRegistryUncheckedCreateInput = {
    chainId: number
    tokenKey: string
    symbol: string
    decimals: number
    name: string
    enabled?: boolean
  }

  export type TokenRegistryUpdateInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    tokenKey?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenRegistryUncheckedUpdateInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    tokenKey?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenRegistryCreateManyInput = {
    chainId: number
    tokenKey: string
    symbol: string
    decimals: number
    name: string
    enabled?: boolean
  }

  export type TokenRegistryUpdateManyMutationInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    tokenKey?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenRegistryUncheckedUpdateManyInput = {
    chainId?: IntFieldUpdateOperationsInput | number
    tokenKey?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateInput = {
    id?: string
    actorAddress?: string | null
    action: string
    target?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorAddress?: string | null
    action: string
    target?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorAddress?: string | null
    action: string
    target?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonceCreateInput = {
    id?: string
    address: string
    value: string
    chainId: number
    domain?: string | null
    issuedAt: Date | string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type NonceUncheckedCreateInput = {
    id?: string
    address: string
    value: string
    chainId: number
    domain?: string | null
    issuedAt: Date | string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type NonceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonceCreateManyInput = {
    id?: string
    address: string
    value: string
    chainId: number
    domain?: string | null
    issuedAt: Date | string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type NonceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    webhookUrl?: string | null
    email?: string | null
    telegramId?: string | null
    smsNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferenceInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    address: string
    webhookUrl?: string | null
    email?: string | null
    telegramId?: string | null
    smsNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    smsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferenceNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    smsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    address: string
    webhookUrl?: string | null
    email?: string | null
    telegramId?: string | null
    smsNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    smsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    address?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    smsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type NotificationPreferenceNullableRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    address?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    address?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    address?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleAddressRoleCompoundUniqueInput = {
    address: string
    role: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    role?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EscrowTimelineListRelationFilter = {
    every?: EscrowTimelineWhereInput
    some?: EscrowTimelineWhereInput
    none?: EscrowTimelineWhereInput
  }

  export type EscrowMessageListRelationFilter = {
    every?: EscrowMessageWhereInput
    some?: EscrowMessageWhereInput
    none?: EscrowMessageWhereInput
  }

  export type EscrowPaymentInstructionNullableRelationFilter = {
    is?: EscrowPaymentInstructionWhereInput | null
    isNot?: EscrowPaymentInstructionWhereInput | null
  }

  export type EscrowFiatStatusListRelationFilter = {
    every?: EscrowFiatStatusWhereInput
    some?: EscrowFiatStatusWhereInput
    none?: EscrowFiatStatusWhereInput
  }

  export type EvidenceItemListRelationFilter = {
    every?: EvidenceItemWhereInput
    some?: EvidenceItemWhereInput
    none?: EvidenceItemWhereInput
  }

  export type DisputeNullableRelationFilter = {
    is?: DisputeWhereInput | null
    isNot?: DisputeWhereInput | null
  }

  export type EscrowTimelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscrowMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscrowFiatStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvidenceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscrowCountOrderByAggregateInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrder
    txHashLast?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowAvgOrderByAggregateInput = {
    chainId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
  }

  export type EscrowMaxOrderByAggregateInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrder
    txHashLast?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowMinOrderByAggregateInput = {
    escrowId?: SortOrder
    chainId?: SortOrder
    contractAddress?: SortOrder
    tokenKey?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    state?: SortOrder
    seller?: SortOrder
    buyer?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
    txHashCreate?: SortOrder
    txHashLast?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowSumOrderByAggregateInput = {
    chainId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    sellerBond?: SortOrder
    buyerBond?: SortOrder
    createdAtBlock?: SortOrder
    updatedAtBlock?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EscrowRelationFilter = {
    is?: EscrowWhereInput
    isNot?: EscrowWhereInput
  }

  export type EscrowTimelineEscrowIdBlockNumberLogIndexCompoundUniqueInput = {
    escrowId: Buffer
    blockNumber: bigint | number
    logIndex: number
  }

  export type EscrowTimelineCountOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
    payload?: SortOrder
  }

  export type EscrowTimelineAvgOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
  }

  export type EscrowTimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
  }

  export type EscrowTimelineMinOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    chainId?: SortOrder
    eventName?: SortOrder
    stateAfter?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
    timestamp?: SortOrder
  }

  export type EscrowTimelineSumOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    blockNumber?: SortOrder
    logIndex?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type EscrowNullableRelationFilter = {
    is?: EscrowWhereInput | null
    isNot?: EscrowWhereInput | null
  }

  export type EscrowMessageCountOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
  }

  export type EscrowMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
  }

  export type EscrowMessageMinOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    sender?: SortOrder
    text?: SortOrder
    attachment?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EscrowPaymentInstructionCountOrderByAggregateInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    content?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowPaymentInstructionMaxOrderByAggregateInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscrowPaymentInstructionMinOrderByAggregateInput = {
    escrowId?: SortOrder
    seller?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EscrowFiatStatusCountOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EscrowFiatStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EscrowFiatStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EscrowFiatStatusMinOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    actor?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EscrowFiatStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EvidenceItemCountOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceItemAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EvidenceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceItemMinOrderByAggregateInput = {
    id?: SortOrder
    escrowId?: SortOrder
    uploader?: SortOrder
    uri?: SortOrder
    sha256?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceItemSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DisputeCountOrderByAggregateInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrder
    outcome?: SortOrder
    ref?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeMaxOrderByAggregateInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrder
    outcome?: SortOrder
    ref?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeMinOrderByAggregateInput = {
    escrowId?: SortOrder
    openedBy?: SortOrder
    reasonCode?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    arbitratorAssigned?: SortOrder
    outcome?: SortOrder
    ref?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointChainIdContractAddressCompoundUniqueInput = {
    chainId: number
    contractAddress: string
  }

  export type IndexerCheckpointCountOrderByAggregateInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointAvgOrderByAggregateInput = {
    chainId?: SortOrder
    lastSyncedBlock?: SortOrder
  }

  export type IndexerCheckpointMaxOrderByAggregateInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointMinOrderByAggregateInput = {
    chainId?: SortOrder
    contractAddress?: SortOrder
    lastSyncedBlock?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndexerCheckpointSumOrderByAggregateInput = {
    chainId?: SortOrder
    lastSyncedBlock?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TokenRegistryChainIdTokenKeyCompoundUniqueInput = {
    chainId: number
    tokenKey: string
  }

  export type TokenRegistryCountOrderByAggregateInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
  }

  export type TokenRegistryAvgOrderByAggregateInput = {
    chainId?: SortOrder
    decimals?: SortOrder
  }

  export type TokenRegistryMaxOrderByAggregateInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
  }

  export type TokenRegistryMinOrderByAggregateInput = {
    chainId?: SortOrder
    tokenKey?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
  }

  export type TokenRegistrySumOrderByAggregateInput = {
    chainId?: SortOrder
    decimals?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorAddress?: SortOrder
    action?: SortOrder
    target?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorAddress?: SortOrder
    action?: SortOrder
    target?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorAddress?: SortOrder
    action?: SortOrder
    target?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceAddressValueCompoundUniqueInput = {
    address: string
    value: string
  }

  export type NonceCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceAvgOrderByAggregateInput = {
    chainId?: SortOrder
  }

  export type NonceMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    chainId?: SortOrder
    domain?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type NonceSumOrderByAggregateInput = {
    chainId?: SortOrder
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    address?: SortOrder
    webhookUrl?: SortOrder
    email?: SortOrder
    telegramId?: SortOrder
    smsNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    address?: SortOrder
    webhookUrl?: SortOrder
    email?: SortOrder
    telegramId?: SortOrder
    smsNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    address?: SortOrder
    webhookUrl?: SortOrder
    email?: SortOrder
    telegramId?: SortOrder
    smsNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleCreateNestedManyWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput> | RoleCreateWithoutUserInput[] | RoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput | RoleCreateOrConnectWithoutUserInput[]
    createMany?: RoleCreateManyUserInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type RoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput> | RoleCreateWithoutUserInput[] | RoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput | RoleCreateOrConnectWithoutUserInput[]
    createMany?: RoleCreateManyUserInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput> | RoleCreateWithoutUserInput[] | RoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput | RoleCreateOrConnectWithoutUserInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutUserInput | RoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoleCreateManyUserInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutUserInput | RoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutUserInput | RoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type RoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput> | RoleCreateWithoutUserInput[] | RoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput | RoleCreateOrConnectWithoutUserInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutUserInput | RoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoleCreateManyUserInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutUserInput | RoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutUserInput | RoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type EscrowTimelineCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput> | EscrowTimelineCreateWithoutEscrowInput[] | EscrowTimelineUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowTimelineCreateOrConnectWithoutEscrowInput | EscrowTimelineCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowTimelineCreateManyEscrowInputEnvelope
    connect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
  }

  export type EscrowMessageCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput> | EscrowMessageCreateWithoutEscrowInput[] | EscrowMessageUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowMessageCreateOrConnectWithoutEscrowInput | EscrowMessageCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowMessageCreateManyEscrowInputEnvelope
    connect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
  }

  export type EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput = {
    create?: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput
    connect?: EscrowPaymentInstructionWhereUniqueInput
  }

  export type EscrowFiatStatusCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput> | EscrowFiatStatusCreateWithoutEscrowInput[] | EscrowFiatStatusUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowFiatStatusCreateOrConnectWithoutEscrowInput | EscrowFiatStatusCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowFiatStatusCreateManyEscrowInputEnvelope
    connect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
  }

  export type EvidenceItemCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput> | EvidenceItemCreateWithoutEscrowInput[] | EvidenceItemUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EvidenceItemCreateOrConnectWithoutEscrowInput | EvidenceItemCreateOrConnectWithoutEscrowInput[]
    createMany?: EvidenceItemCreateManyEscrowInputEnvelope
    connect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
  }

  export type DisputeCreateNestedOneWithoutEscrowInput = {
    create?: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEscrowInput
    connect?: DisputeWhereUniqueInput
  }

  export type EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput> | EscrowTimelineCreateWithoutEscrowInput[] | EscrowTimelineUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowTimelineCreateOrConnectWithoutEscrowInput | EscrowTimelineCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowTimelineCreateManyEscrowInputEnvelope
    connect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
  }

  export type EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput> | EscrowMessageCreateWithoutEscrowInput[] | EscrowMessageUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowMessageCreateOrConnectWithoutEscrowInput | EscrowMessageCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowMessageCreateManyEscrowInputEnvelope
    connect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
  }

  export type EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput = {
    create?: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput
    connect?: EscrowPaymentInstructionWhereUniqueInput
  }

  export type EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput> | EscrowFiatStatusCreateWithoutEscrowInput[] | EscrowFiatStatusUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowFiatStatusCreateOrConnectWithoutEscrowInput | EscrowFiatStatusCreateOrConnectWithoutEscrowInput[]
    createMany?: EscrowFiatStatusCreateManyEscrowInputEnvelope
    connect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
  }

  export type EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput = {
    create?: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput> | EvidenceItemCreateWithoutEscrowInput[] | EvidenceItemUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EvidenceItemCreateOrConnectWithoutEscrowInput | EvidenceItemCreateOrConnectWithoutEscrowInput[]
    createMany?: EvidenceItemCreateManyEscrowInputEnvelope
    connect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
  }

  export type DisputeUncheckedCreateNestedOneWithoutEscrowInput = {
    create?: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEscrowInput
    connect?: DisputeWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EscrowTimelineUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput> | EscrowTimelineCreateWithoutEscrowInput[] | EscrowTimelineUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowTimelineCreateOrConnectWithoutEscrowInput | EscrowTimelineCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput | EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowTimelineCreateManyEscrowInputEnvelope
    set?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    disconnect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    delete?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    connect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    update?: EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput | EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowTimelineUpdateManyWithWhereWithoutEscrowInput | EscrowTimelineUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowTimelineScalarWhereInput | EscrowTimelineScalarWhereInput[]
  }

  export type EscrowMessageUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput> | EscrowMessageCreateWithoutEscrowInput[] | EscrowMessageUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowMessageCreateOrConnectWithoutEscrowInput | EscrowMessageCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput | EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowMessageCreateManyEscrowInputEnvelope
    set?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    disconnect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    delete?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    connect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    update?: EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput | EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowMessageUpdateManyWithWhereWithoutEscrowInput | EscrowMessageUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowMessageScalarWhereInput | EscrowMessageScalarWhereInput[]
  }

  export type EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput = {
    create?: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput
    upsert?: EscrowPaymentInstructionUpsertWithoutEscrowInput
    disconnect?: EscrowPaymentInstructionWhereInput | boolean
    delete?: EscrowPaymentInstructionWhereInput | boolean
    connect?: EscrowPaymentInstructionWhereUniqueInput
    update?: XOR<XOR<EscrowPaymentInstructionUpdateToOneWithWhereWithoutEscrowInput, EscrowPaymentInstructionUpdateWithoutEscrowInput>, EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowFiatStatusUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput> | EscrowFiatStatusCreateWithoutEscrowInput[] | EscrowFiatStatusUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowFiatStatusCreateOrConnectWithoutEscrowInput | EscrowFiatStatusCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput | EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowFiatStatusCreateManyEscrowInputEnvelope
    set?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    disconnect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    delete?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    connect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    update?: EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput | EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput | EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowFiatStatusScalarWhereInput | EscrowFiatStatusScalarWhereInput[]
  }

  export type EvidenceItemUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput> | EvidenceItemCreateWithoutEscrowInput[] | EvidenceItemUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EvidenceItemCreateOrConnectWithoutEscrowInput | EvidenceItemCreateOrConnectWithoutEscrowInput[]
    upsert?: EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput | EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EvidenceItemCreateManyEscrowInputEnvelope
    set?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    disconnect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    delete?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    connect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    update?: EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput | EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EvidenceItemUpdateManyWithWhereWithoutEscrowInput | EvidenceItemUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EvidenceItemScalarWhereInput | EvidenceItemScalarWhereInput[]
  }

  export type DisputeUpdateOneWithoutEscrowNestedInput = {
    create?: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEscrowInput
    upsert?: DisputeUpsertWithoutEscrowInput
    disconnect?: DisputeWhereInput | boolean
    delete?: DisputeWhereInput | boolean
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutEscrowInput, DisputeUpdateWithoutEscrowInput>, DisputeUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput> | EscrowTimelineCreateWithoutEscrowInput[] | EscrowTimelineUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowTimelineCreateOrConnectWithoutEscrowInput | EscrowTimelineCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput | EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowTimelineCreateManyEscrowInputEnvelope
    set?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    disconnect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    delete?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    connect?: EscrowTimelineWhereUniqueInput | EscrowTimelineWhereUniqueInput[]
    update?: EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput | EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowTimelineUpdateManyWithWhereWithoutEscrowInput | EscrowTimelineUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowTimelineScalarWhereInput | EscrowTimelineScalarWhereInput[]
  }

  export type EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput> | EscrowMessageCreateWithoutEscrowInput[] | EscrowMessageUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowMessageCreateOrConnectWithoutEscrowInput | EscrowMessageCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput | EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowMessageCreateManyEscrowInputEnvelope
    set?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    disconnect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    delete?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    connect?: EscrowMessageWhereUniqueInput | EscrowMessageWhereUniqueInput[]
    update?: EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput | EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowMessageUpdateManyWithWhereWithoutEscrowInput | EscrowMessageUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowMessageScalarWhereInput | EscrowMessageScalarWhereInput[]
  }

  export type EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput = {
    create?: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput
    upsert?: EscrowPaymentInstructionUpsertWithoutEscrowInput
    disconnect?: EscrowPaymentInstructionWhereInput | boolean
    delete?: EscrowPaymentInstructionWhereInput | boolean
    connect?: EscrowPaymentInstructionWhereUniqueInput
    update?: XOR<XOR<EscrowPaymentInstructionUpdateToOneWithWhereWithoutEscrowInput, EscrowPaymentInstructionUpdateWithoutEscrowInput>, EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput> | EscrowFiatStatusCreateWithoutEscrowInput[] | EscrowFiatStatusUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EscrowFiatStatusCreateOrConnectWithoutEscrowInput | EscrowFiatStatusCreateOrConnectWithoutEscrowInput[]
    upsert?: EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput | EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EscrowFiatStatusCreateManyEscrowInputEnvelope
    set?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    disconnect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    delete?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    connect?: EscrowFiatStatusWhereUniqueInput | EscrowFiatStatusWhereUniqueInput[]
    update?: EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput | EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput | EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EscrowFiatStatusScalarWhereInput | EscrowFiatStatusScalarWhereInput[]
  }

  export type EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput = {
    create?: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput> | EvidenceItemCreateWithoutEscrowInput[] | EvidenceItemUncheckedCreateWithoutEscrowInput[]
    connectOrCreate?: EvidenceItemCreateOrConnectWithoutEscrowInput | EvidenceItemCreateOrConnectWithoutEscrowInput[]
    upsert?: EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput | EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput[]
    createMany?: EvidenceItemCreateManyEscrowInputEnvelope
    set?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    disconnect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    delete?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    connect?: EvidenceItemWhereUniqueInput | EvidenceItemWhereUniqueInput[]
    update?: EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput | EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput[]
    updateMany?: EvidenceItemUpdateManyWithWhereWithoutEscrowInput | EvidenceItemUpdateManyWithWhereWithoutEscrowInput[]
    deleteMany?: EvidenceItemScalarWhereInput | EvidenceItemScalarWhereInput[]
  }

  export type DisputeUncheckedUpdateOneWithoutEscrowNestedInput = {
    create?: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEscrowInput
    upsert?: DisputeUpsertWithoutEscrowInput
    disconnect?: DisputeWhereInput | boolean
    delete?: DisputeWhereInput | boolean
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutEscrowInput, DisputeUpdateWithoutEscrowInput>, DisputeUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowCreateNestedOneWithoutTimelineInput = {
    create?: XOR<EscrowCreateWithoutTimelineInput, EscrowUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutTimelineInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneRequiredWithoutTimelineNestedInput = {
    create?: XOR<EscrowCreateWithoutTimelineInput, EscrowUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutTimelineInput
    upsert?: EscrowUpsertWithoutTimelineInput
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutTimelineInput, EscrowUpdateWithoutTimelineInput>, EscrowUncheckedUpdateWithoutTimelineInput>
  }

  export type EscrowCreateNestedOneWithoutMessagesInput = {
    create?: XOR<EscrowCreateWithoutMessagesInput, EscrowUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutMessagesInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<EscrowCreateWithoutMessagesInput, EscrowUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutMessagesInput
    upsert?: EscrowUpsertWithoutMessagesInput
    disconnect?: EscrowWhereInput | boolean
    delete?: EscrowWhereInput | boolean
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutMessagesInput, EscrowUpdateWithoutMessagesInput>, EscrowUncheckedUpdateWithoutMessagesInput>
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type EscrowCreateNestedOneWithoutPaymentInstructionInput = {
    create?: XOR<EscrowCreateWithoutPaymentInstructionInput, EscrowUncheckedCreateWithoutPaymentInstructionInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutPaymentInstructionInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneRequiredWithoutPaymentInstructionNestedInput = {
    create?: XOR<EscrowCreateWithoutPaymentInstructionInput, EscrowUncheckedCreateWithoutPaymentInstructionInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutPaymentInstructionInput
    upsert?: EscrowUpsertWithoutPaymentInstructionInput
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutPaymentInstructionInput, EscrowUpdateWithoutPaymentInstructionInput>, EscrowUncheckedUpdateWithoutPaymentInstructionInput>
  }

  export type EscrowCreateNestedOneWithoutFiatStatusesInput = {
    create?: XOR<EscrowCreateWithoutFiatStatusesInput, EscrowUncheckedCreateWithoutFiatStatusesInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutFiatStatusesInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneWithoutFiatStatusesNestedInput = {
    create?: XOR<EscrowCreateWithoutFiatStatusesInput, EscrowUncheckedCreateWithoutFiatStatusesInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutFiatStatusesInput
    upsert?: EscrowUpsertWithoutFiatStatusesInput
    disconnect?: EscrowWhereInput | boolean
    delete?: EscrowWhereInput | boolean
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutFiatStatusesInput, EscrowUpdateWithoutFiatStatusesInput>, EscrowUncheckedUpdateWithoutFiatStatusesInput>
  }

  export type EscrowCreateNestedOneWithoutEvidenceInput = {
    create?: XOR<EscrowCreateWithoutEvidenceInput, EscrowUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutEvidenceInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneWithoutEvidenceNestedInput = {
    create?: XOR<EscrowCreateWithoutEvidenceInput, EscrowUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutEvidenceInput
    upsert?: EscrowUpsertWithoutEvidenceInput
    disconnect?: EscrowWhereInput | boolean
    delete?: EscrowWhereInput | boolean
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutEvidenceInput, EscrowUpdateWithoutEvidenceInput>, EscrowUncheckedUpdateWithoutEvidenceInput>
  }

  export type EscrowCreateNestedOneWithoutDisputeInput = {
    create?: XOR<EscrowCreateWithoutDisputeInput, EscrowUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutDisputeInput
    connect?: EscrowWhereUniqueInput
  }

  export type EscrowUpdateOneRequiredWithoutDisputeNestedInput = {
    create?: XOR<EscrowCreateWithoutDisputeInput, EscrowUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: EscrowCreateOrConnectWithoutDisputeInput
    upsert?: EscrowUpsertWithoutDisputeInput
    connect?: EscrowWhereUniqueInput
    update?: XOR<XOR<EscrowUpdateToOneWithWhereWithoutDisputeInput, EscrowUpdateWithoutDisputeInput>, EscrowUncheckedUpdateWithoutDisputeInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCreateNestedOneWithoutNotificationPreferenceInput = {
    create?: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferenceInput
    upsert?: UserUpsertWithoutNotificationPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferenceInput, UserUpdateWithoutNotificationPreferenceInput>, UserUncheckedUpdateWithoutNotificationPreferenceInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RoleCreateWithoutUserInput = {
    id?: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUserInput = {
    id?: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUserInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type RoleCreateManyUserInputEnvelope = {
    data: RoleCreateManyUserInput | RoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    webhookUrl?: string | null
    email?: string | null
    telegramId?: string | null
    smsNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    webhookUrl?: string | null
    email?: string | null
    telegramId?: string | null
    smsNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutUserInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutUserInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
  }

  export type RoleUpdateManyWithWhereWithoutUserInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutUserInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    address?: StringFilter<"Role"> | string
    role?: StringFilter<"Role"> | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    smsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    smsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRolesInput = {
    address: string
    displayName?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    address: string
    displayName?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EscrowTimelineCreateWithoutEscrowInput = {
    id?: bigint | number
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUncheckedCreateWithoutEscrowInput = {
    id?: bigint | number
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineCreateOrConnectWithoutEscrowInput = {
    where: EscrowTimelineWhereUniqueInput
    create: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowTimelineCreateManyEscrowInputEnvelope = {
    data: EscrowTimelineCreateManyEscrowInput | EscrowTimelineCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type EscrowMessageCreateWithoutEscrowInput = {
    id?: string
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowMessageUncheckedCreateWithoutEscrowInput = {
    id?: string
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowMessageCreateOrConnectWithoutEscrowInput = {
    where: EscrowMessageWhereUniqueInput
    create: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowMessageCreateManyEscrowInputEnvelope = {
    data: EscrowMessageCreateManyEscrowInput | EscrowMessageCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type EscrowPaymentInstructionCreateWithoutEscrowInput = {
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput = {
    seller: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type EscrowPaymentInstructionCreateOrConnectWithoutEscrowInput = {
    where: EscrowPaymentInstructionWhereUniqueInput
    create: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowFiatStatusCreateWithoutEscrowInput = {
    id?: bigint | number
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EscrowFiatStatusUncheckedCreateWithoutEscrowInput = {
    id?: bigint | number
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EscrowFiatStatusCreateOrConnectWithoutEscrowInput = {
    where: EscrowFiatStatusWhereUniqueInput
    create: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowFiatStatusCreateManyEscrowInputEnvelope = {
    data: EscrowFiatStatusCreateManyEscrowInput | EscrowFiatStatusCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type EvidenceItemCreateWithoutEscrowInput = {
    id?: string
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemUncheckedCreateWithoutEscrowInput = {
    id?: string
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemCreateOrConnectWithoutEscrowInput = {
    where: EvidenceItemWhereUniqueInput
    create: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput>
  }

  export type EvidenceItemCreateManyEscrowInputEnvelope = {
    data: EvidenceItemCreateManyEscrowInput | EvidenceItemCreateManyEscrowInput[]
    skipDuplicates?: boolean
  }

  export type DisputeCreateWithoutEscrowInput = {
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUncheckedCreateWithoutEscrowInput = {
    openedBy: string
    reasonCode?: string | null
    summary?: string | null
    status: string
    arbitratorAssigned?: string | null
    outcome?: string | null
    ref?: Buffer | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeCreateOrConnectWithoutEscrowInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowTimelineUpsertWithWhereUniqueWithoutEscrowInput = {
    where: EscrowTimelineWhereUniqueInput
    update: XOR<EscrowTimelineUpdateWithoutEscrowInput, EscrowTimelineUncheckedUpdateWithoutEscrowInput>
    create: XOR<EscrowTimelineCreateWithoutEscrowInput, EscrowTimelineUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowTimelineUpdateWithWhereUniqueWithoutEscrowInput = {
    where: EscrowTimelineWhereUniqueInput
    data: XOR<EscrowTimelineUpdateWithoutEscrowInput, EscrowTimelineUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowTimelineUpdateManyWithWhereWithoutEscrowInput = {
    where: EscrowTimelineScalarWhereInput
    data: XOR<EscrowTimelineUpdateManyMutationInput, EscrowTimelineUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EscrowTimelineScalarWhereInput = {
    AND?: EscrowTimelineScalarWhereInput | EscrowTimelineScalarWhereInput[]
    OR?: EscrowTimelineScalarWhereInput[]
    NOT?: EscrowTimelineScalarWhereInput | EscrowTimelineScalarWhereInput[]
    id?: BigIntFilter<"EscrowTimeline"> | bigint | number
    escrowId?: BytesFilter<"EscrowTimeline"> | Buffer
    chainId?: IntFilter<"EscrowTimeline"> | number
    eventName?: StringFilter<"EscrowTimeline"> | string
    stateAfter?: StringFilter<"EscrowTimeline"> | string
    txHash?: StringFilter<"EscrowTimeline"> | string
    blockNumber?: BigIntFilter<"EscrowTimeline"> | bigint | number
    logIndex?: IntFilter<"EscrowTimeline"> | number
    timestamp?: DateTimeFilter<"EscrowTimeline"> | Date | string
    payload?: JsonFilter<"EscrowTimeline">
  }

  export type EscrowMessageUpsertWithWhereUniqueWithoutEscrowInput = {
    where: EscrowMessageWhereUniqueInput
    update: XOR<EscrowMessageUpdateWithoutEscrowInput, EscrowMessageUncheckedUpdateWithoutEscrowInput>
    create: XOR<EscrowMessageCreateWithoutEscrowInput, EscrowMessageUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowMessageUpdateWithWhereUniqueWithoutEscrowInput = {
    where: EscrowMessageWhereUniqueInput
    data: XOR<EscrowMessageUpdateWithoutEscrowInput, EscrowMessageUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowMessageUpdateManyWithWhereWithoutEscrowInput = {
    where: EscrowMessageScalarWhereInput
    data: XOR<EscrowMessageUpdateManyMutationInput, EscrowMessageUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EscrowMessageScalarWhereInput = {
    AND?: EscrowMessageScalarWhereInput | EscrowMessageScalarWhereInput[]
    OR?: EscrowMessageScalarWhereInput[]
    NOT?: EscrowMessageScalarWhereInput | EscrowMessageScalarWhereInput[]
    id?: StringFilter<"EscrowMessage"> | string
    escrowId?: BytesNullableFilter<"EscrowMessage"> | Buffer | null
    sender?: StringFilter<"EscrowMessage"> | string
    text?: StringFilter<"EscrowMessage"> | string
    attachment?: StringNullableFilter<"EscrowMessage"> | string | null
    hash?: StringNullableFilter<"EscrowMessage"> | string | null
    createdAt?: DateTimeFilter<"EscrowMessage"> | Date | string
    editedAt?: DateTimeNullableFilter<"EscrowMessage"> | Date | string | null
  }

  export type EscrowPaymentInstructionUpsertWithoutEscrowInput = {
    update: XOR<EscrowPaymentInstructionUpdateWithoutEscrowInput, EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput>
    create: XOR<EscrowPaymentInstructionCreateWithoutEscrowInput, EscrowPaymentInstructionUncheckedCreateWithoutEscrowInput>
    where?: EscrowPaymentInstructionWhereInput
  }

  export type EscrowPaymentInstructionUpdateToOneWithWhereWithoutEscrowInput = {
    where?: EscrowPaymentInstructionWhereInput
    data: XOR<EscrowPaymentInstructionUpdateWithoutEscrowInput, EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowPaymentInstructionUpdateWithoutEscrowInput = {
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowPaymentInstructionUncheckedUpdateWithoutEscrowInput = {
    seller?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusUpsertWithWhereUniqueWithoutEscrowInput = {
    where: EscrowFiatStatusWhereUniqueInput
    update: XOR<EscrowFiatStatusUpdateWithoutEscrowInput, EscrowFiatStatusUncheckedUpdateWithoutEscrowInput>
    create: XOR<EscrowFiatStatusCreateWithoutEscrowInput, EscrowFiatStatusUncheckedCreateWithoutEscrowInput>
  }

  export type EscrowFiatStatusUpdateWithWhereUniqueWithoutEscrowInput = {
    where: EscrowFiatStatusWhereUniqueInput
    data: XOR<EscrowFiatStatusUpdateWithoutEscrowInput, EscrowFiatStatusUncheckedUpdateWithoutEscrowInput>
  }

  export type EscrowFiatStatusUpdateManyWithWhereWithoutEscrowInput = {
    where: EscrowFiatStatusScalarWhereInput
    data: XOR<EscrowFiatStatusUpdateManyMutationInput, EscrowFiatStatusUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EscrowFiatStatusScalarWhereInput = {
    AND?: EscrowFiatStatusScalarWhereInput | EscrowFiatStatusScalarWhereInput[]
    OR?: EscrowFiatStatusScalarWhereInput[]
    NOT?: EscrowFiatStatusScalarWhereInput | EscrowFiatStatusScalarWhereInput[]
    id?: BigIntFilter<"EscrowFiatStatus"> | bigint | number
    escrowId?: BytesNullableFilter<"EscrowFiatStatus"> | Buffer | null
    actor?: StringFilter<"EscrowFiatStatus"> | string
    status?: StringFilter<"EscrowFiatStatus"> | string
    note?: StringNullableFilter<"EscrowFiatStatus"> | string | null
    createdAt?: DateTimeFilter<"EscrowFiatStatus"> | Date | string
  }

  export type EvidenceItemUpsertWithWhereUniqueWithoutEscrowInput = {
    where: EvidenceItemWhereUniqueInput
    update: XOR<EvidenceItemUpdateWithoutEscrowInput, EvidenceItemUncheckedUpdateWithoutEscrowInput>
    create: XOR<EvidenceItemCreateWithoutEscrowInput, EvidenceItemUncheckedCreateWithoutEscrowInput>
  }

  export type EvidenceItemUpdateWithWhereUniqueWithoutEscrowInput = {
    where: EvidenceItemWhereUniqueInput
    data: XOR<EvidenceItemUpdateWithoutEscrowInput, EvidenceItemUncheckedUpdateWithoutEscrowInput>
  }

  export type EvidenceItemUpdateManyWithWhereWithoutEscrowInput = {
    where: EvidenceItemScalarWhereInput
    data: XOR<EvidenceItemUpdateManyMutationInput, EvidenceItemUncheckedUpdateManyWithoutEscrowInput>
  }

  export type EvidenceItemScalarWhereInput = {
    AND?: EvidenceItemScalarWhereInput | EvidenceItemScalarWhereInput[]
    OR?: EvidenceItemScalarWhereInput[]
    NOT?: EvidenceItemScalarWhereInput | EvidenceItemScalarWhereInput[]
    id?: StringFilter<"EvidenceItem"> | string
    escrowId?: BytesNullableFilter<"EvidenceItem"> | Buffer | null
    uploader?: StringFilter<"EvidenceItem"> | string
    uri?: StringFilter<"EvidenceItem"> | string
    sha256?: StringFilter<"EvidenceItem"> | string
    mime?: StringFilter<"EvidenceItem"> | string
    size?: BigIntFilter<"EvidenceItem"> | bigint | number
    description?: StringNullableFilter<"EvidenceItem"> | string | null
    createdAt?: DateTimeFilter<"EvidenceItem"> | Date | string
  }

  export type DisputeUpsertWithoutEscrowInput = {
    update: XOR<DisputeUpdateWithoutEscrowInput, DisputeUncheckedUpdateWithoutEscrowInput>
    create: XOR<DisputeCreateWithoutEscrowInput, DisputeUncheckedCreateWithoutEscrowInput>
    where?: DisputeWhereInput
  }

  export type DisputeUpdateToOneWithWhereWithoutEscrowInput = {
    where?: DisputeWhereInput
    data: XOR<DisputeUpdateWithoutEscrowInput, DisputeUncheckedUpdateWithoutEscrowInput>
  }

  export type DisputeUpdateWithoutEscrowInput = {
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUncheckedUpdateWithoutEscrowInput = {
    openedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    arbitratorAssigned?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowCreateWithoutTimelineInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutTimelineInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutTimelineInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutTimelineInput, EscrowUncheckedCreateWithoutTimelineInput>
  }

  export type EscrowUpsertWithoutTimelineInput = {
    update: XOR<EscrowUpdateWithoutTimelineInput, EscrowUncheckedUpdateWithoutTimelineInput>
    create: XOR<EscrowCreateWithoutTimelineInput, EscrowUncheckedCreateWithoutTimelineInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutTimelineInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutTimelineInput, EscrowUncheckedUpdateWithoutTimelineInput>
  }

  export type EscrowUpdateWithoutTimelineInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutTimelineInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutMessagesInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutMessagesInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutMessagesInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutMessagesInput, EscrowUncheckedCreateWithoutMessagesInput>
  }

  export type EscrowUpsertWithoutMessagesInput = {
    update: XOR<EscrowUpdateWithoutMessagesInput, EscrowUncheckedUpdateWithoutMessagesInput>
    create: XOR<EscrowCreateWithoutMessagesInput, EscrowUncheckedCreateWithoutMessagesInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutMessagesInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutMessagesInput, EscrowUncheckedUpdateWithoutMessagesInput>
  }

  export type EscrowUpdateWithoutMessagesInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutMessagesInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutPaymentInstructionInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutPaymentInstructionInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutPaymentInstructionInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutPaymentInstructionInput, EscrowUncheckedCreateWithoutPaymentInstructionInput>
  }

  export type EscrowUpsertWithoutPaymentInstructionInput = {
    update: XOR<EscrowUpdateWithoutPaymentInstructionInput, EscrowUncheckedUpdateWithoutPaymentInstructionInput>
    create: XOR<EscrowCreateWithoutPaymentInstructionInput, EscrowUncheckedCreateWithoutPaymentInstructionInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutPaymentInstructionInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutPaymentInstructionInput, EscrowUncheckedUpdateWithoutPaymentInstructionInput>
  }

  export type EscrowUpdateWithoutPaymentInstructionInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutPaymentInstructionInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutFiatStatusesInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutFiatStatusesInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutFiatStatusesInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutFiatStatusesInput, EscrowUncheckedCreateWithoutFiatStatusesInput>
  }

  export type EscrowUpsertWithoutFiatStatusesInput = {
    update: XOR<EscrowUpdateWithoutFiatStatusesInput, EscrowUncheckedUpdateWithoutFiatStatusesInput>
    create: XOR<EscrowCreateWithoutFiatStatusesInput, EscrowUncheckedCreateWithoutFiatStatusesInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutFiatStatusesInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutFiatStatusesInput, EscrowUncheckedUpdateWithoutFiatStatusesInput>
  }

  export type EscrowUpdateWithoutFiatStatusesInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutFiatStatusesInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutEvidenceInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    dispute?: DisputeCreateNestedOneWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutEvidenceInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutEvidenceInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutEvidenceInput, EscrowUncheckedCreateWithoutEvidenceInput>
  }

  export type EscrowUpsertWithoutEvidenceInput = {
    update: XOR<EscrowUpdateWithoutEvidenceInput, EscrowUncheckedUpdateWithoutEvidenceInput>
    create: XOR<EscrowCreateWithoutEvidenceInput, EscrowUncheckedCreateWithoutEvidenceInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutEvidenceInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutEvidenceInput, EscrowUncheckedUpdateWithoutEvidenceInput>
  }

  export type EscrowUpdateWithoutEvidenceInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutEvidenceInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutEscrowNestedInput
  }

  export type EscrowCreateWithoutDisputeInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemCreateNestedManyWithoutEscrowInput
  }

  export type EscrowUncheckedCreateWithoutDisputeInput = {
    escrowId: Buffer
    chainId: number
    contractAddress: string
    tokenKey: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    sellerBond: Decimal | DecimalJsLike | number | string
    buyerBond: Decimal | DecimalJsLike | number | string
    state: string
    seller: string
    buyer?: string | null
    createdAtBlock: bigint | number
    updatedAtBlock: bigint | number
    txHashCreate?: string | null
    txHashLast?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeline?: EscrowTimelineUncheckedCreateNestedManyWithoutEscrowInput
    messages?: EscrowMessageUncheckedCreateNestedManyWithoutEscrowInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedCreateNestedOneWithoutEscrowInput
    fiatStatuses?: EscrowFiatStatusUncheckedCreateNestedManyWithoutEscrowInput
    evidence?: EvidenceItemUncheckedCreateNestedManyWithoutEscrowInput
  }

  export type EscrowCreateOrConnectWithoutDisputeInput = {
    where: EscrowWhereUniqueInput
    create: XOR<EscrowCreateWithoutDisputeInput, EscrowUncheckedCreateWithoutDisputeInput>
  }

  export type EscrowUpsertWithoutDisputeInput = {
    update: XOR<EscrowUpdateWithoutDisputeInput, EscrowUncheckedUpdateWithoutDisputeInput>
    create: XOR<EscrowCreateWithoutDisputeInput, EscrowUncheckedCreateWithoutDisputeInput>
    where?: EscrowWhereInput
  }

  export type EscrowUpdateToOneWithWhereWithoutDisputeInput = {
    where?: EscrowWhereInput
    data: XOR<EscrowUpdateWithoutDisputeInput, EscrowUncheckedUpdateWithoutDisputeInput>
  }

  export type EscrowUpdateWithoutDisputeInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUpdateManyWithoutEscrowNestedInput
  }

  export type EscrowUncheckedUpdateWithoutDisputeInput = {
    escrowId?: BytesFieldUpdateOperationsInput | Buffer
    chainId?: IntFieldUpdateOperationsInput | number
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenKey?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buyerBond?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    state?: StringFieldUpdateOperationsInput | string
    seller?: StringFieldUpdateOperationsInput | string
    buyer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAtBlock?: BigIntFieldUpdateOperationsInput | bigint | number
    txHashCreate?: NullableStringFieldUpdateOperationsInput | string | null
    txHashLast?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeline?: EscrowTimelineUncheckedUpdateManyWithoutEscrowNestedInput
    messages?: EscrowMessageUncheckedUpdateManyWithoutEscrowNestedInput
    paymentInstruction?: EscrowPaymentInstructionUncheckedUpdateOneWithoutEscrowNestedInput
    fiatStatuses?: EscrowFiatStatusUncheckedUpdateManyWithoutEscrowNestedInput
    evidence?: EvidenceItemUncheckedUpdateManyWithoutEscrowNestedInput
  }

  export type UserCreateWithoutNotificationPreferenceInput = {
    address: string
    displayName?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    roles?: RoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferenceInput = {
    address: string
    displayName?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    roles?: RoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
  }

  export type UserUpsertWithoutNotificationPreferenceInput = {
    update: XOR<UserUpdateWithoutNotificationPreferenceInput, UserUncheckedUpdateWithoutNotificationPreferenceInput>
    create: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferenceInput, UserUncheckedUpdateWithoutNotificationPreferenceInput>
  }

  export type UserUpdateWithoutNotificationPreferenceInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferenceInput = {
    address?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleCreateManyUserInput = {
    id?: string
    role: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type RoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowTimelineCreateManyEscrowInput = {
    id?: bigint | number
    chainId: number
    eventName: string
    stateAfter: string
    txHash: string
    blockNumber: bigint | number
    logIndex: number
    timestamp: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type EscrowMessageCreateManyEscrowInput = {
    id?: string
    sender: string
    text: string
    attachment?: string | null
    hash?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
  }

  export type EscrowFiatStatusCreateManyEscrowInput = {
    id?: bigint | number
    actor: string
    status: string
    note?: string | null
    createdAt?: Date | string
  }

  export type EvidenceItemCreateManyEscrowInput = {
    id?: string
    uploader: string
    uri: string
    sha256: string
    mime: string
    size: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type EscrowTimelineUpdateWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUncheckedUpdateWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowTimelineUncheckedUpdateManyWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chainId?: IntFieldUpdateOperationsInput | number
    eventName?: StringFieldUpdateOperationsInput | string
    stateAfter?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type EscrowMessageUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowMessageUncheckedUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowMessageUncheckedUpdateManyWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EscrowFiatStatusUpdateWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusUncheckedUpdateWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscrowFiatStatusUncheckedUpdateManyWithoutEscrowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    actor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemUncheckedUpdateWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceItemUncheckedUpdateManyWithoutEscrowInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploader?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    sha256?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowCountOutputTypeDefaultArgs instead
     */
    export type EscrowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowDefaultArgs instead
     */
    export type EscrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowTimelineDefaultArgs instead
     */
    export type EscrowTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowTimelineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowMessageDefaultArgs instead
     */
    export type EscrowMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowPaymentInstructionDefaultArgs instead
     */
    export type EscrowPaymentInstructionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowPaymentInstructionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscrowFiatStatusDefaultArgs instead
     */
    export type EscrowFiatStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscrowFiatStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenceItemDefaultArgs instead
     */
    export type EvidenceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DisputeDefaultArgs instead
     */
    export type DisputeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DisputeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndexerCheckpointDefaultArgs instead
     */
    export type IndexerCheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndexerCheckpointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenRegistryDefaultArgs instead
     */
    export type TokenRegistryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenRegistryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NonceDefaultArgs instead
     */
    export type NonceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NonceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationPreferenceDefaultArgs instead
     */
    export type NotificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationPreferenceDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}