generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  address     String    @id
  displayName String?
  bio         String?
  paymentMethods String[]
  createdAt   DateTime  @default(now())
  lastLoginAt DateTime?
  roles       Role[]
  notificationPreference NotificationPreference?
  referralCodes ReferralCode[]
  referralsMade Referral[] @relation("ReferrerUser")
  referralsReceived Referral[] @relation("RefereeUser")
  referralWallet ReferralWallet?
  prime         PrimeStatus?
  notifications Notification[]
  
  reputationScore Int      @default(0)
  successfulTrades Int     @default(0)
  totalVolume     Decimal  @default(0)

  reviewsGiven    TradeReview[] @relation("Reviewer")
  reviewsReceived TradeReview[] @relation("Reviewed")
  offers          Offer[]
}

model TradeReview {
  id              String   @id @default(uuid())
  tradeId         Bytes
  reviewerAddress String
  reviewedAddress String
  rating          Int
  reviewText      String?
  reviewTags      String[]
  tradeRole       String
  createdAt       DateTime @default(now())

  reviewer        User     @relation("Reviewer", fields: [reviewerAddress], references: [address])
  reviewed        User     @relation("Reviewed", fields: [reviewedAddress], references: [address])
  escrow          Escrow   @relation(fields: [tradeId], references: [escrowId])

  @@unique([tradeId, reviewerAddress])
  @@index([reviewedAddress])
}

model Role {
  id        String   @id @default(uuid())
  address   String
  role      String
  createdBy String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [address], references: [address])

  @@unique([address, role])
}

model Escrow {
  escrowId         Bytes      @id
  chainId          Int
  contractAddress  String
  tokenKey         String
  amount           Decimal
  feeAmount        Decimal
  sellerBond       Decimal
  buyerBond        Decimal
  state            String
  seller           String
  buyer            String?
  createdAtBlock   BigInt
  updatedAtBlock   BigInt
  txHashCreate     String?
  txHashLast       String?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  timeline         EscrowTimeline[]
  messages         EscrowMessage[]
  paymentInstruction EscrowPaymentInstruction?
  fiatStatuses     EscrowFiatStatus[]
  evidence         EvidenceItem[]
  dispute          Dispute?
  reviews          TradeReview[]

  @@index([seller])
  @@index([buyer])
  @@index([state])
  @@index([tokenKey])
}

model EscrowTimeline {
  id          BigInt   @id @default(autoincrement())
  escrowId    Bytes
  chainId     Int
  eventName   String
  stateAfter  String
  txHash      String
  blockNumber BigInt
  logIndex    Int
  timestamp   DateTime
  payload     Json
  Escrow      Escrow   @relation(fields: [escrowId], references: [escrowId])

  @@index([escrowId])
  @@index([blockNumber])
  @@unique([escrowId, blockNumber, logIndex])
}

model EscrowMessage {
  id         String    @id @default(uuid())
  escrowId   Bytes?
  sender     String
  text       String
  attachment String?
  hash       String?
  createdAt  DateTime  @default(now())
  editedAt   DateTime?
  Escrow     Escrow?   @relation(fields: [escrowId], references: [escrowId])
}

model EscrowPaymentInstruction {
  escrowId  Bytes     @id
  seller    String
  content   Json?
  updatedAt DateTime  @updatedAt
  Escrow    Escrow    @relation(fields: [escrowId], references: [escrowId])
}

model EscrowFiatStatus {
  id        BigInt   @id @default(autoincrement())
  escrowId  Bytes?
  actor     String
  status    String
  note      String?
  createdAt DateTime @default(now())
  Escrow    Escrow?  @relation(fields: [escrowId], references: [escrowId])
}

model EvidenceItem {
  id          String   @id @default(uuid())
  escrowId    Bytes?
  uploader    String
  uri         String
  sha256      String
  mime        String
  size        BigInt
  description String?
  createdAt   DateTime @default(now())
  Escrow      Escrow?  @relation(fields: [escrowId], references: [escrowId])

  @@index([escrowId])
}

model Dispute {
  escrowId          Bytes   @id
  openedBy         String
  reasonCode       String?
  summary          String?
  status           String
  arbitratorAssigned String?
  outcome          String?
  ref              Bytes?
  escalationLevel  Int      @default(1)
  aiAnalysis       Json?
  tier2Analysis    Json?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  Escrow           Escrow   @relation(fields: [escrowId], references: [escrowId])

  @@index([status])
}

model IndexerCheckpoint {
  chainId        Int
  contractAddress String
  lastSyncedBlock BigInt
  updatedAt      DateTime @default(now())

  @@id([chainId, contractAddress])
}

model TokenRegistry {
  chainId  Int
  tokenKey String
  symbol   String
  decimals Int
  name     String
  enabled  Boolean @default(true)

  @@id([chainId, tokenKey])
}

model AuditLog {
  id         String   @id @default(uuid())
  actorAddress String?
  action     String
  target     String?
  metadata   Json?
  createdAt  DateTime @default(now())
}

model Nonce {
  id             String   @id @default(uuid())
  address        String
  value          String   /// hashed nonce value
  chainId        Int
  domain         String?
  issuedAt       DateTime
  expiresAt      DateTime
  used           Boolean  @default(false)
  createdAt      DateTime @default(now())

  @@index([address])
  @@index([used])
  @@unique([address, value])
}

model NotificationPreference {
  address     String   @id
  webhookUrl  String?
  telegramId  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [address], references: [address])

  @@index([address])
}

model Notification {
  id          String   @id @default(uuid())
  address     String
  type        String
  title       String
  message     String
  read        Boolean  @default(false)
  link        String?
  metadata    Json?
  createdAt   DateTime @default(now())
  
  user        User     @relation(fields: [address], references: [address])

  @@index([address])
  @@index([read])
}

model ReferralCode {
  id           String   @id @default(uuid())
  address      String
  code         String   @unique
  referralLink String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [address], references: [address])
  referrals    Referral[]

  @@unique([address])
}

model Referral {
  id              String   @id @default(uuid())
  referrerAddress String
  refereeAddress  String
  referralCodeId  String
  qualified       Boolean  @default(false)
  qualifiedAt     DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  referrer        User     @relation("ReferrerUser", fields: [referrerAddress], references: [address])
  referee         User     @relation("RefereeUser", fields: [refereeAddress], references: [address])
  referralCode    ReferralCode @relation(fields: [referralCodeId], references: [id])
  commissions     CommissionLedger[]

  @@index([referrerAddress])
  @@index([refereeAddress])
}

model CommissionLedger {
  id               String   @id @default(uuid())
  referralId       String
  feeAmount        Decimal
  commissionRate   Decimal
  commissionAmount Decimal
  feeType          String
  createdAt        DateTime @default(now())
  referral         Referral @relation(fields: [referralId], references: [id])

  @@index([referralId])
}

model ReferralWallet {
  id        String   @id @default(uuid())
  address   String
  balance   Decimal  @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [address], references: [address])
  transactions ReferralWalletTransaction[]

  @@index([address])
  @@unique([address])
}

model ReferralWalletTransaction {
  id        String   @id @default(uuid())
  walletId  String
  amount    Decimal
  type      String   /// withdrawal | transfer
  status    String   /// pending | completed | failed
  targetAddress String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  wallet    ReferralWallet @relation(fields: [walletId], references: [id])

  @@index([walletId])
}

model PrimeStatus {
  id                  String   @id @default(uuid())
  address             String
  isPrime             Boolean  @default(false)
  primeActivatedAt    DateTime?
  referralCount       Int      @default(0)
  qualifiedReferralCount Int   @default(0)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User     @relation(fields: [address], references: [address])

  @@index([address])
  @@unique([address])
}

model ReferralConfig {
  id                 String   @id @default(uuid())
  commissionRate     Decimal  @default(0.20) /// 20% default
  eligibleFeeTypes   String   @default("maker,taker")
  primeUnlockThreshold Int    @default(3)    /// qualified referrals needed
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model Offer {
  id              String   @id @default(uuid())
  creator         String
  type            String   /// BUY | SELL
  token           String   /// e.g. USDT, ETH
  currency        String   /// e.g. USD, EUR
  priceType       String   /// FIXED | MARKET
  price           Decimal
  minAmount       Decimal
  maxAmount       Decimal
  paymentMethods  String[]
  terms           String?
  status          String   /// ACTIVE | PAUSED | CLOSED
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User     @relation(fields: [creator], references: [address])

  @@index([creator])
  @@index([token])
  @@index([currency])
  @@index([status])
}
